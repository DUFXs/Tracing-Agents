{
    "instance_id": "django__django-11532",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "django/core/mail/message.py": "index e393b4cf5c..512abf7621 100644\n     except UnicodeEncodeError:\n         if name.lower() in ADDRESS_HEADERS:\n             val = ', '.join(sanitize_address(addr, encoding) for addr in getaddresses((val,)))\nelif name.lower() == 'message-id':\n# For Message-ID, ensure domain part is IDNA encoded\nat_idx = val.rindex('@')\nlocalpart, domain = val[:at_idx], val[at_idx + 1:]\ntry:\ndomain = domain.encode('idna').decode('ascii')\nval = localpart + '@' + domain\nexcept UnicodeError:\nval = Header(val, encoding).encode()\n         else:\n             val = Header(val, encoding).encode()\n     else:\n     return name, val\n \n \n\n def sanitize_address(addr, encoding):\n     \"\"\"\n     Format a pair of (name, address) or an email address string.\n             for alternative in self.alternatives:\n                 msg.attach(self._create_mime_attachment(*alternative))\n         return msg\n\n",
        "django/core/mail/utils.py": "index d18dfe4667..ce71944bf7 100644\n     def get_fqdn(self):\n         if not hasattr(self, '_fqdn'):\n             self._fqdn = socket.getfqdn()\n# Convert domain to IDNA/punycode for non-ASCII hostnames\ntry:\nreturn self._fqdn.encode('idna').decode('ascii')\nexcept UnicodeError:\n# If IDNA encoding fails, try to return ASCII portion\ntry:\nreturn self._fqdn.encode('ascii', 'ignore').decode('ascii')\nexcept UnicodeError:\nreturn 'localhost'\n \n \n DNS_NAME = CachedDnsName()\n\n",
        "reproduce.py": "new file mode 100644\nindex 0000000000..50958ec6b2\nfrom django.conf import settings\nsettings.configure()\n\nfrom unittest.mock import patch\nfrom django.core.mail import EmailMessage\n\ndef test_unicode_dns():\nwith patch(\"django.core.mail.message.DNS_NAME\", \"\u6f22\u5b57\"):\nemail = EmailMessage('subject', '', 'from@example.com', ['to@example.com'])\nemail.encoding = 'iso-8859-1'\nmessage = email.message()\nprint(\"Message ID:\", message['Message-ID'])\n\nif __name__ == \"__main__\":\ntest_unicode_dns()\n"
    },
    "ground_truth_patch": {
        "django/core/mail/message.py": " \n from django.conf import settings\n from django.core.mail.utils import DNS_NAME\nfrom django.utils.encoding import force_str, punycode\n \n # Don't BASE64-encode UTF-8 messages so that we avoid unwanted attention from\n # some spam filters.\n         localpart.encode('ascii')\n     except UnicodeEncodeError:\n         localpart = Header(localpart, encoding).encode()\ndomain = punycode(domain)\n \n     parsed_address = Address(nm, username=localpart, domain=domain)\n     return str(parsed_address)\n",
        "django/core/mail/utils.py": " \n import socket\n \nfrom django.utils.encoding import punycode\n\n \n # Cache the hostname, but do it lazily: socket.getfqdn() can take a couple of\n # seconds, which slows down the restart of the server.\n \n     def get_fqdn(self):\n         if not hasattr(self, '_fqdn'):\nself._fqdn = punycode(socket.getfqdn())\n         return self._fqdn\n \n \n",
        "django/core/validators.py": " \n from django.core.exceptions import ValidationError\n from django.utils.deconstruct import deconstructible\nfrom django.utils.encoding import punycode\n from django.utils.functional import SimpleLazyObject\n from django.utils.ipv6 import is_valid_ipv6_address\n from django.utils.translation import gettext_lazy as _, ngettext_lazy\n                 except ValueError:  # for example, \"Invalid IPv6 URL\"\n                     raise ValidationError(self.message, code=self.code)\n                 try:\nnetloc = punycode(netloc)  # IDN -> ACE\n                 except UnicodeError:  # invalid domain part\n                     raise e\n                 url = urlunsplit((scheme, netloc, path, query, fragment))\n                 not self.validate_domain_part(domain_part)):\n             # Try for possible IDN domain-part\n             try:\ndomain_part = punycode(domain_part)\n             except UnicodeError:\n                 pass\n             else:\n",
        "django/utils/encoding.py": "     return quote(path, safe=\"/:@&+$,-_.!~*'()\")\n \n \ndef punycode(domain):\n\"\"\"Return the Punycode of the given domain if it's non-ASCII.\"\"\"\nreturn domain.encode('idna').decode('ascii')\n\n\n def repercent_broken_unicode(path):\n     \"\"\"\n     As per section 3.2 of RFC 3987, step three of converting a URI into an IRI,\n",
        "django/utils/html.py": "     parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit,\n )\n \nfrom django.utils.encoding import punycode\n from django.utils.functional import Promise, keep_lazy, keep_lazy_text\n from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS\n from django.utils.safestring import SafeData, SafeString, mark_safe\n         return unquote_quote(url)\n \n     try:\nnetloc = punycode(netloc)  # IDN -> ACE\n     except UnicodeError:  # invalid domain part\n         return unquote_quote(url)\n \n             elif ':' not in middle and is_email_simple(middle):\n                 local, domain = middle.rsplit('@', 1)\n                 try:\ndomain = punycode(domain)\n                 except UnicodeError:\n                     continue\n                 url = 'mailto:%s@%s' % (local, domain)\n"
    },
    "response": "{\n\"explanation\": \"The code in code sample 1 handles IDNA (Internationalized Domain Names in Applications) encoding of domain names in two contexts: one in message.py for handling Message-ID headers in email messages, and another in utils.py for handling fully qualified domain names (FQDN). Both implementations attempt to encode domain parts using IDNA encoding and fall back to different strategies if that fails. The code in code sample 2 introduces a new utility function called 'punycode' in encoding.py that encapsulates this IDNA encoding functionality, and then uses this function across multiple files (message.py, utils.py, validators.py, html.py) to handle domain name encoding.\",\n\"is_clone\": true,\n\"classification\": \"type-3\",\n\"reasoning\": \"These code samples are type-3 clones because they both handle the same fundamental operation (IDNA encoding of domain names) but with different implementations. The first sample implements the encoding directly using try-except blocks with encode('idna').decode('ascii'), while the second sample refactors this functionality into a centralized punycode() function that's reused across multiple files. The core functionality (IDNA encoding) remains the same, but the structure has been modified to improve code reuse and maintainability. This represents a syntactically similar operation with modifications in how the code is structured and called, which is characteristic of type-3 clones.\"\n}"
}