{
    "instance_id": "django__django-12774",
    "agent": "20241202_agentless-1.5_claude-3.5-sonnet-20241022",
    "agent_patch": {
        "django/db/models/query.py": "index 398c1d7..6471a3b 100644\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\nif field_name != 'pk':\nfield = self.model._meta.get_field(field_name)\nis_unique = (\nfield.unique or\nany(\nconstraint.fields == (field_name,)\nfor constraint in self.model._meta.total_unique_constraints\n)\n)\nif not is_unique:\nraise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n                 return {}\n"
    },
    "ground_truth_patch": {
        "django/db/models/query.py": "         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\nopts = self.model._meta\nunique_fields = [\nconstraint.fields[0]\nfor constraint in opts.total_unique_constraints\nif len(constraint.fields) == 1\n]\nif (\nfield_name != 'pk' and\nnot opts.get_field(field_name).unique and\nfield_name not in unique_fields\n):\n             raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n"
    },
    "response": "{\n\"explanation\": \"The code in code sample 1 checks if a given field_name is unique by examining if the field has a unique constraint directly or if it's part of a single-field unique constraint in the model's metadata. If the field is not unique, it raises a ValueError. The code in code sample 2 does essentially the same thing but uses a different approach: it first creates a list of all single-field unique constraints and then checks if the field_name is either the primary key, has a unique constraint directly, or is in the list of unique fields. Both code samples have the same validation logic for empty id_list.\",\n\"is_clone\": true,\n\"classification\": \"type-3\",\n\"reasoning\": \"These code samples are type-3 clones because they perform the same functionality (checking if a field is unique and raising an error if it's not) but use different syntactical structures to achieve it. Sample 1 uses a more direct approach with an 'any' expression, while Sample 2 first builds a list of unique fields and then checks membership. The code has been modified and restructured, but the core functionality and purpose remain the same. Both samples share similar error messages and the same handling of id_list, but the main uniqueness checking logic is implemented differently while maintaining the same semantic meaning.\"\n}"
}