{
    "instance_id": "django__django-14053",
    "agent": "20241202_agentless-1.5_claude-3.5-sonnet-20241022",
    "agent_patch": {
        "django/contrib/staticfiles/storage.py": "index 04c866a..dc07d26 100644\n             path for path in paths\n             if matches_patterns(path, self._patterns)\n         ]\n# Track which files have been yielded\nyielded_files = set()\n\n         # Do a single pass first. Post-process all files once, then repeat for\n         # adjustable files.\n         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):\nif processed and name not in yielded_files:\nyield name, hashed_name, processed\nyielded_files.add(name)\n \n         paths = {path: paths[path] for path in adjustable_paths}\n \n         for i in range(self.max_post_process_passes):\n             substitutions = False\n             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\nif processed and subst and name not in yielded_files:\nyield name, hashed_name, processed\nyielded_files.add(name)\n                 substitutions = substitutions or subst\n \n             if not substitutions:\n"
    },
    "ground_truth_patch": {
        "django/contrib/staticfiles/storage.py": "             path for path in paths\n             if matches_patterns(path, self._patterns)\n         ]\n\n# Adjustable files to yield at end, keyed by the original path.\nprocessed_adjustable_paths = {}\n\n# Do a single pass first. Post-process all files once, yielding not\n# adjustable files and exceptions, and collecting adjustable files.\n         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):\nif name not in adjustable_paths or isinstance(processed, Exception):\nyield name, hashed_name, processed\nelse:\nprocessed_adjustable_paths[name] = (name, hashed_name, processed)\n \n         paths = {path: paths[path] for path in adjustable_paths}\n \n         for i in range(self.max_post_process_passes):\n             substitutions = False\n             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\n# Overwrite since hashed_name may be newer.\nprocessed_adjustable_paths[name] = (name, hashed_name, processed)\n                 substitutions = substitutions or subst\n \n             if not substitutions:\n         # Store the processed paths\n         self.hashed_files.update(hashed_files)\n \n# Yield adjustable files with final, hashed name.\nyield from processed_adjustable_paths.values()\n\n     def _post_process(self, paths, adjustable_paths, hashed_files):\n         # Sort the files by directory level\n         def path_level(name):\n"
    },
    "response": "{\n    \"explanation\": \"The code in code sample 1 processes static files using a yielded_files set to track which files have been processed, and yields files immediately after processing. It uses a two-pass system: first processing all files once, then repeating for adjustable files. The code in code sample 2 also processes static files but uses a different approach with a processed_adjustable_paths dictionary to collect adjustable files first, then yield them all at the end. It separates the handling of adjustable and non-adjustable files more explicitly.\",\n    \"is_clone\": true,\n    \"classification\": \"type-3\",\n    \"reasoning\": \"These code samples are type-3 clones because they share the same basic structure and purpose (processing static files with multiple passes), but have modified statements and different implementation strategies. Key differences include:\n    1. Sample 1 uses a set (yielded_files) to track processed files, while Sample 2 uses a dictionary (processed_adjustable_paths)\n    2. Sample 1 yields files immediately after processing, while Sample 2 collects adjustable files and yields them at the end\n    3. Sample 2 has additional logic for handling exceptions and separating adjustable/non-adjustable files\n    4. The core loop structure and purpose remain similar, but the implementation details and control flow are modified\n    These modifications make them type-3 clones as they maintain similar syntax and structure but have added, modified, and removed statements while preserving the overall functionality.\"\n}"
}