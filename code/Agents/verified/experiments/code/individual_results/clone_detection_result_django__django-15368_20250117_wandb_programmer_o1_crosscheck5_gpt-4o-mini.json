{
    "instance_id": "django__django-15368",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/query.py": "index f8d848e926..f41a42c9c0 100644\n                 when_statements = []\n                 for obj in batch_objs:\n                     attr = getattr(obj, field.attname)\n# Replaced the narrow isinstance(attr, Expression) check:\nif not hasattr(attr, 'resolve_expression'):\n                         attr = Value(attr, output_field=field)\n                     when_statements.append(When(pk=obj.pk, then=attr))\n                 case_statement = Case(*when_statements, output_field=field)\n                 if requires_casting:\nfrom django.db.models.functions import Cast\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\n         rows_updated = 0\nfrom django.db import transaction\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\n                 rows_updated += self.filter(pk__in=pks).update(**update_kwargs)\n         return rows_updated\n\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n",
        "test_bulk_update_f_expression.py": "new file mode 100644\nindex 0000000000..06b3570c3b\nimport sys\nimport django\nfrom django.conf import settings\nfrom django.apps import AppConfig, apps\nfrom django.db import models, connection\nfrom django.db.models import F\nimport traceback\n\nclass TestAppConfig(AppConfig):\nname = \"test_bulk_update_f_expression\"\nlabel = \"testapp\"\n\ndef main():\nprint(\"Setting up test environment...\", flush=True)\nsettings.configure(\nINSTALLED_APPS=[\"test_bulk_update_f_expression.TestAppConfig\"],\nDATABASES={\n\"default\": {\n\"ENGINE\": \"django.db.backends.sqlite3\",\n\"NAME\": \":memory:\",\n}\n},\nMIDDLEWARE=[],\nSECRET_KEY=\"test_secret_key\",\nDEFAULT_AUTO_FIELD=\"django.db.models.AutoField\",\n)\ndjango.setup()\n\nclass MyModel(models.Model):\nname = models.CharField(max_length=100)\nc8 = models.CharField(max_length=100, null=True)\n\nclass Meta:\napp_label = \"testapp\"\n\n# Register the model with the app registry, ignoring if it's already there.\ntry:\napps.register_model(\"testapp\", MyModel)\nexcept RuntimeError:\npass\n\nprint(\"Creating table with schema_editor...\", flush=True)\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(MyModel)\n\nprint(\"Inserting a test row...\", flush=True)\nobj = MyModel.objects.create(name=\"TEST\")\n\nprint(\"Assigning F('name') to c8 and calling bulk_update...\", flush=True)\nobj.c8 = F(\"name\")\ntry:\nMyModel.objects.bulk_update([obj], [\"c8\"])\nexcept Exception:\nprint(\"Exception occurred during bulk_update:\", flush=True)\ntraceback.print_exc()\nsys.exit(1)\n\nobj.refresh_from_db()\nprint(f\"c8 after refresh_from_db(): '{obj.c8}' ; name: '{obj.name}'\")\n\n# On HEAD, the bug occurs: c8 == 'F(name)' when it should match 'TEST'.\n# We'll exit 2 if c8 != name to confirm the bug is present.\nif obj.c8 == obj.name:\nprint(\"Test PASSED unexpectedly. c8 matches the name column value.\")\nsys.exit(0)\nelse:\nprint(f\"Test FAILED as expected: c8 ('{obj.c8}') != name ('{obj.name}')\")\nsys.exit(2)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/models/query.py": " from django.db.models import AutoField, DateField, DateTimeField, sql\n from django.db.models.constants import LOOKUP_SEP, OnConflict\n from django.db.models.deletion import Collector\nfrom django.db.models.expressions import Case, F, Ref, Value, When\n from django.db.models.functions import Cast, Trunc\n from django.db.models.query_utils import FilteredRelation, Q\n from django.db.models.sql.constants import CURSOR, GET_ITERATOR_CHUNK_SIZE\n                 when_statements = []\n                 for obj in batch_objs:\n                     attr = getattr(obj, field.attname)\nif not hasattr(attr, 'resolve_expression'):\n                         attr = Value(attr, output_field=field)\n                     when_statements.append(When(pk=obj.pk, then=attr))\n                 case_statement = Case(*when_statements, output_field=field)\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share a similar structure and logic, but there are modifications and omissions in the content of the two samples. For example, both have similar loops and conditionals, yet the second sample has a more simplified context, omitting functionalities such as transaction handling and certain imports that are present in the first sample. Thus, they are syntactically similar with added, modified, or removed statements.\"}"
}