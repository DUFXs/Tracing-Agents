{
    "instance_id": "sympy__sympy-24562",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "sympy/core/numbers.py": "index 52f7ea45ad..c1914ca555 100644\n \n     @cacheit\n     def __new__(cls, p, q=None, gcd=None):\n# If only 1 argument, that is p, q=None\n         if q is None:\n             if isinstance(p, Rational):\n                 return p\n             if isinstance(p, SYMPY_INTS):\nreturn Integer(p)\n             else:\n                 if isinstance(p, (float, Float)):\n                     return Rational(*_as_integer_ratio(p))\n                 if not isinstance(p, str):\n                     try:\n                         p = sympify(p)\n                         pass  # error will raise below\n                     else:\n                         return Rational(p.numerator, p.denominator, 1)\n                 if not isinstance(p, Rational):\n                     raise TypeError('invalid input: %s' % p)\nq = 1\ngcd = 1\n\n# If q is not None, we proceed with the standard logic\n# First, convert p to Rational if needed\n         if not isinstance(p, SYMPY_INTS):\n             p = Rational(p)\n# Then convert q to Rational if needed, so we don't do string multiplication\nif not isinstance(q, SYMPY_INTS):\nq = Rational(q)\n             q *= p.q\n             p = p.p\n         else:\n             p = int(p)\n\n# Next, convert q if needed\n         if not isinstance(q, SYMPY_INTS):\n             q = Rational(q)\n             p *= q.q\n             q = q.p\n         else:\n             q = int(q)\n\n# Now do the rest of the logic\n         if q == 0:\n             if p == 0:\n                 if _errdict[\"divide\"]:\n             q = -q\n             p = -p\n         if not gcd:\ngcd_ = igcd(abs(p), q)\nelse:\ngcd_ = gcd\nif gcd_ > 1:\np //= gcd_\nq //= gcd_\n         if q == 1:\n             return Integer(p)\n         if p == 1 and q == 2:\n         obj.p = p\n         obj.q = q\n         return obj\n\n \n     def limit_denominator(self, max_denominator=1000000):\n         \"\"\"Closest Rational to self with denominator at most max_denominator.\n",
        "test_rational_bug.py": "new file mode 100644\nindex 0000000000..af612231f7\nimport sys\nfrom sympy import Rational\n\ndef main():\nprint(\"Reproduction test for Rational('0.5', '100') bug.\")\nbug_value = Rational('0.5', '100')\nprint(\"Computed value:\", bug_value)\nexpected = Rational(1, 200)\nprint(\"Expected value:\", expected)\n\nif bug_value == expected:\nprint(\"TEST PASSED: The bug is apparently fixed.\")\nsys.exit(0)\nelse:\nprint(\"TEST FAILED: Got {}, instead of {}.\".format(bug_value, expected))\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "sympy/core/numbers.py": " \n             q = 1\n             gcd = 1\nQ = 1\n \n         if not isinstance(p, SYMPY_INTS):\n             p = Rational(p)\nQ *= p.q\n             p = p.p\n         else:\n             p = int(p)\n         if not isinstance(q, SYMPY_INTS):\n             q = Rational(q)\n             p *= q.q\nQ *= q.p\n         else:\nQ *= int(q)\nq = Q\n \n         # p and q are now ints\n         if q == 0:\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they exhibit significant differences in both structure and content. The second code sample has statements that are completely absent in the first code sample, and some identifiers have been modified (e.g., 'q' has 'Q' in the second sample). Furthermore, the second sample introduces new logic (like the variable 'Q') that does not appear in the first sample, making them syntactically dissimilar and functionally distinct.\"}"
}