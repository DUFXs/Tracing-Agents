{
    "instance_id": "django__django-13590",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/db/models/sql/query.py": "index 4648daf395..cfc2168064 100644\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\nresolved_values = [\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n]\n# For named tuples, we need to unpack the values\nif hasattr(value, '_fields'):\nreturn type(value)(*resolved_values)\nreturn type(value)(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..1647c734bd\nfrom collections import namedtuple\nfrom django.db import models\nfrom django.db.models.sql.query import Query\nfrom django.conf import settings\nimport django\n\n# Configure Django settings\nif not settings.configured:\nsettings.configure(\nDATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3'}},\nINSTALLED_APPS=['django.contrib.contenttypes'],\n)\ndjango.setup()\n\n# Create a simple model for testing\nclass TestModel(models.Model):\nvalue = models.IntegerField()\n\nclass Meta:\napp_label = 'test_app'\n\n# Create a named tuple for testing\nRange = namedtuple('Range', ['near', 'far'])\ntest_range = Range(near=1, far=10)\n\n# Create a query instance\nquery = Query(TestModel)\n\n# Try to resolve the lookup value\ntry:\n# This simulates what happens when using a named tuple in a range filter\nresolved = query.resolve_lookup_value(test_range, can_reuse=None, allow_joins=True)\nprint(\"Success! Resolved value:\", resolved)\nexcept TypeError as e:\nprint(\"Error occurred as expected:\", str(e))\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/query.py": "         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\nvalues = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\ntype_ = type(value)\nif hasattr(type_, '_make'):  # namedtuple\nreturn type_(*values)\nreturn type_(values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they are syntactically similar but include added, modified, or removed statements. The first sample uses a list comprehension to generate 'resolved_values', while the second uses a generator expression to create 'values'. Furthermore, the handling of the type check and return structure varies slightly, indicating modifications in structure while retaining overall logic.\"}"
}