{
    "instance_id": "django__django-13315",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/forms/models.py": "index 5d115458a1..2c8307b6f5 100644\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\nformfield.queryset = formfield.queryset.complex_filter(limit_choices_to).distinct()\n\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n",
        "tests/test_duplicate_choices.py": "new file mode 100644\nindex 0000000000..4d76ca1769\nimport sys\nimport django\nfrom django.conf import settings\nfrom django.core.management import call_command\n\nif not settings.configured:\nsettings.configure(\nINSTALLED_APPS=[\n\"django.contrib.contenttypes\",\n\"django.contrib.auth\",\n\"tests.test_duplicate_choices_app\",\n],\nSECRET_KEY=\"not very secret\",\nDATABASES={\n\"default\": {\n\"ENGINE\": \"django.db.backends.sqlite3\",\n\"NAME\": \":memory:\",\n}\n},\nMIGRATION_MODULES={\"test_duplicate_choices_app\": None},\n)\n\ndjango.setup()\n\nfrom tests.test_duplicate_choices_app.models import Category, Topping\nfrom tests.test_duplicate_choices_app.forms import PizzaForm\n\ndef main():\ncall_command(\"migrate\", run_syncdb=True, verbosity=0)\n\ncat1 = Category.objects.create(name=\"VegCheese\", is_vegetarian=True)\ncat2 = Category.objects.create(name=\"VegCheese2\", is_vegetarian=True)\ncat3 = Category.objects.create(name=\"Meat\", is_vegetarian=False)\n\n# Create toppings with multiple categories for at least one topping, to force duplicates\nt1 = Topping.objects.create(name=\"Cheese1\")\nt1.categories.add(cat1)  # single vegetarian category\n\nt2 = Topping.objects.create(name=\"Cheese2\")\nt2.categories.add(cat1, cat2)  # multiple vegetarian categories => duplicates\n\nt3 = Topping.objects.create(name=\"Meat1\")\nt3.categories.add(cat3)  # non-vegetarian\n\nfrom tests.test_duplicate_choices_app.forms import PizzaForm\nform = PizzaForm()\nlabeled_choices = [label for value, label in form.fields[\"topping\"].choices]\nprint(\"Topping choices (labels):\", labeled_choices)\n\n# Fails if duplicates are found\nif len(labeled_choices) != len(set(labeled_choices)):\nprint(\"Found duplicate choices in topping field. Test fails.\")\nsys.exit(1)\nelse:\nprint(\"No duplicate choices found. Test passes.\")\nsys.exit(0)\n\n\nif __name__ == \"__main__\":\nmain()\n",
        "tests/test_duplicate_choices_app/__init__.py": "new file mode 100644\nindex 0000000000..969ace0722\n# Empty __init__ to make this directory a Python package\n",
        "tests/test_duplicate_choices_app/apps.py": "new file mode 100644\nindex 0000000000..6ed97ce2b0\nfrom django.apps import AppConfig\n\nclass TestDupChoicesAppConfig(AppConfig):\nname = \"tests.test_duplicate_choices_app\"\nlabel = \"test_duplicate_choices_app\"\n",
        "tests/test_duplicate_choices_app/forms.py": "new file mode 100644\nindex 0000000000..51f6c3a3c9\nfrom django.forms import ModelForm\nfrom .models import Pizza\n\nclass PizzaForm(ModelForm):\nclass Meta:\nmodel = Pizza\nfields = [\"topping\"]\n",
        "tests/test_duplicate_choices_app/models.py": "new file mode 100644\nindex 0000000000..f4a86251af\nfrom django.db import models\nfrom django.db.models import Q\n\nclass Category(models.Model):\nname = models.CharField(max_length=100)\nis_vegetarian = models.BooleanField(default=False)\n\nclass Meta:\napp_label = \"test_duplicate_choices_app\"\n\nclass Topping(models.Model):\nname = models.CharField(max_length=50)\ncategories = models.ManyToManyField(Category)\n\nclass Meta:\napp_label = \"test_duplicate_choices_app\"\n\n\nclass Pizza(models.Model):\ntopping = models.ForeignKey(\nTopping,\nlimit_choices_to=Q(categories__is_vegetarian=True),\non_delete=models.CASCADE,\nrelated_name=\"pizzas\",\n)\n\nclass Meta:\napp_label = \"test_duplicate_choices_app\"\n\n"
    },
    "ground_truth_patch": {
        "django/forms/models.py": " \n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\nfrom django.db.models import Exists, OuterRef, Q\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\nif limit_choices_to:\ncomplex_filter = limit_choices_to\nif not isinstance(complex_filter, Q):\ncomplex_filter = Q(**limit_choices_to)\ncomplex_filter &= Q(pk=OuterRef('pk'))\n# Use Exists() to avoid potential duplicates.\nformfield.queryset = formfield.queryset.filter(\nExists(formfield.queryset.model._base_manager.filter(complex_filter)),\n)\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarity; both involve functions that handle formfield querysets in Django. However, the second sample introduces additional statements and modifies the logic. Specifically, the second sample includes `Exists()` filtering and introduces a variable `complex_filter`, which is missing from the first. Thus, while they share a common purpose and structure, they diverge in their implementation.\"}"
}