{
    "instance_id": "django__django-12304",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/db/models/enums.py": "index f48143ddaf..4aa4ec8cfe 100644\n         # that is passed in as \"self\" as the value to use when looking up the\n         # label in the choices.\n         cls.label = property(lambda self: cls._value2label_map_.get(self.value))\n# Add do_not_call_in_templates to prevent template system from calling the enum\ncls.do_not_call_in_templates = True\n         return enum.unique(cls)\n \n     def __contains__(cls, member):\n         return str(self.value)\n \n \nclass IntegerChoices(enum.IntEnum, metaclass=ChoicesMeta):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n\ndef __str__(self):\n\"\"\"\nUse value when cast to str, so that Choices set as model instance\nattributes are rendered as expected in templates and similar contexts.\n\"\"\"\nreturn str(self.value)\n \n \nclass TextChoices(str, enum.Enum, metaclass=ChoicesMeta):\n     \"\"\"Class for creating enumerated string choices.\"\"\"\n \ndef __str__(self):\n\"\"\"\nUse value when cast to str, so that Choices set as model instance\nattributes are rendered as expected in templates and similar contexts.\n\"\"\"\nreturn str(self.value)\n\n     def _generate_next_value_(name, start, count, last_values):\n         return name\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..d81dca7a82\nfrom django.db import models\nfrom django.template import Context, Template\nfrom django.conf import settings\nimport django\n\n# Configure Django settings\nsettings.configure(\nTEMPLATES=[{\n'BACKEND': 'django.template.backends.django.DjangoTemplates',\n'APP_DIRS': True,\n}],\nINSTALLED_APPS=['django.contrib.contenttypes']\n)\n\n# Initialize Django\ndjango.setup()\n\nclass YearInSchool(models.TextChoices):\nFRESHMAN = 'FR', 'Freshman'\nSOPHOMORE = 'SO', 'Sophomore'\nJUNIOR = 'JR', 'Junior'\nSENIOR = 'SR', 'Senior'\n\n# Create a template that tests various enum comparisons\ntemplate = Template('''\n{% if year == YearInSchool.FRESHMAN %}Is Freshman{% endif %}\n{% if year == YearInSchool.SOPHOMORE %}Is Sophomore{% endif %}\n{% if year != YearInSchool.FRESHMAN %}Not Freshman{% endif %}\n{% if YearInSchool.FRESHMAN == \"FR\" %}Freshman equals FR{% endif %}\n''')\n\n# Test different scenarios\ntest_cases = [\n{'year': YearInSchool.FRESHMAN},\n{'year': YearInSchool.SOPHOMORE},\n{'year': 'FR'},  # Test raw value comparison\n]\n\nfor case in test_cases:\nprint(f\"\\nTesting with year = {case['year']}\")\ncontext = Context({**case, 'YearInSchool': YearInSchool})\ntry:\nresult = template.render(context)\nprint(\"Template rendered successfully:\")\nprint(result.strip())\nexcept Exception as e:\nprint(\"Error rendering template:\", str(e))\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/db/models/enums.py": "         # that is passed in as \"self\" as the value to use when looking up the\n         # label in the choices.\n         cls.label = property(lambda self: cls._value2label_map_.get(self.value))\ncls.do_not_call_in_templates = True\n         return enum.unique(cls)\n \n     def __contains__(cls, member):\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for minor formatting issues like whitespace. The actual content and structure of the code are the same.\"}"
}