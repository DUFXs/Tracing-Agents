{
    "instance_id": "django__django-16642",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/http/response.py": "index f62dec8ce9..0aa375cc4c 100644\n     def set_headers(self, filelike):\n         \"\"\"\n         Set some common response headers (Content-Length, Content-Type, and\nContent-Disposition) based on the filelike response content.\n         \"\"\"\nimport mimetypes\n         filename = getattr(filelike, \"name\", \"\")\n         filename = filename if isinstance(filename, str) else \"\"\n         seekable = hasattr(filelike, \"seek\") and (\n                 iter(lambda: len(filelike.read(self.block_size)), 0)\n             )\n             filelike.seek(-int(self.headers[\"Content-Length\"]), io.SEEK_END)\n\n         filename = os.path.basename(self.filename or filename)\n         if self._no_explicit_content_type:\n             if filename:\n# Register .Z and .br so guess_type() sees them properly.\nmimetypes.add_type(\"application/x-compress\", \".Z\", strict=False)\nmimetypes.add_type(\"application/x-brotli\", \".br\", strict=False)\n\n                 content_type, encoding = mimetypes.guess_type(filename)\n# If guess_type detects a compression encoding (e.g. compress, br),\n# override the content_type to reflect the actual compressed type\n# instead of a text-based main extension.\nencoding_map = {\n                     \"bzip2\": \"application/x-bzip\",\n                     \"gzip\": \"application/gzip\",\n                     \"xz\": \"application/x-xz\",\n\"compress\": \"application/x-compress\",\n\"br\": \"application/x-brotli\",\n}\ncontent_type = encoding_map.get(encoding, content_type)\nself.headers[\"Content-Type\"] = content_type or \"application/octet-stream\"\n             else:\n                 self.headers[\"Content-Type\"] = \"application/octet-stream\"\n\nif content_disposition := content_disposition_header(self.as_attachment, filename):\n             self.headers[\"Content-Disposition\"] = content_disposition\n\n\n \n \n class HttpResponseRedirectBase(HttpResponse):\n",
        "test.html.Z": "new file mode 100644\nindex 0000000000..2a4f4f1bbe\nThis is .Z data\n\\ No newline at end of file\n",
        "test.html.br": "new file mode 100644\nindex 0000000000..1a45328c72\nThis is .br data\n\\ No newline at end of file\n",
        "test_mime_problem.py": "new file mode 100644\nindex 0000000000..ba1298f132\nimport sys\nimport os\n\nimport django\nfrom django.conf import settings\n\n# Configure settings if not already configured.\nif not settings.configured:\nsettings.configure(\nDEBUG=True,\nSECRET_KEY=\"test\",\nDEFAULT_CHARSET=\"utf-8\",\n)\n\ndjango.setup()\n\nfrom django.http import FileResponse\n\ndef main():\nprint(\"Creating sample files .Z / .br for testing...\")\n\nwith open(\"test.html.Z\", \"wb\") as fz:\nfz.write(b\"This is .Z data\")\n\nwith open(\"test.html.br\", \"wb\") as fbr:\nfbr.write(b\"This is .br data\")\n\n# Test .Z\nprint(\"Testing FileResponse for test.html.Z...\")\nresponseZ = FileResponse(open(\"test.html.Z\", \"rb\"))\ncontent_type_z = responseZ.get(\"Content-Type\", None)\nprint(f\"Content-Type for .Z = {content_type_z}\")\nif content_type_z == \"text/html\":\nprint(\"FAIL: .Z incorrectly recognized as text/html.\")\nsys.exit(1)\n\n# Test .br\nprint(\"Testing FileResponse for test.html.br...\")\nresponseBR = FileResponse(open(\"test.html.br\", \"rb\"))\ncontent_type_br = responseBR.get(\"Content-Type\", None)\nprint(f\"Content-Type for .br = {content_type_br}\")\nif content_type_br == \"text/html\":\nprint(\"FAIL: .br incorrectly recognized as text/html.\")\nsys.exit(1)\n\nprint(\"PASS: .Z and .br are not reported as text/html. Test completed successfully.\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/http/response.py": "                 # Encoding isn't set to prevent browsers from automatically\n                 # uncompressing files.\n                 content_type = {\n\"br\": \"application/x-brotli\",\n                     \"bzip2\": \"application/x-bzip\",\n\"compress\": \"application/x-compress\",\n                     \"gzip\": \"application/gzip\",\n                     \"xz\": \"application/x-xz\",\n                 }.get(encoding, content_type)\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarity with modifications. They both handle compression types, but the second code sample contains an additional comment regarding encoding and layout differences. The assignment approach to `content_type` differs slightly, suggesting that modifications were made, but the core logic is similar.\"}"
}