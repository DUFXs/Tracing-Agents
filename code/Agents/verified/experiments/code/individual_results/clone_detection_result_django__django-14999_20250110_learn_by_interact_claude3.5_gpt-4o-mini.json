{
    "instance_id": "django__django-14999",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "django/db/migrations/operations/models.py": "index 982816be3a..ee0fd5e901 100644\n         new_model = to_state.apps.get_model(app_label, self.new_name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n             old_model = from_state.apps.get_model(app_label, self.old_name)\n# Skip database operations if the table name isn't actually changing\nold_db_table = old_model._meta.db_table\nnew_db_table = new_model._meta.db_table\nif old_db_table == new_db_table:\nreturn\n             # Move the main table\n             schema_editor.alter_db_table(\n                 new_model,\n                 old_model._meta.db_table,\n                 new_model._meta.db_table,\n             )\n\n             # Alter the fields pointing to us\n             for related_object in old_model._meta.related_objects:\n                 if related_object.related_model == old_model:\n     @property\n     def migration_name_fragment(self):\n         return 'remove_%s_%s' % (self.model_name_lower, self.name.lower())\n\n",
        "reproduce_rename.py": "new file mode 100644\nindex 0000000000..ff821e0440\nfrom django.conf import settings\nsettings.configure()\n\nfrom django.db import migrations\nfrom django.db.migrations.state import ProjectState\nfrom django.db.backends.base.schema import BaseDatabaseSchemaEditor\nfrom django.db.migrations.operations.models import RenameModel\n\nclass FakeSchemaEditor(BaseDatabaseSchemaEditor):\ndef __init__(self):\nself.collected_sql = []\nself.connection = type('Connection', (), {'alias': 'default'})\n\ndef execute(self, sql, params=()):\nself.collected_sql.append(sql)\n\ndef alter_db_table(self, model, old_db_table, new_db_table):\nself.execute(f'ALTER TABLE {old_db_table} RENAME TO {new_db_table}')\n\nclass Meta:\ndef can_migrate(self, connection):\nreturn True\n\nclass FakeModel:\ndef __init__(self, name, db_table):\nself._meta = Meta()\nself._meta.db_table = db_table\nself._meta.related_objects = []\nself._meta.model_name = name.lower()\nself._meta.app_label = 'myapp'\nself._meta.local_many_to_many = []\n\nclass FakeApps:\ndef __init__(self, old_table, new_table):\nself.old_table = old_table\nself.new_table = new_table\n\ndef get_model(self, app_label, model_name):\nif model_name.lower() == 'oldname':\nreturn FakeModel('OldName', self.old_table)\nreturn FakeModel('NewName', self.new_table)\n\nclass FakeState:\ndef __init__(self):\nself.apps = None  # Will be set by test_rename\n\ndef test_rename(old_table, new_table):\noperation = RenameModel('OldName', 'NewName')\nschema_editor = FakeSchemaEditor()\nfrom_state = FakeState()\nfrom_state.apps = FakeApps(old_table, new_table)\nto_state = FakeState()\nto_state.apps = FakeApps(old_table, new_table)\n\noperation.database_forwards('myapp', schema_editor, from_state, to_state)\nreturn schema_editor.collected_sql\n\n# Test case 1: Same table name (should be no-op)\nprint(\"Test case 1 - Same table name:\")\nprint(f\"SQL executed: {test_rename('same_table', 'same_table')}\")\n\n# Test case 2: Different table names (should execute ALTER TABLE)\nprint(\"\\nTest case 2 - Different table names:\")\nprint(f\"SQL executed: {test_rename('old_table', 'new_table')}\")\n\n"
    },
    "ground_truth_patch": {
        "django/db/migrations/operations/models.py": "         new_model = to_state.apps.get_model(app_label, self.new_name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n             old_model = from_state.apps.get_model(app_label, self.old_name)\nold_db_table = old_model._meta.db_table\nnew_db_table = new_model._meta.db_table\n# Don't alter when a table name is not changed.\nif old_db_table == new_db_table:\nreturn\n             # Move the main table\nschema_editor.alter_db_table(new_model, old_db_table, new_db_table)\n             # Alter the fields pointing to us\n             for related_object in old_model._meta.related_objects:\n                 if related_object.related_model == old_model:\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for differences in whitespace, layout, and comments. The main logic and structure of the code are the same.\"}"
}