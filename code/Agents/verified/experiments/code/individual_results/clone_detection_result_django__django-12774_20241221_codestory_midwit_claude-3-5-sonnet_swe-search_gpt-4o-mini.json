{
    "instance_id": "django__django-12774",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/db/models/query.py": "index d9c9b0db04..7bb6db95b2 100644\n     DJANGO_VERSION_PICKLE_KEY, IntegrityError, NotSupportedError, connections,\n     router, transaction,\n )\nfrom django.db.models import AutoField, DateField, DateTimeField, sql, UniqueConstraint\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.deletion import Collector\n from django.db.models.expressions import Case, Expression, F, Value, When\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\nif field_name != 'pk':\nfield = self.model._meta.get_field(field_name)\nis_unique = field.unique\nif not is_unique:\n# Check if there's a UniqueConstraint that makes this field unique\nfor constraint in self.model._meta.constraints:\nif isinstance(constraint, UniqueConstraint) and constraint.fields == (field_name,) and constraint.condition is None:\nis_unique = True\nbreak\nif not is_unique:\nraise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n                 return {}\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..671652235a\nfrom django.db import models\nfrom django.conf import settings\nimport os\n\n# Configure minimal settings\nsettings.configure(\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\nINSTALLED_APPS=[],\nDEFAULT_AUTO_FIELD='django.db.models.AutoField',\n)\n\nimport django\ndjango.setup()\n\n# Create your test model\nclass Article(models.Model):\nslug = models.CharField(max_length=255)\n\nclass Meta:\napp_label = 'myapp'\nconstraints = [\nmodels.UniqueConstraint(fields=[\"slug\"], name=\"article_slug_unq\")\n]\n\n# Create the tables\nfrom django.db import connection\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(Article)\n\n# Create some test data\nArticle.objects.create(slug=\"test-1\")\nArticle.objects.create(slug=\"test-2\")\n\n# Try to use in_bulk with the uniquely constrained field\ntry:\nresult = Article.objects.in_bulk(field_name=\"slug\")\nprint(\"Success! in_bulk worked with UniqueConstraint field\")\nprint(f\"Result: {result}\")\nexcept ValueError as e:\nprint(f\"Error occurred as expected: {str(e)}\")\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/db/models/query.py": "         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\nopts = self.model._meta\nunique_fields = [\nconstraint.fields[0]\nfor constraint in opts.total_unique_constraints\nif len(constraint.fields) == 1\n]\nif (\nfield_name != 'pk' and\nnot opts.get_field(field_name).unique and\nfield_name not in unique_fields\n):\n             raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarity with notable changes and restructuring of the statements between them. For example, the handling of unique constraints and the raising of ValueErrors in the context of the 'in_bulk' function are conceptually related, but the specific implementations have been changed. The first sample mentions 'UniqueConstraint' and iterates through constraints, while the second uses a lambda-like comprehension for fetching unique fields. This modification indicates changes in the flow while maintaining similar structural functions.\"}"
}