{
    "instance_id": "sympy__sympy-17139",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index 2614e1546e..10380f4020 100644\n \n # pytest related data file for slow tests\n .ci/durations.log\n.aider/\n",
        "sympy/simplify/fu.py": "index ad1130ef96..c8f8f4c773 100644\n         if not (rv.is_Pow and rv.base.func == f):\n             return rv\n \nif not rv.exp.is_real:\nreturn rv\n         if (rv.exp < 0) == True:\n             return rv\n         if (rv.exp > max) == True:\n",
        "sympy/simplify/fu.py.bak": "new file mode 100644\nindex 0000000000..ad1130ef96\n\"\"\"\nImplementation of the trigsimp algorithm by Fu et al.\n\nThe idea behind the ``fu`` algorithm is to use a sequence of rules, applied\nin what is heuristically known to be a smart order, to select a simpler\nexpression that is equivalent to the input.\n\nThere are transform rules in which a single rule is applied to the\nexpression tree. The following are just mnemonic in nature; see the\ndocstrings for examples.\n\nTR0 - simplify expression\nTR1 - sec-csc to cos-sin\nTR2 - tan-cot to sin-cos ratio\nTR2i - sin-cos ratio to tan\nTR3 - angle canonicalization\nTR4 - functions at special angles\nTR5 - powers of sin to powers of cos\nTR6 - powers of cos to powers of sin\nTR7 - reduce cos power (increase angle)\nTR8 - expand products of sin-cos to sums\nTR9 - contract sums of sin-cos to products\nTR10 - separate sin-cos arguments\nTR10i - collect sin-cos arguments\nTR11 - reduce double angles\nTR12 - separate tan arguments\nTR12i - collect tan arguments\nTR13 - expand product of tan-cot\nTRmorrie - prod(cos(x*2**i), (i, 0, k - 1)) -> sin(2**k*x)/(2**k*sin(x))\nTR14 - factored powers of sin or cos to cos or sin power\nTR15 - negative powers of sin to cot power\nTR16 - negative powers of cos to tan power\nTR22 - tan-cot powers to negative powers of sec-csc functions\nTR111 - negative sin-cos-tan powers to csc-sec-cot\n\nThere are 4 combination transforms (CTR1 - CTR4) in which a sequence of\ntransformations are applied and the simplest expression is selected from\na few options.\n\nFinally, there are the 2 rule lists (RL1 and RL2), which apply a\nsequence of transformations and combined transformations, and the ``fu``\nalgorithm itself, which applies rules and rule lists and selects the\nbest expressions. There is also a function ``L`` which counts the number\nof trigonometric functions that appear in the expression.\n\nOther than TR0, re-writing of expressions is not done by the transformations.\ne.g. TR10i finds pairs of terms in a sum that are in the form like\n``cos(x)*cos(y) + sin(x)*sin(y)``. Such expression are targeted in a bottom-up\ntraversal of the expression, but no manipulation to make them appear is\nattempted. For example,\n\nSet-up for examples below:\n\n>>> from sympy.simplify.fu import fu, L, TR9, TR10i, TR11\n>>> from sympy import factor, sin, cos, powsimp\n>>> from sympy.abc import x, y, z, a\n>>> from time import time\n\n>>> eq = cos(x + y)/cos(x)\n>>> TR10i(eq.expand(trig=True))\n-sin(x)*sin(y)/cos(x) + cos(y)\n\nIf the expression is put in \"normal\" form (with a common denominator) then\nthe transformation is successful:\n\n>>> TR10i(_.normal())\ncos(x + y)/cos(x)\n\nTR11's behavior is similar. It rewrites double angles as smaller angles but\ndoesn't do any simplification of the result.\n\n>>> TR11(sin(2)**a*cos(1)**(-a), 1)\n(2*sin(1)*cos(1))**a*cos(1)**(-a)\n>>> powsimp(_)\n(2*sin(1))**a\n\nThe temptation is to try make these TR rules \"smarter\" but that should really\nbe done at a higher level; the TR rules should try maintain the \"do one thing\nwell\" principle.  There is one exception, however. In TR10i and TR9 terms are\nrecognized even when they are each multiplied by a common factor:\n\n>>> fu(a*cos(x)*cos(y) + a*sin(x)*sin(y))\na*cos(x - y)\n\nFactoring with ``factor_terms`` is used but it it \"JIT\"-like, being delayed\nuntil it is deemed necessary. Furthermore, if the factoring does not\nhelp with the simplification, it is not retained, so\n``a*cos(x)*cos(y) + a*sin(x)*sin(z)`` does not become the factored\n(but unsimplified in the trigonometric sense) expression:\n\n>>> fu(a*cos(x)*cos(y) + a*sin(x)*sin(z))\na*sin(x)*sin(z) + a*cos(x)*cos(y)\n\nIn some cases factoring might be a good idea, but the user is left\nto make that decision. For example:\n\n>>> expr=((15*sin(2*x) + 19*sin(x + y) + 17*sin(x + z) + 19*cos(x - z) +\n... 25)*(20*sin(2*x) + 15*sin(x + y) + sin(y + z) + 14*cos(x - z) +\n... 14*cos(y - z))*(9*sin(2*y) + 12*sin(y + z) + 10*cos(x - y) + 2*cos(y -\n... z) + 18)).expand(trig=True).expand()\n\nIn the expanded state, there are nearly 1000 trig functions:\n\n>>> L(expr)\n932\n\nIf the expression where factored first, this would take time but the\nresulting expression would be transformed very quickly:\n\n>>> def clock(f, n=2):\n...    t=time(); f(); return round(time()-t, n)\n...\n>>> clock(lambda: factor(expr))  # doctest: +SKIP\n0.86\n>>> clock(lambda: TR10i(expr), 3)  # doctest: +SKIP\n0.016\n\nIf the unexpanded expression is used, the transformation takes longer but\nnot as long as it took to factor it and then transform it:\n\n>>> clock(lambda: TR10i(expr), 2)  # doctest: +SKIP\n0.28\n\nSo neither expansion nor factoring is used in ``TR10i``: if the\nexpression is already factored (or partially factored) then expansion\nwith ``trig=True`` would destroy what is already known and take\nlonger; if the expression is expanded, factoring may take longer than\nsimply applying the transformation itself.\n\nAlthough the algorithms should be canonical, always giving the same\nresult, they may not yield the best result. This, in general, is\nthe nature of simplification where searching all possible transformation\npaths is very expensive. Here is a simple example. There are 6 terms\nin the following sum:\n\n>>> expr = (sin(x)**2*cos(y)*cos(z) + sin(x)*sin(y)*cos(x)*cos(z) +\n... sin(x)*sin(z)*cos(x)*cos(y) + sin(y)*sin(z)*cos(x)**2 + sin(y)*sin(z) +\n... cos(y)*cos(z))\n>>> args = expr.args\n\nSerendipitously, fu gives the best result:\n\n>>> fu(expr)\n3*cos(y - z)/2 - cos(2*x + y + z)/2\n\nBut if different terms were combined, a less-optimal result might be\nobtained, requiring some additional work to get better simplification,\nbut still less than optimal. The following shows an alternative form\nof ``expr`` that resists optimal simplification once a given step\nis taken since it leads to a dead end:\n\n>>> TR9(-cos(x)**2*cos(y + z) + 3*cos(y - z)/2 +\n...     cos(y + z)/2 + cos(-2*x + y + z)/4 - cos(2*x + y + z)/4)\nsin(2*x)*sin(y + z)/2 - cos(x)**2*cos(y + z) + 3*cos(y - z)/2 + cos(y + z)/2\n\nHere is a smaller expression that exhibits the same behavior:\n\n>>> a = sin(x)*sin(z)*cos(x)*cos(y) + sin(x)*sin(y)*cos(x)*cos(z)\n>>> TR10i(a)\nsin(x)*sin(y + z)*cos(x)\n>>> newa = _\n>>> TR10i(expr - a)  # this combines two more of the remaining terms\nsin(x)**2*cos(y)*cos(z) + sin(y)*sin(z)*cos(x)**2 + cos(y - z)\n>>> TR10i(_ + newa) == _ + newa  # but now there is no more simplification\nTrue\n\nWithout getting lucky or trying all possible pairings of arguments, the\nfinal result may be less than optimal and impossible to find without\nbetter heuristics or brute force trial of all possibilities.\n\nNotes\n=====\n\nThis work was started by Dimitar Vlahovski at the Technological School\n\"Electronic systems\" (30.11.2011).\n\nReferences\n==========\n\nFu, Hongguang, Xiuqin Zhong, and Zhenbing Zeng. \"Automated and readable\nsimplification of trigonometric expressions.\" Mathematical and computer\nmodelling 44.11 (2006): 1169-1177.\nhttp://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/DESTIME2006/DES_contribs/Fu/simplification.pdf\n\nhttp://www.sosmath.com/trig/Trig5/trig5/pdf/pdf.html gives a formula sheet.\n\n\"\"\"\n\nfrom __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.add import Add\nfrom sympy.core.basic import S\nfrom sympy.core.compatibility import ordered, range\nfrom sympy.core.expr import Expr\nfrom sympy.core.exprtools import Factors, gcd_terms, factor_terms\nfrom sympy.core.function import expand_mul\nfrom sympy.core.mul import Mul\nfrom sympy.core.numbers import pi, I\nfrom sympy.core.power import Pow\nfrom sympy.core.symbol import Dummy\nfrom sympy.core.sympify import sympify\nfrom sympy.functions.combinatorial.factorials import binomial\nfrom sympy.functions.elementary.hyperbolic import (\ncosh, sinh, tanh, coth, sech, csch, HyperbolicFunction)\nfrom sympy.functions.elementary.trigonometric import (\ncos, sin, tan, cot, sec, csc, sqrt, TrigonometricFunction)\nfrom sympy.ntheory.factor_ import perfect_power\nfrom sympy.polys.polytools import factor\nfrom sympy.simplify.simplify import bottom_up\nfrom sympy.strategies.tree import greedy\nfrom sympy.strategies.core import identity, debug\n\nfrom sympy import SYMPY_DEBUG\n\n\n# ================== Fu-like tools ===========================\n\n\ndef TR0(rv):\n\"\"\"Simplification of rational polynomials, trying to simplify\nthe expression, e.g. combine things like 3*x + 2*x, etc....\n\"\"\"\n# although it would be nice to use cancel, it doesn't work\n# with noncommutatives\nreturn rv.normal().factor().expand()\n\n\ndef TR1(rv):\n\"\"\"Replace sec, csc with 1/cos, 1/sin\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR1, sec, csc\n>>> from sympy.abc import x\n>>> TR1(2*csc(x) + sec(x))\n1/cos(x) + 2/sin(x)\n\"\"\"\n\ndef f(rv):\nif isinstance(rv, sec):\na = rv.args[0]\nreturn S.One/cos(a)\nelif isinstance(rv, csc):\na = rv.args[0]\nreturn S.One/sin(a)\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR2(rv):\n\"\"\"Replace tan and cot with sin/cos and cos/sin\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR2\n>>> from sympy.abc import x\n>>> from sympy import tan, cot, sin, cos\n>>> TR2(tan(x))\nsin(x)/cos(x)\n>>> TR2(cot(x))\ncos(x)/sin(x)\n>>> TR2(tan(tan(x) - sin(x)/cos(x)))\n0\n\n\"\"\"\n\ndef f(rv):\nif isinstance(rv, tan):\na = rv.args[0]\nreturn sin(a)/cos(a)\nelif isinstance(rv, cot):\na = rv.args[0]\nreturn cos(a)/sin(a)\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR2i(rv, half=False):\n\"\"\"Converts ratios involving sin and cos as follows::\nsin(x)/cos(x) -> tan(x)\nsin(x)/(cos(x) + 1) -> tan(x/2) if half=True\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR2i\n>>> from sympy.abc import x, a\n>>> from sympy import sin, cos\n>>> TR2i(sin(x)/cos(x))\ntan(x)\n\nPowers of the numerator and denominator are also recognized\n\n>>> TR2i(sin(x)**2/(cos(x) + 1)**2, half=True)\ntan(x/2)**2\n\nThe transformation does not take place unless assumptions allow\n(i.e. the base must be positive or the exponent must be an integer\nfor both numerator and denominator)\n\n>>> TR2i(sin(x)**a/(cos(x) + 1)**a)\n(cos(x) + 1)**(-a)*sin(x)**a\n\n\"\"\"\n\ndef f(rv):\nif not rv.is_Mul:\nreturn rv\n\nn, d = rv.as_numer_denom()\nif n.is_Atom or d.is_Atom:\nreturn rv\n\ndef ok(k, e):\n# initial filtering of factors\nreturn (\n(e.is_integer or k.is_positive) and (\nk.func in (sin, cos) or (half and\nk.is_Add and\nlen(k.args) >= 2 and\nany(any(isinstance(ai, cos) or ai.is_Pow and ai.base is cos\nfor ai in Mul.make_args(a)) for a in k.args))))\n\nn = n.as_powers_dict()\nndone = [(k, n.pop(k)) for k in list(n.keys()) if not ok(k, n[k])]\nif not n:\nreturn rv\n\nd = d.as_powers_dict()\nddone = [(k, d.pop(k)) for k in list(d.keys()) if not ok(k, d[k])]\nif not d:\nreturn rv\n\n# factoring if necessary\n\ndef factorize(d, ddone):\nnewk = []\nfor k in d:\nif k.is_Add and len(k.args) > 1:\nknew = factor(k) if half else factor_terms(k)\nif knew != k:\nnewk.append((k, knew))\nif newk:\nfor i, (k, knew) in enumerate(newk):\ndel d[k]\nnewk[i] = knew\nnewk = Mul(*newk).as_powers_dict()\nfor k in newk:\nv = d[k] + newk[k]\nif ok(k, v):\nd[k] = v\nelse:\nddone.append((k, v))\ndel newk\nfactorize(n, ndone)\nfactorize(d, ddone)\n\n# joining\nt = []\nfor k in n:\nif isinstance(k, sin):\na = cos(k.args[0], evaluate=False)\nif a in d and d[a] == n[k]:\nt.append(tan(k.args[0])**n[k])\nn[k] = d[a] = None\nelif half:\na1 = 1 + a\nif a1 in d and d[a1] == n[k]:\nt.append((tan(k.args[0]/2))**n[k])\nn[k] = d[a1] = None\nelif isinstance(k, cos):\na = sin(k.args[0], evaluate=False)\nif a in d and d[a] == n[k]:\nt.append(tan(k.args[0])**-n[k])\nn[k] = d[a] = None\nelif half and k.is_Add and k.args[0] is S.One and \\\nisinstance(k.args[1], cos):\na = sin(k.args[1].args[0], evaluate=False)\nif a in d and d[a] == n[k] and (d[a].is_integer or \\\na.is_positive):\nt.append(tan(a.args[0]/2)**-n[k])\nn[k] = d[a] = None\n\nif t:\nrv = Mul(*(t + [b**e for b, e in n.items() if e]))/\\\nMul(*[b**e for b, e in d.items() if e])\nrv *= Mul(*[b**e for b, e in ndone])/Mul(*[b**e for b, e in ddone])\n\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR3(rv):\n\"\"\"Induced formula: example sin(-a) = -sin(a)\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR3\n>>> from sympy.abc import x, y\n>>> from sympy import pi\n>>> from sympy import cos\n>>> TR3(cos(y - x*(y - x)))\ncos(x*(x - y) + y)\n>>> cos(pi/2 + x)\n-sin(x)\n>>> cos(30*pi/2 + x)\n-cos(x)\n\n\"\"\"\nfrom sympy.simplify.simplify import signsimp\n\n# Negative argument (already automatic for funcs like sin(-x) -> -sin(x)\n# but more complicated expressions can use it, too). Also, trig angles\n# between pi/4 and pi/2 are not reduced to an angle between 0 and pi/4.\n# The following are automatically handled:\n#   Argument of type: pi/2 +/- angle\n#   Argument of type: pi +/- angle\n#   Argument of type : 2k*pi +/- angle\n\ndef f(rv):\nif not isinstance(rv, TrigonometricFunction):\nreturn rv\nrv = rv.func(signsimp(rv.args[0]))\nif not isinstance(rv, TrigonometricFunction):\nreturn rv\nif (rv.args[0] - S.Pi/4).is_positive is (S.Pi/2 - rv.args[0]).is_positive is True:\nfmap = {cos: sin, sin: cos, tan: cot, cot: tan, sec: csc, csc: sec}\nrv = fmap[rv.func](S.Pi/2 - rv.args[0])\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR4(rv):\n\"\"\"Identify values of special angles.\n\na=  0   pi/6        pi/4        pi/3        pi/2\n----------------------------------------------------\ncos(a)  0   1/2         sqrt(2)/2   sqrt(3)/2   1\nsin(a)  1   sqrt(3)/2   sqrt(2)/2   1/2         0\ntan(a)  0   sqt(3)/3    1           sqrt(3)     --\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR4\n>>> from sympy import pi\n>>> from sympy import cos, sin, tan, cot\n>>> for s in (0, pi/6, pi/4, pi/3, pi/2):\n...    print('%s %s %s %s' % (cos(s), sin(s), tan(s), cot(s)))\n...\n1 0 0 zoo\nsqrt(3)/2 1/2 sqrt(3)/3 sqrt(3)\nsqrt(2)/2 sqrt(2)/2 1 1\n1/2 sqrt(3)/2 sqrt(3) sqrt(3)/3\n0 1 zoo 0\n\"\"\"\n# special values at 0, pi/6, pi/4, pi/3, pi/2 already handled\nreturn rv\n\n\ndef _TR56(rv, f, g, h, max, pow):\n\"\"\"Helper for TR5 and TR6 to replace f**2 with h(g**2)\n\nOptions\n=======\n\nmax :   controls size of exponent that can appear on f\ne.g. if max=4 then f**4 will be changed to h(g**2)**2.\npow :   controls whether the exponent must be a perfect power of 2\ne.g. if pow=True (and max >= 6) then f**6 will not be changed\nbut f**8 will be changed to h(g**2)**4\n\n>>> from sympy.simplify.fu import _TR56 as T\n>>> from sympy.abc import x\n>>> from sympy import sin, cos\n>>> h = lambda x: 1 - x\n>>> T(sin(x)**3, sin, cos, h, 4, False)\nsin(x)**3\n>>> T(sin(x)**6, sin, cos, h, 6, False)\n(1 - cos(x)**2)**3\n>>> T(sin(x)**6, sin, cos, h, 6, True)\nsin(x)**6\n>>> T(sin(x)**8, sin, cos, h, 10, True)\n(1 - cos(x)**2)**4\n\"\"\"\n\ndef _f(rv):\n# I'm not sure if this transformation should target all even powers\n# or only those expressible as powers of 2. Also, should it only\n# make the changes in powers that appear in sums -- making an isolated\n# change is not going to allow a simplification as far as I can tell.\nif not (rv.is_Pow and rv.base.func == f):\nreturn rv\n\nif (rv.exp < 0) == True:\nreturn rv\nif (rv.exp > max) == True:\nreturn rv\nif rv.exp == 2:\nreturn h(g(rv.base.args[0])**2)\nelse:\nif rv.exp == 4:\ne = 2\nelif not pow:\nif rv.exp % 2:\nreturn rv\ne = rv.exp//2\nelse:\np = perfect_power(rv.exp)\nif not p:\nreturn rv\ne = rv.exp//2\nreturn h(g(rv.base.args[0])**2)**e\n\nreturn bottom_up(rv, _f)\n\n\ndef TR5(rv, max=4, pow=False):\n\"\"\"Replacement of sin**2 with 1 - cos(x)**2.\n\nSee _TR56 docstring for advanced use of ``max`` and ``pow``.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR5\n>>> from sympy.abc import x\n>>> from sympy import sin\n>>> TR5(sin(x)**2)\n1 - cos(x)**2\n>>> TR5(sin(x)**-2)  # unchanged\nsin(x)**(-2)\n>>> TR5(sin(x)**4)\n(1 - cos(x)**2)**2\n\"\"\"\nreturn _TR56(rv, sin, cos, lambda x: 1 - x, max=max, pow=pow)\n\n\ndef TR6(rv, max=4, pow=False):\n\"\"\"Replacement of cos**2 with 1 - sin(x)**2.\n\nSee _TR56 docstring for advanced use of ``max`` and ``pow``.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR6\n>>> from sympy.abc import x\n>>> from sympy import cos\n>>> TR6(cos(x)**2)\n1 - sin(x)**2\n>>> TR6(cos(x)**-2)  #unchanged\ncos(x)**(-2)\n>>> TR6(cos(x)**4)\n(1 - sin(x)**2)**2\n\"\"\"\nreturn _TR56(rv, cos, sin, lambda x: 1 - x, max=max, pow=pow)\n\n\ndef TR7(rv):\n\"\"\"Lowering the degree of cos(x)**2\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR7\n>>> from sympy.abc import x\n>>> from sympy import cos\n>>> TR7(cos(x)**2)\ncos(2*x)/2 + 1/2\n>>> TR7(cos(x)**2 + 1)\ncos(2*x)/2 + 3/2\n\n\"\"\"\n\ndef f(rv):\nif not (rv.is_Pow and rv.base.func == cos and rv.exp == 2):\nreturn rv\nreturn (1 + cos(2*rv.base.args[0]))/2\n\nreturn bottom_up(rv, f)\n\n\ndef TR8(rv, first=True):\n\"\"\"Converting products of ``cos`` and/or ``sin`` to a sum or\ndifference of ``cos`` and or ``sin`` terms.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR8, TR7\n>>> from sympy import cos, sin\n>>> TR8(cos(2)*cos(3))\ncos(5)/2 + cos(1)/2\n>>> TR8(cos(2)*sin(3))\nsin(5)/2 + sin(1)/2\n>>> TR8(sin(2)*sin(3))\n-cos(5)/2 + cos(1)/2\n\"\"\"\n\ndef f(rv):\nif not (\nrv.is_Mul or\nrv.is_Pow and\nrv.base.func in (cos, sin) and\n(rv.exp.is_integer or rv.base.is_positive)):\nreturn rv\n\nif first:\nn, d = [expand_mul(i) for i in rv.as_numer_denom()]\nnewn = TR8(n, first=False)\nnewd = TR8(d, first=False)\nif newn != n or newd != d:\nrv = gcd_terms(newn/newd)\nif rv.is_Mul and rv.args[0].is_Rational and \\\nlen(rv.args) == 2 and rv.args[1].is_Add:\nrv = Mul(*rv.as_coeff_Mul())\nreturn rv\n\nargs = {cos: [], sin: [], None: []}\nfor a in ordered(Mul.make_args(rv)):\nif a.func in (cos, sin):\nargs[a.func].append(a.args[0])\nelif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\na.base.func in (cos, sin)):\n# XXX this is ok but pathological expression could be handled\n# more efficiently as in TRmorrie\nargs[a.base.func].extend([a.base.args[0]]*a.exp)\nelse:\nargs[None].append(a)\nc = args[cos]\ns = args[sin]\nif not (c and s or len(c) > 1 or len(s) > 1):\nreturn rv\n\nargs = args[None]\nn = min(len(c), len(s))\nfor i in range(n):\na1 = s.pop()\na2 = c.pop()\nargs.append((sin(a1 + a2) + sin(a1 - a2))/2)\nwhile len(c) > 1:\na1 = c.pop()\na2 = c.pop()\nargs.append((cos(a1 + a2) + cos(a1 - a2))/2)\nif c:\nargs.append(cos(c.pop()))\nwhile len(s) > 1:\na1 = s.pop()\na2 = s.pop()\nargs.append((-cos(a1 + a2) + cos(a1 - a2))/2)\nif s:\nargs.append(sin(s.pop()))\nreturn TR8(expand_mul(Mul(*args)))\n\nreturn bottom_up(rv, f)\n\n\ndef TR9(rv):\n\"\"\"Sum of ``cos`` or ``sin`` terms as a product of ``cos`` or ``sin``.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR9\n>>> from sympy import cos, sin\n>>> TR9(cos(1) + cos(2))\n2*cos(1/2)*cos(3/2)\n>>> TR9(cos(1) + 2*sin(1) + 2*sin(2))\ncos(1) + 4*sin(3/2)*cos(1/2)\n\nIf no change is made by TR9, no re-arrangement of the\nexpression will be made. For example, though factoring\nof common term is attempted, if the factored expression\nwasn't changed, the original expression will be returned:\n\n>>> TR9(cos(3) + cos(3)*cos(2))\ncos(3) + cos(2)*cos(3)\n\n\"\"\"\n\ndef f(rv):\nif not rv.is_Add:\nreturn rv\n\ndef do(rv, first=True):\n# cos(a)+/-cos(b) can be combined into a product of cosines and\n# sin(a)+/-sin(b) can be combined into a product of cosine and\n# sine.\n#\n# If there are more than two args, the pairs which \"work\" will\n# have a gcd extractable and the remaining two terms will have\n# the above structure -- all pairs must be checked to find the\n# ones that work. args that don't have a common set of symbols\n# are skipped since this doesn't lead to a simpler formula and\n# also has the arbitrariness of combining, for example, the x\n# and y term instead of the y and z term in something like\n# cos(x) + cos(y) + cos(z).\n\nif not rv.is_Add:\nreturn rv\n\nargs = list(ordered(rv.args))\nif len(args) != 2:\nhit = False\nfor i in range(len(args)):\nai = args[i]\nif ai is None:\ncontinue\nfor j in range(i + 1, len(args)):\naj = args[j]\nif aj is None:\ncontinue\nwas = ai + aj\nnew = do(was)\nif new != was:\nargs[i] = new  # update in place\nargs[j] = None\nhit = True\nbreak  # go to next i\nif hit:\nrv = Add(*[_f for _f in args if _f])\nif rv.is_Add:\nrv = do(rv)\n\nreturn rv\n\n# two-arg Add\nsplit = trig_split(*args)\nif not split:\nreturn rv\ngcd, n1, n2, a, b, iscos = split\n\n# application of rule if possible\nif iscos:\nif n1 == n2:\nreturn gcd*n1*2*cos((a + b)/2)*cos((a - b)/2)\nif n1 < 0:\na, b = b, a\nreturn -2*gcd*sin((a + b)/2)*sin((a - b)/2)\nelse:\nif n1 == n2:\nreturn gcd*n1*2*sin((a + b)/2)*cos((a - b)/2)\nif n1 < 0:\na, b = b, a\nreturn 2*gcd*cos((a + b)/2)*sin((a - b)/2)\n\nreturn process_common_addends(rv, do)  # DON'T sift by free symbols\n\nreturn bottom_up(rv, f)\n\n\ndef TR10(rv, first=True):\n\"\"\"Separate sums in ``cos`` and ``sin``.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR10\n>>> from sympy.abc import a, b, c\n>>> from sympy import cos, sin\n>>> TR10(cos(a + b))\n-sin(a)*sin(b) + cos(a)*cos(b)\n>>> TR10(sin(a + b))\nsin(a)*cos(b) + sin(b)*cos(a)\n>>> TR10(sin(a + b + c))\n(-sin(a)*sin(b) + cos(a)*cos(b))*sin(c) + \\\n(sin(a)*cos(b) + sin(b)*cos(a))*cos(c)\n\"\"\"\n\ndef f(rv):\nif not rv.func in (cos, sin):\nreturn rv\n\nf = rv.func\narg = rv.args[0]\nif arg.is_Add:\nif first:\nargs = list(ordered(arg.args))\nelse:\nargs = list(arg.args)\na = args.pop()\nb = Add._from_args(args)\nif b.is_Add:\nif f == sin:\nreturn sin(a)*TR10(cos(b), first=False) + \\\ncos(a)*TR10(sin(b), first=False)\nelse:\nreturn cos(a)*TR10(cos(b), first=False) - \\\nsin(a)*TR10(sin(b), first=False)\nelse:\nif f == sin:\nreturn sin(a)*cos(b) + cos(a)*sin(b)\nelse:\nreturn cos(a)*cos(b) - sin(a)*sin(b)\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR10i(rv):\n\"\"\"Sum of products to function of sum.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR10i\n>>> from sympy import cos, sin, pi, Add, Mul, sqrt, Symbol\n>>> from sympy.abc import x, y\n\n>>> TR10i(cos(1)*cos(3) + sin(1)*sin(3))\ncos(2)\n>>> TR10i(cos(1)*sin(3) + sin(1)*cos(3) + cos(3))\ncos(3) + sin(4)\n>>> TR10i(sqrt(2)*cos(x)*x + sqrt(6)*sin(x)*x)\n2*sqrt(2)*x*sin(x + pi/6)\n\n\"\"\"\nglobal _ROOT2, _ROOT3, _invROOT3\nif _ROOT2 is None:\n_roots()\n\ndef f(rv):\nif not rv.is_Add:\nreturn rv\n\ndef do(rv, first=True):\n# args which can be expressed as A*(cos(a)*cos(b)+/-sin(a)*sin(b))\n# or B*(cos(a)*sin(b)+/-cos(b)*sin(a)) can be combined into\n# A*f(a+/-b) where f is either sin or cos.\n#\n# If there are more than two args, the pairs which \"work\" will have\n# a gcd extractable and the remaining two terms will have the above\n# structure -- all pairs must be checked to find the ones that\n# work.\n\nif not rv.is_Add:\nreturn rv\n\nargs = list(ordered(rv.args))\nif len(args) != 2:\nhit = False\nfor i in range(len(args)):\nai = args[i]\nif ai is None:\ncontinue\nfor j in range(i + 1, len(args)):\naj = args[j]\nif aj is None:\ncontinue\nwas = ai + aj\nnew = do(was)\nif new != was:\nargs[i] = new  # update in place\nargs[j] = None\nhit = True\nbreak  # go to next i\nif hit:\nrv = Add(*[_f for _f in args if _f])\nif rv.is_Add:\nrv = do(rv)\n\nreturn rv\n\n# two-arg Add\nsplit = trig_split(*args, two=True)\nif not split:\nreturn rv\ngcd, n1, n2, a, b, same = split\n\n# identify and get c1 to be cos then apply rule if possible\nif same:  # coscos, sinsin\ngcd = n1*gcd\nif n1 == n2:\nreturn gcd*cos(a - b)\nreturn gcd*cos(a + b)\nelse:  #cossin, cossin\ngcd = n1*gcd\nif n1 == n2:\nreturn gcd*sin(a + b)\nreturn gcd*sin(b - a)\n\nrv = process_common_addends(\nrv, do, lambda x: tuple(ordered(x.free_symbols)))\n\n# need to check for inducible pairs in ratio of sqrt(3):1 that\n# appeared in different lists when sorting by coefficient\nwhile rv.is_Add:\nbyrad = defaultdict(list)\nfor a in rv.args:\nhit = 0\nif a.is_Mul:\nfor ai in a.args:\nif ai.is_Pow and ai.exp is S.Half and \\\nai.base.is_Integer:\nbyrad[ai].append(a)\nhit = 1\nbreak\nif not hit:\nbyrad[S.One].append(a)\n\n# no need to check all pairs -- just check for the onees\n# that have the right ratio\nargs = []\nfor a in byrad:\nfor b in [_ROOT3*a, _invROOT3]:\nif b in byrad:\nfor i in range(len(byrad[a])):\nif byrad[a][i] is None:\ncontinue\nfor j in range(len(byrad[b])):\nif byrad[b][j] is None:\ncontinue\nwas = Add(byrad[a][i] + byrad[b][j])\nnew = do(was)\nif new != was:\nargs.append(new)\nbyrad[a][i] = None\nbyrad[b][j] = None\nbreak\nif args:\nrv = Add(*(args + [Add(*[_f for _f in v if _f])\nfor v in byrad.values()]))\nelse:\nrv = do(rv)  # final pass to resolve any new inducible pairs\nbreak\n\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR11(rv, base=None):\n\"\"\"Function of double angle to product. The ``base`` argument can be used\nto indicate what is the un-doubled argument, e.g. if 3*pi/7 is the base\nthen cosine and sine functions with argument 6*pi/7 will be replaced.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR11\n>>> from sympy import cos, sin, pi\n>>> from sympy.abc import x\n>>> TR11(sin(2*x))\n2*sin(x)*cos(x)\n>>> TR11(cos(2*x))\n-sin(x)**2 + cos(x)**2\n>>> TR11(sin(4*x))\n4*(-sin(x)**2 + cos(x)**2)*sin(x)*cos(x)\n>>> TR11(sin(4*x/3))\n4*(-sin(x/3)**2 + cos(x/3)**2)*sin(x/3)*cos(x/3)\n\nIf the arguments are simply integers, no change is made\nunless a base is provided:\n\n>>> TR11(cos(2))\ncos(2)\n>>> TR11(cos(4), 2)\n-sin(2)**2 + cos(2)**2\n\nThere is a subtle issue here in that autosimplification will convert\nsome higher angles to lower angles\n\n>>> cos(6*pi/7) + cos(3*pi/7)\n-cos(pi/7) + cos(3*pi/7)\n\nThe 6*pi/7 angle is now pi/7 but can be targeted with TR11 by supplying\nthe 3*pi/7 base:\n\n>>> TR11(_, 3*pi/7)\n-sin(3*pi/7)**2 + cos(3*pi/7)**2 + cos(3*pi/7)\n\n\"\"\"\n\ndef f(rv):\nif not rv.func in (cos, sin):\nreturn rv\n\nif base:\nf = rv.func\nt = f(base*2)\nco = S.One\nif t.is_Mul:\nco, t = t.as_coeff_Mul()\nif not t.func in (cos, sin):\nreturn rv\nif rv.args[0] == t.args[0]:\nc = cos(base)\ns = sin(base)\nif f is cos:\nreturn (c**2 - s**2)/co\nelse:\nreturn 2*c*s/co\nreturn rv\n\nelif not rv.args[0].is_Number:\n# make a change if the leading coefficient's numerator is\n# divisible by 2\nc, m = rv.args[0].as_coeff_Mul(rational=True)\nif c.p % 2 == 0:\narg = c.p//2*m/c.q\nc = TR11(cos(arg))\ns = TR11(sin(arg))\nif rv.func == sin:\nrv = 2*s*c\nelse:\nrv = c**2 - s**2\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR12(rv, first=True):\n\"\"\"Separate sums in ``tan``.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR12\n>>> from sympy.abc import x, y\n>>> from sympy import tan\n>>> from sympy.simplify.fu import TR12\n>>> TR12(tan(x + y))\n(tan(x) + tan(y))/(-tan(x)*tan(y) + 1)\n\"\"\"\n\ndef f(rv):\nif not rv.func == tan:\nreturn rv\n\narg = rv.args[0]\nif arg.is_Add:\nif first:\nargs = list(ordered(arg.args))\nelse:\nargs = list(arg.args)\na = args.pop()\nb = Add._from_args(args)\nif b.is_Add:\ntb = TR12(tan(b), first=False)\nelse:\ntb = tan(b)\nreturn (tan(a) + tb)/(1 - tan(a)*tb)\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR12i(rv):\n\"\"\"Combine tan arguments as\n(tan(y) + tan(x))/(tan(x)*tan(y) - 1) -> -tan(x + y)\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR12i\n>>> from sympy import tan\n>>> from sympy.abc import a, b, c\n>>> ta, tb, tc = [tan(i) for i in (a, b, c)]\n>>> TR12i((ta + tb)/(-ta*tb + 1))\ntan(a + b)\n>>> TR12i((ta + tb)/(ta*tb - 1))\n-tan(a + b)\n>>> TR12i((-ta - tb)/(ta*tb - 1))\ntan(a + b)\n>>> eq = (ta + tb)/(-ta*tb + 1)**2*(-3*ta - 3*tc)/(2*(ta*tc - 1))\n>>> TR12i(eq.expand())\n-3*tan(a + b)*tan(a + c)/(2*(tan(a) + tan(b) - 1))\n\"\"\"\nfrom sympy import factor\n\ndef f(rv):\nif not (rv.is_Add or rv.is_Mul or rv.is_Pow):\nreturn rv\n\nn, d = rv.as_numer_denom()\nif not d.args or not n.args:\nreturn rv\n\ndok = {}\n\ndef ok(di):\nm = as_f_sign_1(di)\nif m:\ng, f, s = m\nif s is S.NegativeOne and f.is_Mul and len(f.args) == 2 and \\\nall(isinstance(fi, tan) for fi in f.args):\nreturn g, f\n\nd_args = list(Mul.make_args(d))\nfor i, di in enumerate(d_args):\nm = ok(di)\nif m:\ng, t = m\ns = Add(*[_.args[0] for _ in t.args])\ndok[s] = S.One\nd_args[i] = g\ncontinue\nif di.is_Add:\ndi = factor(di)\nif di.is_Mul:\nd_args.extend(di.args)\nd_args[i] = S.One\nelif di.is_Pow and (di.exp.is_integer or di.base.is_positive):\nm = ok(di.base)\nif m:\ng, t = m\ns = Add(*[_.args[0] for _ in t.args])\ndok[s] = di.exp\nd_args[i] = g**di.exp\nelse:\ndi = factor(di)\nif di.is_Mul:\nd_args.extend(di.args)\nd_args[i] = S.One\nif not dok:\nreturn rv\n\ndef ok(ni):\nif ni.is_Add and len(ni.args) == 2:\na, b = ni.args\nif isinstance(a, tan) and isinstance(b, tan):\nreturn a, b\nn_args = list(Mul.make_args(factor_terms(n)))\nhit = False\nfor i, ni in enumerate(n_args):\nm = ok(ni)\nif not m:\nm = ok(-ni)\nif m:\nn_args[i] = S.NegativeOne\nelse:\nif ni.is_Add:\nni = factor(ni)\nif ni.is_Mul:\nn_args.extend(ni.args)\nn_args[i] = S.One\ncontinue\nelif ni.is_Pow and (\nni.exp.is_integer or ni.base.is_positive):\nm = ok(ni.base)\nif m:\nn_args[i] = S.One\nelse:\nni = factor(ni)\nif ni.is_Mul:\nn_args.extend(ni.args)\nn_args[i] = S.One\ncontinue\nelse:\ncontinue\nelse:\nn_args[i] = S.One\nhit = True\ns = Add(*[_.args[0] for _ in m])\ned = dok[s]\nnewed = ed.extract_additively(S.One)\nif newed is not None:\nif newed:\ndok[s] = newed\nelse:\ndok.pop(s)\nn_args[i] *= -tan(s)\n\nif hit:\nrv = Mul(*n_args)/Mul(*d_args)/Mul(*[(Add(*[\ntan(a) for a in i.args]) - 1)**e for i, e in dok.items()])\n\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR13(rv):\n\"\"\"Change products of ``tan`` or ``cot``.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR13\n>>> from sympy import tan, cot, cos\n>>> TR13(tan(3)*tan(2))\n-tan(2)/tan(5) - tan(3)/tan(5) + 1\n>>> TR13(cot(3)*cot(2))\ncot(2)*cot(5) + 1 + cot(3)*cot(5)\n\"\"\"\n\ndef f(rv):\nif not rv.is_Mul:\nreturn rv\n\n# XXX handle products of powers? or let power-reducing handle it?\nargs = {tan: [], cot: [], None: []}\nfor a in ordered(Mul.make_args(rv)):\nif a.func in (tan, cot):\nargs[a.func].append(a.args[0])\nelse:\nargs[None].append(a)\nt = args[tan]\nc = args[cot]\nif len(t) < 2 and len(c) < 2:\nreturn rv\nargs = args[None]\nwhile len(t) > 1:\nt1 = t.pop()\nt2 = t.pop()\nargs.append(1 - (tan(t1)/tan(t1 + t2) + tan(t2)/tan(t1 + t2)))\nif t:\nargs.append(tan(t.pop()))\nwhile len(c) > 1:\nt1 = c.pop()\nt2 = c.pop()\nargs.append(1 + cot(t1)*cot(t1 + t2) + cot(t2)*cot(t1 + t2))\nif c:\nargs.append(cot(c.pop()))\nreturn Mul(*args)\n\nreturn bottom_up(rv, f)\n\n\ndef TRmorrie(rv):\n\"\"\"Returns cos(x)*cos(2*x)*...*cos(2**(k-1)*x) -> sin(2**k*x)/(2**k*sin(x))\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TRmorrie, TR8, TR3\n>>> from sympy.abc import x\n>>> from sympy import Mul, cos, pi\n>>> TRmorrie(cos(x)*cos(2*x))\nsin(4*x)/(4*sin(x))\n>>> TRmorrie(7*Mul(*[cos(x) for x in range(10)]))\n7*sin(12)*sin(16)*cos(5)*cos(7)*cos(9)/(64*sin(1)*sin(3))\n\nSometimes autosimplification will cause a power to be\nnot recognized. e.g. in the following, cos(4*pi/7) automatically\nsimplifies to -cos(3*pi/7) so only 2 of the 3 terms are\nrecognized:\n\n>>> TRmorrie(cos(pi/7)*cos(2*pi/7)*cos(4*pi/7))\n-sin(3*pi/7)*cos(3*pi/7)/(4*sin(pi/7))\n\nA touch by TR8 resolves the expression to a Rational\n\n>>> TR8(_)\n-1/8\n\nIn this case, if eq is unsimplified, the answer is obtained\ndirectly:\n\n>>> eq = cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9)\n>>> TRmorrie(eq)\n1/16\n\nBut if angles are made canonical with TR3 then the answer\nis not simplified without further work:\n\n>>> TR3(eq)\nsin(pi/18)*cos(pi/9)*cos(2*pi/9)/2\n>>> TRmorrie(_)\nsin(pi/18)*sin(4*pi/9)/(8*sin(pi/9))\n>>> TR8(_)\ncos(7*pi/18)/(16*sin(pi/9))\n>>> TR3(_)\n1/16\n\nThe original expression would have resolve to 1/16 directly with TR8,\nhowever:\n\n>>> TR8(eq)\n1/16\n\nReferences\n==========\n\nhttps://en.wikipedia.org/wiki/Morrie%27s_law\n\n\"\"\"\n\ndef f(rv, first=True):\nif not rv.is_Mul:\nreturn rv\nif first:\nn, d = rv.as_numer_denom()\nreturn f(n, 0)/f(d, 0)\n\nargs = defaultdict(list)\ncoss = {}\nother = []\nfor c in rv.args:\nb, e = c.as_base_exp()\nif e.is_Integer and isinstance(b, cos):\nco, a = b.args[0].as_coeff_Mul()\nargs[a].append(co)\ncoss[b] = e\nelse:\nother.append(c)\n\nnew = []\nfor a in args:\nc = args[a]\nc.sort()\nno = []\nwhile c:\nk = 0\ncc = ci = c[0]\nwhile cc in c:\nk += 1\ncc *= 2\nif k > 1:\nnewarg = sin(2**k*ci*a)/2**k/sin(ci*a)\n# see how many times this can be taken\ntake = None\nccs = []\nfor i in range(k):\ncc /= 2\nkey = cos(a*cc, evaluate=False)\nccs.append(cc)\ntake = min(coss[key], take or coss[key])\n# update exponent counts\nfor i in range(k):\ncc = ccs.pop()\nkey = cos(a*cc, evaluate=False)\ncoss[key] -= take\nif not coss[key]:\nc.remove(cc)\nnew.append(newarg**take)\nelse:\nno.append(c.pop(0))\nc[:] = no\n\nif new:\nrv = Mul(*(new + other + [\ncos(k*a, evaluate=False) for a in args for k in args[a]]))\n\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR14(rv, first=True):\n\"\"\"Convert factored powers of sin and cos identities into simpler\nexpressions.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR14\n>>> from sympy.abc import x, y\n>>> from sympy import cos, sin\n>>> TR14((cos(x) - 1)*(cos(x) + 1))\n-sin(x)**2\n>>> TR14((sin(x) - 1)*(sin(x) + 1))\n-cos(x)**2\n>>> p1 = (cos(x) + 1)*(cos(x) - 1)\n>>> p2 = (cos(y) - 1)*2*(cos(y) + 1)\n>>> p3 = (3*(cos(y) - 1))*(3*(cos(y) + 1))\n>>> TR14(p1*p2*p3*(x - 1))\n-18*(x - 1)*sin(x)**2*sin(y)**4\n\n\"\"\"\n\ndef f(rv):\nif not rv.is_Mul:\nreturn rv\n\nif first:\n# sort them by location in numerator and denominator\n# so the code below can just deal with positive exponents\nn, d = rv.as_numer_denom()\nif d is not S.One:\nnewn = TR14(n, first=False)\nnewd = TR14(d, first=False)\nif newn != n or newd != d:\nrv = newn/newd\nreturn rv\n\nother = []\nprocess = []\nfor a in rv.args:\nif a.is_Pow:\nb, e = a.as_base_exp()\nif not (e.is_integer or b.is_positive):\nother.append(a)\ncontinue\na = b\nelse:\ne = S.One\nm = as_f_sign_1(a)\nif not m or m[1].func not in (cos, sin):\nif e is S.One:\nother.append(a)\nelse:\nother.append(a**e)\ncontinue\ng, f, si = m\nprocess.append((g, e.is_Number, e, f, si, a))\n\n# sort them to get like terms next to each other\nprocess = list(ordered(process))\n\n# keep track of whether there was any change\nnother = len(other)\n\n# access keys\nkeys = (g, t, e, f, si, a) = list(range(6))\n\nwhile process:\nA = process.pop(0)\nif process:\nB = process[0]\n\nif A[e].is_Number and B[e].is_Number:\n# both exponents are numbers\nif A[f] == B[f]:\nif A[si] != B[si]:\nB = process.pop(0)\ntake = min(A[e], B[e])\n\n# reinsert any remainder\n# the B will likely sort after A so check it first\nif B[e] != take:\nrem = [B[i] for i in keys]\nrem[e] -= take\nprocess.insert(0, rem)\nelif A[e] != take:\nrem = [A[i] for i in keys]\nrem[e] -= take\nprocess.insert(0, rem)\n\nif isinstance(A[f], cos):\nt = sin\nelse:\nt = cos\nother.append((-A[g]*B[g]*t(A[f].args[0])**2)**take)\ncontinue\n\nelif A[e] == B[e]:\n# both exponents are equal symbols\nif A[f] == B[f]:\nif A[si] != B[si]:\nB = process.pop(0)\ntake = A[e]\nif isinstance(A[f], cos):\nt = sin\nelse:\nt = cos\nother.append((-A[g]*B[g]*t(A[f].args[0])**2)**take)\ncontinue\n\n# either we are done or neither condition above applied\nother.append(A[a]**A[e])\n\nif len(other) != nother:\nrv = Mul(*other)\n\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR15(rv, max=4, pow=False):\n\"\"\"Convert sin(x)*-2 to 1 + cot(x)**2.\n\nSee _TR56 docstring for advanced use of ``max`` and ``pow``.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR15\n>>> from sympy.abc import x\n>>> from sympy import cos, sin\n>>> TR15(1 - 1/sin(x)**2)\n-cot(x)**2\n\n\"\"\"\n\ndef f(rv):\nif not (isinstance(rv, Pow) and isinstance(rv.base, sin)):\nreturn rv\n\nia = 1/rv\na = _TR56(ia, sin, cot, lambda x: 1 + x, max=max, pow=pow)\nif a != ia:\nrv = a\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR16(rv, max=4, pow=False):\n\"\"\"Convert cos(x)*-2 to 1 + tan(x)**2.\n\nSee _TR56 docstring for advanced use of ``max`` and ``pow``.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR16\n>>> from sympy.abc import x\n>>> from sympy import cos, sin\n>>> TR16(1 - 1/cos(x)**2)\n-tan(x)**2\n\n\"\"\"\n\ndef f(rv):\nif not (isinstance(rv, Pow) and isinstance(rv.base, cos)):\nreturn rv\n\nia = 1/rv\na = _TR56(ia, cos, tan, lambda x: 1 + x, max=max, pow=pow)\nif a != ia:\nrv = a\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR111(rv):\n\"\"\"Convert f(x)**-i to g(x)**i where either ``i`` is an integer\nor the base is positive and f, g are: tan, cot; sin, csc; or cos, sec.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR111\n>>> from sympy.abc import x\n>>> from sympy import tan\n>>> TR111(1 - 1/tan(x)**2)\n1 - cot(x)**2\n\n\"\"\"\n\ndef f(rv):\nif not (\nisinstance(rv, Pow) and\n(rv.base.is_positive or rv.exp.is_integer and rv.exp.is_negative)):\nreturn rv\n\nif isinstance(rv.base, tan):\nreturn cot(rv.base.args[0])**-rv.exp\nelif isinstance(rv.base, sin):\nreturn csc(rv.base.args[0])**-rv.exp\nelif isinstance(rv.base, cos):\nreturn sec(rv.base.args[0])**-rv.exp\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TR22(rv, max=4, pow=False):\n\"\"\"Convert tan(x)**2 to sec(x)**2 - 1 and cot(x)**2 to csc(x)**2 - 1.\n\nSee _TR56 docstring for advanced use of ``max`` and ``pow``.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TR22\n>>> from sympy.abc import x\n>>> from sympy import tan, cot\n>>> TR22(1 + tan(x)**2)\nsec(x)**2\n>>> TR22(1 + cot(x)**2)\ncsc(x)**2\n\n\"\"\"\n\ndef f(rv):\nif not (isinstance(rv, Pow) and rv.base.func in (cot, tan)):\nreturn rv\n\nrv = _TR56(rv, tan, sec, lambda x: x - 1, max=max, pow=pow)\nrv = _TR56(rv, cot, csc, lambda x: x - 1, max=max, pow=pow)\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef TRpower(rv):\n\"\"\"Convert sin(x)**n and cos(x)**n with positive n to sums.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import TRpower\n>>> from sympy.abc import x\n>>> from sympy import cos, sin\n>>> TRpower(sin(x)**6)\n-15*cos(2*x)/32 + 3*cos(4*x)/16 - cos(6*x)/32 + 5/16\n>>> TRpower(sin(x)**3*cos(2*x)**4)\n(3*sin(x)/4 - sin(3*x)/4)*(cos(4*x)/2 + cos(8*x)/8 + 3/8)\n\nReferences\n==========\n\nhttps://en.wikipedia.org/wiki/List_of_trigonometric_identities#Power-reduction_formulae\n\n\"\"\"\n\ndef f(rv):\nif not (isinstance(rv, Pow) and isinstance(rv.base, (sin, cos))):\nreturn rv\nb, n = rv.as_base_exp()\nx = b.args[0]\nif n.is_Integer and n.is_positive:\nif n.is_odd and isinstance(b, cos):\nrv = 2**(1-n)*Add(*[binomial(n, k)*cos((n - 2*k)*x)\nfor k in range((n + 1)/2)])\nelif n.is_odd and isinstance(b, sin):\nrv = 2**(1-n)*(-1)**((n-1)/2)*Add(*[binomial(n, k)*\n(-1)**k*sin((n - 2*k)*x) for k in range((n + 1)/2)])\nelif n.is_even and isinstance(b, cos):\nrv = 2**(1-n)*Add(*[binomial(n, k)*cos((n - 2*k)*x)\nfor k in range(n/2)])\nelif n.is_even and isinstance(b, sin):\nrv = 2**(1-n)*(-1)**(n/2)*Add(*[binomial(n, k)*\n(-1)**k*cos((n - 2*k)*x) for k in range(n/2)])\nif n.is_even:\nrv += 2**(-n)*binomial(n, n/2)\nreturn rv\n\nreturn bottom_up(rv, f)\n\n\ndef L(rv):\n\"\"\"Return count of trigonometric functions in expression.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import L\n>>> from sympy.abc import x\n>>> from sympy import cos, sin\n>>> L(cos(x)+sin(x))\n2\n\"\"\"\nreturn S(rv.count(TrigonometricFunction))\n\n\n# ============== end of basic Fu-like tools =====================\n\nif SYMPY_DEBUG:\n(TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7, TR8, TR9, TR10, TR11, TR12, TR13,\nTR2i, TRmorrie, TR14, TR15, TR16, TR12i, TR111, TR22\n)= list(map(debug,\n(TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7, TR8, TR9, TR10, TR11, TR12, TR13,\nTR2i, TRmorrie, TR14, TR15, TR16, TR12i, TR111, TR22)))\n\n\n# tuples are chains  --  (f, g) -> lambda x: g(f(x))\n# lists are choices  --  [f, g] -> lambda x: min(f(x), g(x), key=objective)\n\nCTR1 = [(TR5, TR0), (TR6, TR0), identity]\n\nCTR2 = (TR11, [(TR5, TR0), (TR6, TR0), TR0])\n\nCTR3 = [(TRmorrie, TR8, TR0), (TRmorrie, TR8, TR10i, TR0), identity]\n\nCTR4 = [(TR4, TR10i), identity]\n\nRL1 = (TR4, TR3, TR4, TR12, TR4, TR13, TR4, TR0)\n\n\n# XXX it's a little unclear how this one is to be implemented\n# see Fu paper of reference, page 7. What is the Union symbol referring to?\n# The diagram shows all these as one chain of transformations, but the\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n(TR4, TR3, TR10, TR4, TR3, TR11),\n(TR5, TR7, TR11, TR4),\n(CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\nidentity,\n]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n\"\"\"Attempt to simplify expression by using transformation rules given\nin the algorithm by Fu et al.\n\n:func:`fu` will try to minimize the objective function ``measure``.\nBy default this first minimizes the number of trig terms and then minimizes\nthe number of total operations.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import fu\n>>> from sympy import cos, sin, tan, pi, S, sqrt\n>>> from sympy.abc import x, y, a, b\n\n>>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n3/2\n>>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n2*sqrt(2)*sin(x + pi/3)\n\nCTR1 example\n\n>>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n>>> fu(eq)\ncos(x)**4 - 2*cos(y)**2 + 2\n\nCTR2 example\n\n>>> fu(S.Half - cos(2*x)/2)\nsin(x)**2\n\nCTR3 example\n\n>>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\nsqrt(2)*sin(a + b + pi/4)\n\nCTR4 example\n\n>>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\nsin(x + pi/3)\n\nExample 1\n\n>>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n-cos(x)**2 + cos(y)**2\n\nExample 2\n\n>>> fu(cos(4*pi/9))\nsin(pi/18)\n>>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n1/16\n\nExample 3\n\n>>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n-sqrt(3)\n\nObjective function example\n\n>>> fu(sin(x)/cos(x))  # default objective function\ntan(x)\n>>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\nsin(x)/cos(x)\n\nReferences\n==========\nhttp://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\nDESTIME2006/DES_contribs/Fu/simplification.pdf\n\"\"\"\nfRL1 = greedy(RL1, measure)\nfRL2 = greedy(RL2, measure)\n\nwas = rv\nrv = sympify(rv)\nif not isinstance(rv, Expr):\nreturn rv.func(*[fu(a, measure=measure) for a in rv.args])\nrv = TR1(rv)\nif rv.has(tan, cot):\nrv1 = fRL1(rv)\nif (measure(rv1) < measure(rv)):\nrv = rv1\nif rv.has(tan, cot):\nrv = TR2(rv)\nif rv.has(sin, cos):\nrv1 = fRL2(rv)\nrv2 = TR8(TRmorrie(rv1))\nrv = min([was, rv, rv1, rv2], key=measure)\nreturn min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n\"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\na common absolute value of their coefficient and the value of ``key2`` when\napplied to the argument. If ``key1`` is False ``key2`` must be supplied and\nwill be the only key applied.\n\"\"\"\n\n# collect by absolute value of coefficient and key2\nabsc = defaultdict(list)\nif key1:\nfor a in rv.args:\nc, a = a.as_coeff_Mul()\nif c < 0:\nc = -c\na = -a  # put the sign on `a`\nabsc[(c, key2(a) if key2 else 1)].append(a)\nelif key2:\nfor a in rv.args:\nabsc[(S.One, key2(a))].append(a)\nelse:\nraise ValueError('must have at least one key')\n\nargs = []\nhit = False\nfor k in absc:\nv = absc[k]\nc, _ = k\nif len(v) > 1:\ne = Add(*v, evaluate=False)\nnew = do(e)\nif new != e:\ne = new\nhit = True\nargs.append(c*e)\nelse:\nargs.append(c*v[0])\nif hit:\nrv = Add(*args)\n\nreturn rv\n\n\nfufuncs = '''\nTR0 TR1 TR2 TR3 TR4 TR5 TR6 TR7 TR8 TR9 TR10 TR10i TR11\nTR12 TR13 L TR2i TRmorrie TR12i\nTR14 TR15 TR16 TR111 TR22'''.split()\nFU = dict(list(zip(fufuncs, list(map(locals().get, fufuncs)))))\n\n\ndef _roots():\nglobal _ROOT2, _ROOT3, _invROOT3\n_ROOT2, _ROOT3 = sqrt(2), sqrt(3)\n_invROOT3 = 1/_ROOT3\n_ROOT2 = None\n\n\ndef trig_split(a, b, two=False):\n\"\"\"Return the gcd, s1, s2, a1, a2, bool where\n\nIf two is False (default) then::\na + b = gcd*(s1*f(a1) + s2*f(a2)) where f = cos if bool else sin\nelse:\nif bool, a + b was +/- cos(a1)*cos(a2) +/- sin(a1)*sin(a2) and equals\nn1*gcd*cos(a - b) if n1 == n2 else\nn1*gcd*cos(a + b)\nelse a + b was +/- cos(a1)*sin(a2) +/- sin(a1)*cos(a2) and equals\nn1*gcd*sin(a + b) if n1 = n2 else\nn1*gcd*sin(b - a)\n\nExamples\n========\n\n>>> from sympy.simplify.fu import trig_split\n>>> from sympy.abc import x, y, z\n>>> from sympy import cos, sin, sqrt\n\n>>> trig_split(cos(x), cos(y))\n(1, 1, 1, x, y, True)\n>>> trig_split(2*cos(x), -2*cos(y))\n(2, 1, -1, x, y, True)\n>>> trig_split(cos(x)*sin(y), cos(y)*sin(y))\n(sin(y), 1, 1, x, y, True)\n\n>>> trig_split(cos(x), -sqrt(3)*sin(x), two=True)\n(2, 1, -1, x, pi/6, False)\n>>> trig_split(cos(x), sin(x), two=True)\n(sqrt(2), 1, 1, x, pi/4, False)\n>>> trig_split(cos(x), -sin(x), two=True)\n(sqrt(2), 1, -1, x, pi/4, False)\n>>> trig_split(sqrt(2)*cos(x), -sqrt(6)*sin(x), two=True)\n(2*sqrt(2), 1, -1, x, pi/6, False)\n>>> trig_split(-sqrt(6)*cos(x), -sqrt(2)*sin(x), two=True)\n(-2*sqrt(2), 1, 1, x, pi/3, False)\n>>> trig_split(cos(x)/sqrt(6), sin(x)/sqrt(2), two=True)\n(sqrt(6)/3, 1, 1, x, pi/6, False)\n>>> trig_split(-sqrt(6)*cos(x)*sin(y), -sqrt(2)*sin(x)*sin(y), two=True)\n(-2*sqrt(2)*sin(y), 1, 1, x, pi/3, False)\n\n>>> trig_split(cos(x), sin(x))\n>>> trig_split(cos(x), sin(z))\n>>> trig_split(2*cos(x), -sin(x))\n>>> trig_split(cos(x), -sqrt(3)*sin(x))\n>>> trig_split(cos(x)*cos(y), sin(x)*sin(z))\n>>> trig_split(cos(x)*cos(y), sin(x)*sin(y))\n>>> trig_split(-sqrt(6)*cos(x), sqrt(2)*sin(x)*sin(y), two=True)\n\"\"\"\nglobal _ROOT2, _ROOT3, _invROOT3\nif _ROOT2 is None:\n_roots()\n\na, b = [Factors(i) for i in (a, b)]\nua, ub = a.normal(b)\ngcd = a.gcd(b).as_expr()\nn1 = n2 = 1\nif S.NegativeOne in ua.factors:\nua = ua.quo(S.NegativeOne)\nn1 = -n1\nelif S.NegativeOne in ub.factors:\nub = ub.quo(S.NegativeOne)\nn2 = -n2\na, b = [i.as_expr() for i in (ua, ub)]\n\ndef pow_cos_sin(a, two):\n\"\"\"Return ``a`` as a tuple (r, c, s) such that\n``a = (r or 1)*(c or 1)*(s or 1)``.\n\nThree arguments are returned (radical, c-factor, s-factor) as\nlong as the conditions set by ``two`` are met; otherwise None is\nreturned. If ``two`` is True there will be one or two non-None\nvalues in the tuple: c and s or c and r or s and r or s or c with c\nbeing a cosine function (if possible) else a sine, and s being a sine\nfunction (if possible) else oosine. If ``two`` is False then there\nwill only be a c or s term in the tuple.\n\n``two`` also require that either two cos and/or sin be present (with\nthe condition that if the functions are the same the arguments are\ndifferent or vice versa) or that a single cosine or a single sine\nbe present with an optional radical.\n\nIf the above conditions dictated by ``two`` are not met then None\nis returned.\n\"\"\"\nc = s = None\nco = S.One\nif a.is_Mul:\nco, a = a.as_coeff_Mul()\nif len(a.args) > 2 or not two:\nreturn None\nif a.is_Mul:\nargs = list(a.args)\nelse:\nargs = [a]\na = args.pop(0)\nif isinstance(a, cos):\nc = a\nelif isinstance(a, sin):\ns = a\nelif a.is_Pow and a.exp is S.Half:  # autoeval doesn't allow -1/2\nco *= a\nelse:\nreturn None\nif args:\nb = args[0]\nif isinstance(b, cos):\nif c:\ns = b\nelse:\nc = b\nelif isinstance(b, sin):\nif s:\nc = b\nelse:\ns = b\nelif b.is_Pow and b.exp is S.Half:\nco *= b\nelse:\nreturn None\nreturn co if co is not S.One else None, c, s\nelif isinstance(a, cos):\nc = a\nelif isinstance(a, sin):\ns = a\nif c is None and s is None:\nreturn\nco = co if co is not S.One else None\nreturn co, c, s\n\n# get the parts\nm = pow_cos_sin(a, two)\nif m is None:\nreturn\ncoa, ca, sa = m\nm = pow_cos_sin(b, two)\nif m is None:\nreturn\ncob, cb, sb = m\n\n# check them\nif (not ca) and cb or ca and isinstance(ca, sin):\ncoa, ca, sa, cob, cb, sb = cob, cb, sb, coa, ca, sa\nn1, n2 = n2, n1\nif not two:  # need cos(x) and cos(y) or sin(x) and sin(y)\nc = ca or sa\ns = cb or sb\nif not isinstance(c, s.func):\nreturn None\nreturn gcd, n1, n2, c.args[0], s.args[0], isinstance(c, cos)\nelse:\nif not coa and not cob:\nif (ca and cb and sa and sb):\nif isinstance(ca, sa.func) is not isinstance(cb, sb.func):\nreturn\nargs = {j.args for j in (ca, sa)}\nif not all(i.args in args for i in (cb, sb)):\nreturn\nreturn gcd, n1, n2, ca.args[0], sa.args[0], isinstance(ca, sa.func)\nif ca and sa or cb and sb or \\\ntwo and (ca is None and sa is None or cb is None and sb is None):\nreturn\nc = ca or sa\ns = cb or sb\nif c.args != s.args:\nreturn\nif not coa:\ncoa = S.One\nif not cob:\ncob = S.One\nif coa is cob:\ngcd *= _ROOT2\nreturn gcd, n1, n2, c.args[0], pi/4, False\nelif coa/cob == _ROOT3:\ngcd *= 2*cob\nreturn gcd, n1, n2, c.args[0], pi/3, False\nelif coa/cob == _invROOT3:\ngcd *= 2*coa\nreturn gcd, n1, n2, c.args[0], pi/6, False\n\n\ndef as_f_sign_1(e):\n\"\"\"If ``e`` is a sum that can be written as ``g*(a + s)`` where\n``s`` is ``+/-1``, return ``g``, ``a``, and ``s`` where ``a`` does\nnot have a leading negative coefficient.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import as_f_sign_1\n>>> from sympy.abc import x\n>>> as_f_sign_1(x + 1)\n(1, x, 1)\n>>> as_f_sign_1(x - 1)\n(1, x, -1)\n>>> as_f_sign_1(-x + 1)\n(-1, x, -1)\n>>> as_f_sign_1(-x - 1)\n(-1, x, 1)\n>>> as_f_sign_1(2*x + 2)\n(2, x, 1)\n\"\"\"\nif not e.is_Add or len(e.args) != 2:\nreturn\n# exact match\na, b = e.args\nif a in (S.NegativeOne, S.One):\ng = S.One\nif b.is_Mul and b.args[0].is_Number and b.args[0] < 0:\na, b = -a, -b\ng = -g\nreturn g, b, a\n# gcd match\na, b = [Factors(i) for i in e.args]\nua, ub = a.normal(b)\ngcd = a.gcd(b).as_expr()\nif S.NegativeOne in ua.factors:\nua = ua.quo(S.NegativeOne)\nn1 = -1\nn2 = 1\nelif S.NegativeOne in ub.factors:\nub = ub.quo(S.NegativeOne)\nn1 = 1\nn2 = -1\nelse:\nn1 = n2 = 1\na, b = [i.as_expr() for i in (ua, ub)]\nif a is S.One:\na, b = b, a\nn1, n2 = n2, n1\nif n1 == -1:\ngcd = -gcd\nn2 = -n2\n\nif b is S.One:\nreturn gcd, a, n2\n\n\ndef _osborne(e, d):\n\"\"\"Replace all hyperbolic functions with trig functions using\nthe Osborne rule.\n\nNotes\n=====\n\n``d`` is a dummy variable to prevent automatic evaluation\nof trigonometric/hyperbolic functions.\n\n\nReferences\n==========\n\nhttps://en.wikipedia.org/wiki/Hyperbolic_function\n\"\"\"\n\ndef f(rv):\nif not isinstance(rv, HyperbolicFunction):\nreturn rv\na = rv.args[0]\na = a*d if not a.is_Add else Add._from_args([i*d for i in a.args])\nif isinstance(rv, sinh):\nreturn I*sin(a)\nelif isinstance(rv, cosh):\nreturn cos(a)\nelif isinstance(rv, tanh):\nreturn I*tan(a)\nelif isinstance(rv, coth):\nreturn cot(a)/I\nelif isinstance(rv, sech):\nreturn sec(a)\nelif isinstance(rv, csch):\nreturn csc(a)/I\nelse:\nraise NotImplementedError('unhandled %s' % rv.func)\n\nreturn bottom_up(e, f)\n\n\ndef _osbornei(e, d):\n\"\"\"Replace all trig functions with hyperbolic functions using\nthe Osborne rule.\n\nNotes\n=====\n\n``d`` is a dummy variable to prevent automatic evaluation\nof trigonometric/hyperbolic functions.\n\nReferences\n==========\n\nhttps://en.wikipedia.org/wiki/Hyperbolic_function\n\"\"\"\n\ndef f(rv):\nif not isinstance(rv, TrigonometricFunction):\nreturn rv\nconst, x = rv.args[0].as_independent(d, as_Add=True)\na = x.xreplace({d: S.One}) + const*I\nif isinstance(rv, sin):\nreturn sinh(a)/I\nelif isinstance(rv, cos):\nreturn cosh(a)\nelif isinstance(rv, tan):\nreturn tanh(a)/I\nelif isinstance(rv, cot):\nreturn coth(a)*I\nelif isinstance(rv, sec):\nreturn sech(a)\nelif isinstance(rv, csc):\nreturn csch(a)*I\nelse:\nraise NotImplementedError('unhandled %s' % rv.func)\n\nreturn bottom_up(e, f)\n\n\ndef hyper_as_trig(rv):\n\"\"\"Return an expression containing hyperbolic functions in terms\nof trigonometric functions. Any trigonometric functions initially\npresent are replaced with Dummy symbols and the function to undo\nthe masking and the conversion back to hyperbolics is also returned. It\nshould always be true that::\n\nt, f = hyper_as_trig(expr)\nexpr == f(t)\n\nExamples\n========\n\n>>> from sympy.simplify.fu import hyper_as_trig, fu\n>>> from sympy.abc import x\n>>> from sympy import cosh, sinh\n>>> eq = sinh(x)**2 + cosh(x)**2\n>>> t, f = hyper_as_trig(eq)\n>>> f(fu(t))\ncosh(2*x)\n\nReferences\n==========\n\nhttps://en.wikipedia.org/wiki/Hyperbolic_function\n\"\"\"\nfrom sympy.simplify.simplify import signsimp\nfrom sympy.simplify.radsimp import collect\n\n# mask off trig functions\ntrigs = rv.atoms(TrigonometricFunction)\nreps = [(t, Dummy()) for t in trigs]\nmasked = rv.xreplace(dict(reps))\n\n# get inversion substitutions in place\nreps = [(v, k) for k, v in reps]\n\nd = Dummy()\n\nreturn _osborne(masked, d), lambda x: collect(signsimp(\n_osbornei(x, d).xreplace(dict(reps))), S.ImaginaryUnit)\n\n\ndef sincos_to_sum(expr):\n\"\"\"Convert products and powers of sin and cos to sums.\n\nApplied power reduction TRpower first, then expands products, and\nconverts products to sums with TR8.\n\nExamples\n========\n\n>>> from sympy.simplify.fu import sincos_to_sum\n>>> from sympy.abc import x\n>>> from sympy import cos, sin\n>>> sincos_to_sum(16*sin(x)**3*cos(2*x)**2)\n7*sin(x) - 5*sin(3*x) + 3*sin(5*x) - sin(7*x)\n\"\"\"\n\nif not expr.has(cos, sin):\nreturn expr\nelse:\nreturn TR8(expand_mul(TRpower(expr)))\n"
    },
    "ground_truth_patch": {
        "sympy/simplify/fu.py": "         # change is not going to allow a simplification as far as I can tell.\n         if not (rv.is_Pow and rv.base.func == f):\n             return rv\nif not rv.exp.is_real:\nreturn rv\n \n         if (rv.exp < 0) == True:\n             return rv\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical apart from whitespace, layout, and the presence of comments. The actual logic and structure of the code is unchanged.\"}"
}