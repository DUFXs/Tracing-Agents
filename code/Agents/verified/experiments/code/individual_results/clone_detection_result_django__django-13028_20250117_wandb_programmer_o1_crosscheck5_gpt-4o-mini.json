{
    "instance_id": "django__django-13028",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/sql/query.py": "index ce18098fd2..2178dee5d0 100644\n                     self.check_query_object_type(v, opts, field)\n \n     def check_filterable(self, expression):\n# If this is a model instance (has _meta) rather than a Django expression,\n# skip the filterable check entirely to avoid clashing with user fields named 'filterable'.\nif hasattr(expression, '_meta'):\nreturn\n         if not getattr(expression, 'filterable', True):\n             raise NotSupportedError(\nexpression.__class__.__name__ + ' is disallowed in the filter clause.'\n             )\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n\n\n \n     def build_lookup(self, lookups, lhs, rhs):\n         \"\"\"\n",
        "test_filterable_bug.py": "new file mode 100644\nindex 0000000000..920f44f724\nimport sys\nimport traceback\nimport django\nfrom django.conf import settings\nfrom django.db import models\n\ndef main():\nprint(\"Setting up test environment.\")\nsettings.configure(\nDEBUG=True,\nINSTALLED_APPS=[\n'django.contrib.contenttypes',\n'testapp',\n],\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\nTIME_ZONE='UTC',\nUSE_TZ=True,\nSECRET_KEY='secret',\nMIDDLEWARE_CLASSES=(),\n)\ndjango.setup()\n\nfrom django.db import connection, transaction\n\nclass ProductMetadataType(models.Model):\nfilterable = models.BooleanField(default=False)  # Field that triggers the bug\nlabel = models.CharField(max_length=255, blank=True)\n\nclass Meta:\napp_label = 'testapp'\n\nclass ProductMetadata(models.Model):\nmetadata_type = models.ForeignKey(ProductMetadataType, on_delete=models.CASCADE)\nvalue = models.TextField()\n\nclass Meta:\napp_label = 'testapp'\n\n# Create DB tables for the test models\nwith connection.schema_editor() as editor:\neditor.create_model(ProductMetadataType)\neditor.create_model(ProductMetadata)\n\n# Reproduce the bug\ntry:\nwith transaction.atomic():\nt = ProductMetadataType.objects.create(filterable=False, label='testing')\npm = ProductMetadata.objects.create(metadata_type=t, value='Dark Vador')\n\nprint(\"Filtering on ProductMetadata with metadata_type:\", t.id)\nresults = ProductMetadata.objects.filter(value='Dark Vador', metadata_type=t)\nprint(\"Filter worked; retrieved\", results.count(), \"items.\")\n\nexcept Exception as e:\ntraceback.print_exc()\nprint(\"Bug reproduced: NotSupportedError or unexpected exception encountered.\")\nsys.exit(1)\n\nprint(\"No error, so the bug is fixed (or never triggered).\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n",
        "testapp/__init__.py": "new file mode 100644\nindex 0000000000..2f55ccceb8\n# empty init so that testapp is a recognized Python package\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/query.py": " \n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\nif (\nhasattr(expression, 'resolve_expression') and\nnot getattr(expression, 'filterable', True)\n):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n                 'clause.'\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share similar structures and functionalities, but there are differences in how they handle the logic and syntax. The second sample introduces a conditional check with a different condition and an explanation comment which is different from the first sample. Additionally, the layout and whitespace in the two samples differ, as well as the error message format.\"}"
}