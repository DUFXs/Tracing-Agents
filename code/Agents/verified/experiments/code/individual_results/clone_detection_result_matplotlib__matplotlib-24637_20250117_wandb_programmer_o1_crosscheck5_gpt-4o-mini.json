{
    "instance_id": "matplotlib__matplotlib-24637",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "lib/matplotlib/offsetbox.py": "index efa34dd078..4172cc0eb5 100644\n             self.arrow_patch.set_patchA(patchA)\n \n     def draw(self, renderer):\n         if renderer is not None:\n             self._renderer = renderer\n         if not self.get_visible() or not self._check_xy(renderer):\n             return\n\ngid = self.get_gid()\nif gid:\nrenderer.open_group('annotationbbox', gid=gid)\n\n         self.update_positions(renderer)\n         if self.arrow_patch is not None:\n             if self.arrow_patch.figure is None and self.figure is not None:\n             self.arrow_patch.draw(renderer)\n         self.patch.draw(renderer)\n         self.offsetbox.draw(renderer)\n\nif gid:\nrenderer.close_group('annotationbbox')\n\n         self.stale = False\n\n \n \n class DraggableBase:\n",
        "test_annotationbbox.svg": "new file mode 100644\nindex 0000000000..a45c48d659\nBinary files /dev/null and b/test_annotationbbox.svg differ\n",
        "test_gid_annotationbbox.py": "new file mode 100644\nindex 0000000000..76dbb8168d\nimport sys\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.offsetbox import OffsetImage, AnnotationBbox\n\ndef main():\nprint(\"Reproducing the AnnotationBbox GID issue.\")\nfig, ax = plt.subplots()\narr_img = np.random.rand(10, 10, 3)\nimagebox = OffsetImage(arr_img, zoom=0.1)\nab = AnnotationBbox(\nimagebox,\n(0.3, 0.55),\nxybox=(120., -80.),\nxycoords=\"data\",\nboxcoords=\"offset points\",\npad=0.5,\narrowprops=dict(arrowstyle=\"->\", connectionstyle=\"angle,angleA=0,angleB=90,rad=3\")\n)\nab.set_gid(\"My_label\")\nax.add_artist(ab)\noutfile = \"test_annotationbbox.svg\"\nfig.savefig(outfile)\nprint(f\"Wrote {outfile}\")\nwith open(outfile, \"r\", encoding=\"utf-8\") as f:\ncontents = f.read()\nif 'id=\"My_label\"' in contents or \"id='My_label'\" in contents:\nprint(\"Found id=\\\"My_label\\\" in the svg. Test pass.\")\nsys.exit(0)\nelse:\nprint(\"Did NOT find id=\\\"My_label\\\" in the svg. Test fail.\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "lib/matplotlib/offsetbox.py": "             self._renderer = renderer\n         if not self.get_visible() or not self._check_xy(renderer):\n             return\nrenderer.open_group(self.__class__.__name__, gid=self.get_gid())\n         self.update_positions(renderer)\n         if self.arrow_patch is not None:\n             if self.arrow_patch.figure is None and self.figure is not None:\n             self.arrow_patch.draw(renderer)\n         self.patch.draw(renderer)\n         self.offsetbox.draw(renderer)\nrenderer.close_group(self.__class__.__name__)\n         self.stale = False\n \n \n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-2\", \"reasoning\": \"These code samples are type-2 clones because they are identical except for differences in identifier names and formatting. Both samples feature similar logic and structure, with the difference that sample 2 uses 'self.__class__.__name__' instead of 'gid=self.get_gid()' and modifies the invocation of the 'open_group' and 'close_group' functions, while maintaining the same overall functionality.\"}"
}