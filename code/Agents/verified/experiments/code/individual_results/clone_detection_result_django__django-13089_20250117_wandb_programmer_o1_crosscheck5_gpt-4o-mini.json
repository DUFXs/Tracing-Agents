{
    "instance_id": "django__django-13089",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/core/cache/backends/db.py": "index 33c79c5a14..4332b2a04e 100644\n         else:\n             connection = connections[db]\n             table = connection.ops.quote_name(self._table)\n# Remove expired entries first\ncursor.execute(\n\"DELETE FROM %s WHERE expires < %%s\" % table,\n[connection.ops.adapt_datetimefield_value(now)]\n)\n             cursor.execute(\"SELECT COUNT(*) FROM %s\" % table)\n             num = cursor.fetchone()[0]\n             if num > self._max_entries:\n                 cull_num = num // self._cull_frequency\n                 cursor.execute(\n                     connection.ops.cache_key_culling_sql() % table,\n[cull_num]\n)\nrow = cursor.fetchone()\nif row is None:\n# No row was returned; safely skip\nreturn\n# Now delete rows with cache_key < row[0]\ncursor.execute(\n\"DELETE FROM %s WHERE cache_key < %%s\" % table,\n[row[0]]\n)\n\n \n     def clear(self):\n         db = router.db_for_write(self.cache_model_class)\n",
        "test_bug_cull.py": "new file mode 100644\nindex 0000000000..68b74fd666\nimport sys\nimport django\nfrom django.conf import settings\nfrom django.db import connection\nfrom django.core.cache.backends.db import DatabaseCache\n\ndef main():\nprint(\"Configuring settings...\")\nsettings.configure(\nINSTALLED_APPS=[\"django.contrib.contenttypes\"],\nDATABASES={\n\"default\": {\n\"ENGINE\": \"django.db.backends.sqlite3\",\n\"NAME\": \":memory:\",\n},\n},\nUSE_TZ=False,\nSECRET_KEY=\"test_secret_key\",\n)\ndjango.setup()\n\nprint(\"Creating table 'testcachetable'...\")\nwith connection.cursor() as c:\nc.execute(\"CREATE TABLE testcachetable (cache_key varchar(255) primary key, value text, expires datetime)\")\n\nprint(\"Initializing DatabaseCache with MAX_ENTRIES=2, CULL_FREQUENCY=1\")\ndb_cache = DatabaseCache(\"testcachetable\", params={\"MAX_ENTRIES\":2, \"CULL_FREQUENCY\":1})\n\nprint(\"Storing multiple items so cull_num > total entries, forcing cursor.fetchone() to return None on HEAD...\")\ntry:\nfor i in range(10):\nk = f\"key{i}\"\ndb_cache.set(k, f\"value{i}\")\nprint(f\"Set item {k}\")\nprint(\"SUCCESS: No exception thrown. Possibly the bug is fixed.\")\nsys.exit(0)\nexcept Exception as e:\nprint(\"FAILURE: Encountered an exception, indicating the bug persists.\")\nprint(\"Exception:\", e)\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/core/cache/backends/db.py": "                 cursor.execute(\n                     connection.ops.cache_key_culling_sql() % table,\n                     [cull_num])\nlast_cache_key = cursor.fetchone()\nif last_cache_key:\ncursor.execute(\n'DELETE FROM %s WHERE cache_key < %%s' % table,\n[last_cache_key[0]],\n)\n \n     def clear(self):\n         db = router.db_for_write(self.cache_model_class)\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share similar syntactic structures but contain additional or modified statements. The first code sample includes a broader context within the cache clear implementation, while the second code sample is a continuation that specifically focuses on executing a cache key deletion based on a fetched result. There are enough differences in statements present that indicate they are not identical, but the core functionality and intent are maintained, marking them as clones.\"}"
}