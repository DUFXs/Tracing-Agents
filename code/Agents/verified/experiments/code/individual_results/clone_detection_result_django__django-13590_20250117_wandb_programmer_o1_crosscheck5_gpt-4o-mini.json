{
    "instance_id": "django__django-13590",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/sql/query.py": "index 4648daf395..b3ce0647be 100644\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\nitems = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n# If this is a namedtuple, expand args. Otherwise, pass them as one iterable.\nif hasattr(value, '_fields'):\nreturn type(value)(*items)\nelse:\nreturn type(value)(items)\n         return value\n\n \n     def solve_lookup_type(self, lookup):\n         \"\"\"\n",
        "test_namedtuple_range.py": "new file mode 100644\nindex 0000000000..1a9479cc26\nimport sys\nimport django\nimport os\nfrom django.conf import settings\nfrom django.db import models, connection\nfrom collections import namedtuple\n\n# Minimal project setup\nif not settings.configured:\nsettings.configure(\nINSTALLED_APPS=[],\nDATABASES={\"default\": {\"ENGINE\": \"django.db.backends.sqlite3\", \"NAME\": \":memory:\"}},\nSECRET_KEY=\"testkey\",\n)\n\ndjango.setup()\n\nclass RangeModel(models.Model):\nvalue = models.IntegerField()\nclass Meta:\napp_label = \"namedtuple_range_app\"\n\n# Create table directly with schema_editor (no migrations).\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(RangeModel)\n\n# Insert sample data.\nRangeModel.objects.create(value=5)\nRangeModel.objects.create(value=10)\n\nMyRange = namedtuple(\"MyRange\", [\"start\", \"end\"])\ntest_tuple = MyRange(start=5, end=10)\n\ntry:\n# This filter triggers the namedtuple range bug on Django <= 3.0\nqs = RangeModel.objects.filter(value__range=test_tuple)\nprint(\"Filter succeeded with namedtuple range argument!\")\nsys.exit(0)\nexcept TypeError as e:\nprint(\"TEST FAILED. Got TypeError for namedtuple range, indicating the bug is present.\")\nprint(f\"Error details: {e}\")\nsys.exit(1)\nexcept Exception as e:\nprint(\"TEST FAILED. An unexpected exception occurred.\")\nprint(f\"Exception details: {e}\")\nsys.exit(1)\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/query.py": "         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\nvalues = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\ntype_ = type(value)\nif hasattr(type_, '_make'):  # namedtuple\nreturn type_(*values)\nreturn type_(values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-2\", \"reasoning\": \"These code samples are type-2 clones because they show identical structures with changes in identifier names and literal values. For instance, 'items' in the first code sample has been changed to 'values' in the second, and the return statements have a slight rewording ('return type(value)(*items)' vs. 'return type_(*values)'). Although the main logic remains the same, these changes distinguish them as type-2 clones.\"}"
}