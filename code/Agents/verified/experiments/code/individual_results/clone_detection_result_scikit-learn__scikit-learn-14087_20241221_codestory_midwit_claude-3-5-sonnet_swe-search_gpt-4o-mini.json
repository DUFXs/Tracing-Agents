{
    "instance_id": "scikit-learn__scikit-learn-14087",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "reproduce_error.py": "new file mode 100644\nindex 000000000..dde272031\nimport sys\nimport sklearn\nfrom sklearn.linear_model import LogisticRegressionCV\nimport numpy as np\n\nnp.random.seed(29)\nX = np.random.normal(size=(1000, 3))\nbeta = np.random.normal(size=3)\nintercept = np.random.normal(size=None)\ny = np.sign(intercept + X @ beta)\n\nmodel = LogisticRegressionCV(\ncv=5,\nsolver='saga',  # same error with 'liblinear'\ntol=1e-2,\nrefit=False).fit(X, y)\n\nprint(\"Success if we reach here!\")\n\\ No newline at end of file\n",
        "sklearn/linear_model/logistic.py": "index 1999f1dae..d4bba2754 100644\n                     w = np.mean([coefs_paths[i, best_indices[i], :]\n                                  for i in range(len(folds))], axis=0)\n                 else:\n# For multinomial case, coefs_paths has shape (n_classes, n_folds, n_Cs, n_features)\nw = np.mean([coefs_paths[..., i, best_indices[i], :]\n                                  for i in range(len(folds))], axis=0)\n \n                 best_indices_C = best_indices % len(self.Cs_)\n                 self.C_.append(np.mean(self.Cs_[best_indices_C]))\n \nif self.penalty == 'elasticnet':\nbest_indices_l1 = best_indices // len(self.Cs_)\nself.l1_ratio_.append(np.mean(l1_ratios_[best_indices_l1]))\nelse:\nself.l1_ratio_.append(None)\n \n             if multi_class == 'multinomial':\n                 self.C_ = np.tile(self.C_, n_classes)\n"
    },
    "ground_truth_patch": {
        "sklearn/linear_model/logistic.py": "                 # Take the best scores across every fold and the average of\n                 # all coefficients corresponding to the best scores.\n                 best_indices = np.argmax(scores, axis=1)\nif multi_class == 'ovr':\n                     w = np.mean([coefs_paths[i, best_indices[i], :]\n                                  for i in range(len(folds))], axis=0)\n                 else:\n                 best_indices_C = best_indices % len(self.Cs_)\n                 self.C_.append(np.mean(self.Cs_[best_indices_C]))\n \nif self.penalty == 'elasticnet':\nbest_indices_l1 = best_indices // len(self.Cs_)\nself.l1_ratio_.append(np.mean(l1_ratios_[best_indices_l1]))\nelse:\nself.l1_ratio_.append(None)\n \n             if multi_class == 'multinomial':\n                 self.C_ = np.tile(self.C_, n_classes)\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-4\", \"reasoning\": \"These code samples are type-4 clones because they exhibit syntactical dissimilarity but have functionally equivalent behavior. Both code samples perform operations related to logistic regression model training using similar mechanisms such as best coefficient selection but differ in their comments and layout.\"}"
}