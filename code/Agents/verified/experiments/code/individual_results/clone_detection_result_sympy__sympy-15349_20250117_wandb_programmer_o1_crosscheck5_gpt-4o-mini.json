{
    "instance_id": "sympy__sympy-15349",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "sympy/algebras/quaternion.py": "index b84e7cb95a..f99d4d5e3d 100644\n         return t\n \n     def to_rotation_matrix(self, v=None):\n\"\"\"\nReturns the equivalent rotation transformation matrix of the quaternion\n         which represents rotation about the origin if v is not passed.\n\n         Example\n         ========\n\n         >>> from sympy.algebras.quaternion import Quaternion\n         >>> from sympy import symbols, trigsimp, cos, sin\n         >>> x = symbols('x')\n         [cos(x), -sin(x), 0],\n         [sin(x),  cos(x), 0],\n         [     0,       0, 1]])\n\n         Generates a 4x4 transformation matrix (used for rotation about a point\n         other than the origin) if the point(v) is passed as an argument.\n\n         Example\n         ========\n\n         >>> from sympy.algebras.quaternion import Quaternion\n         >>> from sympy import symbols, trigsimp, cos, sin\n         >>> x = symbols('x')\n         [     0,       0, 1,                    0],\n         [     0,       0, 0,                    1]])\n         \"\"\"\n         q = self\n         s = q.norm()**-2\n         m00 = 1 - 2*s*(q.c**2 + q.d**2)\n         m01 = 2*s*(q.b*q.c - q.d*q.a)\n         m02 = 2*s*(q.b*q.d + q.c*q.a)\n\n         m10 = 2*s*(q.b*q.c + q.d*q.a)\n         m11 = 1 - 2*s*(q.b**2 + q.d**2)\nm12 = 2*s*(q.c*q.d - q.b*q.a)  # Fixed sign here\n\n         m20 = 2*s*(q.b*q.d - q.c*q.a)\n         m21 = 2*s*(q.c*q.d + q.b*q.a)\n         m22 = 1 - 2*s*(q.b**2 + q.c**2)\n\n         if not v:\nreturn Matrix([[m00, m01, m02],\n[m10, m11, m12],\n[m20, m21, m22]])\n\n         else:\n             (x, y, z) = v\n\n             m03 = x - x*m00 - y*m01 - z*m02\n             m13 = y - x*m10 - y*m11 - z*m12\n             m23 = z - x*m20 - y*m21 - z*m22\n             m30 = m31 = m32 = 0\n             m33 = 1\n\nreturn Matrix([[m00, m01, m02, m03],\n[m10, m11, m12, m13],\n[m20, m21, m22, m23],\n[m30, m31, m32, m33]])\n\n",
        "sympy/algebras/tests/test_quaternion.py": "index 420e9976d2..52cdecf887 100644\n \n \n def test_quaternion_conversions():\nfrom sympy.algebras.quaternion import Quaternion\nfrom sympy import symbols, acos, sqrt, Matrix, trigsimp, cos, sin, S\n \nq1 = Quaternion(1, 2, 3, 4)\n# The axis-angle remains the same regardless of the sign fix.\nassert q1.to_axis_angle() == (\n(2*sqrt(29)/29, 3*sqrt(29)/29, 4*sqrt(29)/29),\n2*acos(sqrt(30)/30)\n)\n\n# With the minus sign fix, this is the correct 3x3 rotation matrix:\nM3 = Matrix([\n[-S(2)/3,  S(2)/15,  S(11)/15],\n[ S(2)/3, -S(1)/3,   S(2)/3],\n[ S(1)/3,  S(14)/15, S(2)/15]\n])\nassert q1.to_rotation_matrix() == M3\n\n# For rotation about a point (1,1,1), the last column changes accordingly:\nM4 = Matrix([\n[-S(2)/3,  S(2)/15,  S(11)/15,  S(4)/5],\n[ S(2)/3, -S(1)/3,   S(2)/3,    S(0)],\n[ S(1)/3,  S(14)/15, S(2)/15,  -S(2)/5],\n[ S(0),    S(0),     S(0),      S(1)]\n])\nassert q1.to_rotation_matrix((1,1,1)) == M4\n\n# Check a simpler quaternion representing a rotation about z:\n     theta = symbols(\"theta\", real=True)\n     q2 = Quaternion(cos(theta/2), 0, 0, sin(theta/2))\nM2_expected = Matrix([\n[cos(theta), -sin(theta), 0],\n[sin(theta),  cos(theta), 0],\n[0,           0,          1]\n])\nassert trigsimp(q2.to_rotation_matrix()) == M2_expected\n\n# And for a point offset:\nM2_offset = Matrix([\n[cos(theta), -sin(theta), 0, sin(theta) - cos(theta) + 1],\n[sin(theta),  cos(theta), 0, -sin(theta) - cos(theta) + 1],\n[0,           0,          1, 0],\n[0,           0,          0, 1]\n])\nassert trigsimp(q2.to_rotation_matrix((1,1,1))) == M2_offset\n\n\ndef placeholder():\npass\n \n",
        "test_quaternion_bug.py": "new file mode 100644\nindex 0000000000..4d4f6373fd\nimport sys\nimport sympy\nfrom sympy import symbols, sin, cos, trigsimp, Matrix\nfrom sympy.algebras.quaternion import Quaternion\n\ndef main():\nprint(\"Reproduction test for Quaternion.to_rotation_matrix sign bug...\")\nx = symbols('x', real=True)\nq = Quaternion(cos(x/2), sin(x/2), 0, 0)\nM = trigsimp(q.to_rotation_matrix())\nexpected = Matrix([\n[1, 0, 0],\n[0, cos(x), -sin(x)],\n[0, sin(x),  cos(x)]\n])\n\nprint(\"Quaternion:\", q)\nprint(\"Computed rotation matrix (trigsimp):\")\nprint(M)\nprint(\"Expected rotation matrix:\")\nprint(expected)\ndiff = trigsimp(M - expected)\nprint(\"Difference:\")\nprint(diff)\n\n# Check each element == 0\nif any(sympy.simplify(elem) != 0 for elem in diff):\nprint(\"Test fails: rotation matrix does not match expected.\")\nsys.exit(1)\nelse:\nprint(\"Test passes: rotation matrix matches expected.\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "sympy/algebras/quaternion.py": " \n         m10 = 2*s*(q.b*q.c + q.d*q.a)\n         m11 = 1 - 2*s*(q.b**2 + q.d**2)\nm12 = 2*s*(q.c*q.d - q.b*q.a)\n \n         m20 = 2*s*(q.b*q.d - q.c*q.a)\n         m21 = 2*s*(q.c*q.d + q.b*q.a)\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-2\", \"reasoning\": \"These code samples are type-2 clones because they are identical except for whitespace, some differences in layout, and potential differences in how the identifiers are represented. The variable names and structure appear similar, and both snippets contain similar mathematical operations related to quaternion rotation matrices, although presented in different contexts.\"}"
}