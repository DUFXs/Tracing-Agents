{
    "instance_id": "sympy__sympy-21847",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "sympy/polys/monomials.py": "index 0e84403307..7dc96a2aa7 100644\n from sympy.utilities import public\n from sympy.core.compatibility import is_sequence\n \n def itermonomials(variables, max_degrees, min_degrees=None):\n\"Implement itermonomials\"\n \nfrom sympy.core import Mul, S\nfrom itertools import combinations_with_replacement, product\nfrom sympy.core.compatibility import is_sequence\n \n     n = len(variables)\n     if is_sequence(max_degrees):\n         if len(max_degrees) != n:\n                 raise ValueError(\"min_degrees can't be negative\")\n             min_degree = min_degrees\n         total_degree = True\n\n     if total_degree:\n         if min_degree > max_degree:\n             return\n                 for variable in item:\n                     if variable != 1:\n                         powers[variable] += 1\nif sum(powers.values()) >= min_degree:\n                     monomials_list_comm.append(Mul(*item))\n             yield from set(monomials_list_comm)\n         else:\n                 for variable in item:\n                     if variable != 1:\n                         powers[variable] += 1\nif sum(powers.values()) >= min_degree:\n                     monomials_list_non_comm.append(Mul(*item))\n             yield from set(monomials_list_non_comm)\n     else:\n         for powers in product(*power_lists):\n             yield Mul(*powers)\n \n\n def monomial_count(V, N):\n     r\"\"\"\n     Computes the number of monomials.\n",
        "test_itermonomials_min_degrees_bug.py": "new file mode 100644\nindex 0000000000..4eece299af\n#!/usr/bin/env python\n\nimport sys\nimport sympy as sp\nfrom sympy.polys.orderings import monomial_key\n\ndef main():\nprint(\"Reproducer for itermonomials min_degrees bug.\")\nx1, x2, x3 = sp.symbols('x1 x2 x3', commutative=True)\nstates = [x1, x2, x3]\nmax_degrees = 3\nmin_degrees = 3\nmonomials = sorted(sp.itermonomials(states, max_degrees, min_degrees=min_degrees),\nkey=monomial_key('grlex', states))\n# Expect all total-degree-3 monomials: x1^3, x1^2*x2, x1*x2^2, x2^3, x3^3, x1*x2*x3, etc.\n# The correct set is:\nexpected = {\nx1**3, x2**3, x3**3,\nx1**2*x2, x1**2*x3, x2**2*x1, x2**2*x3, x3**2*x1, x3**2*x2,\nx1*x2*x3\n}\ngot = set(monomials)\n\n# Print them out\nprint(\"Got monomials = \", got)\nprint(\"Expected monomials = \", expected)\n\nmissing = expected - got\nextra = got - expected\n\nif missing:\nprint(\"FAIL: Missing monomials: \", missing)\nsys.exit(1)\nif extra:\nprint(\"FAIL: Unexpected monomials: \", extra)\nsys.exit(1)\nprint(\"PASS: All expected monomials are present and correct.\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "sympy/polys/monomials.py": "                 for variable in item:\n                     if variable != 1:\n                         powers[variable] += 1\nif sum(powers.values()) >= min_degree:\n                     monomials_list_comm.append(Mul(*item))\n             yield from set(monomials_list_comm)\n         else:\n                 for variable in item:\n                     if variable != 1:\n                         powers[variable] += 1\nif sum(powers.values()) >= min_degree:\n                     monomials_list_non_comm.append(Mul(*item))\n             yield from set(monomials_list_non_comm)\n     else:\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for differences in whitespace and layout. The structure and content of the code are the same.\"}"
}