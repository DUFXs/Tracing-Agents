{
    "instance_id": "scikit-learn__scikit-learn-13124",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "reproduce_error.py": "new file mode 100644\nindex 000000000..de9ebf6ec\nimport numpy as np\nfrom sklearn.model_selection import StratifiedKFold\n\nRANDOM_SEED = 1\n\nsamples_per_class = 10\nX = np.linspace(0, samples_per_class*2-1, samples_per_class * 2)\ny = np.concatenate((np.ones(samples_per_class), np.zeros(samples_per_class)), axis=0)\n\nprint(X, '\\n', y, '\\n')\n\nprint('\\nshuffle = False\\n')\n\nk_fold = StratifiedKFold(n_splits=10, shuffle=False, random_state=RANDOM_SEED)\nresult = 0\nfor fold_n, (train_idx, test_idx) in enumerate(k_fold.split(X, y)):\nprint(train_idx, '\\n', test_idx)\n\nprint('\\nshuffle = True, Random seed =', RANDOM_SEED, '\\n')\n\nk_fold = StratifiedKFold(n_splits=10, shuffle=True, random_state=RANDOM_SEED)\nresult = 0\nfor fold_n, (train_idx, test_idx) in enumerate(k_fold.split(X, y)):\nprint(train_idx, '\\n', test_idx)\n\nRANDOM_SEED += 1\nprint('\\nshuffle = True, Random seed =', RANDOM_SEED, '\\n')\n\nk_fold = StratifiedKFold(n_splits=10, shuffle=True, random_state=RANDOM_SEED)\nresult = 0\nfor fold_n, (train_idx, test_idx) in enumerate(k_fold.split(X, y)):\nprint(train_idx, '\\n', test_idx)\n\\ No newline at end of file\n",
        "sklearn/model_selection/_split.py": "index 24394f869..524f7537b 100644\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\nrng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\n                            \" be less than n_splits=%d.\"\n                            % (min_groups, self.n_splits)), Warning)\n \n# Initialize test_folds array\n         test_folds = np.zeros(n_samples, dtype=np.int)\n\n# For each class, get indices and assign folds\nfor cls in unique_y:\ncls_mask = y == cls\ncls_indices = np.where(cls_mask)[0]\nn_cls_samples = len(cls_indices)\n\n# Shuffle indices if requested\nif self.shuffle:\nrng.shuffle(cls_indices)\n\n# Assign folds by taking n_splits slices\nfold_sizes = np.full(self.n_splits, n_cls_samples // self.n_splits, dtype=int)\nfold_sizes[:n_cls_samples % self.n_splits] += 1\ncurrent = 0\nfor fold_idx, fold_size in enumerate(fold_sizes):\nstart, stop = current, current + fold_size\ntest_folds[cls_indices[start:stop]] = fold_idx\ncurrent = stop\n \n         return test_folds\n \n"
    },
    "ground_truth_patch": {
        "sklearn/model_selection/_split.py": "             ``n_splits`` default value will change from 3 to 5 in v0.22.\n \n     shuffle : boolean, optional\nWhether to shuffle each class's samples before splitting into batches.\n \n     random_state : int, RandomState instance or None, optional, default=None\n         If int, random_state is the seed used by the random number generator;\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\nrng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they serve completely different purposes and utilize different structures. The first sample contains a comprehensive implementation using `StratifiedKFold` and handles data splitting with numerous print statements, while the second sample appears to be a piece of documentation or a part of a definition without actual functional code related to data splitting. They do not share syntactic similarity or functional equivalence.\"}"
}