{
    "instance_id": "pydata__xarray-4094",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "test_to_unstacked_single_dim.py": "new file mode 100644\nindex 00000000..88e9a3e3\n#!/usr/bin/env python3\n\nimport sys\nimport xarray as xr\nimport numpy as np\n\nprint(\"Starting test_to_unstacked_single_dim script...\")\n\ntry:\nprint(\"Creating single-dim DataArrays and combining into a Dataset...\")\narr = xr.DataArray(\nnp.arange(3),\ncoords=[(\"x\", [0, 1, 2])],\n)\ndata = xr.Dataset({\"a\": arr, \"b\": arr})\n\nprint(\"Stacking dataset into a single dimension 'y' with sample_dims=['x']...\")\nstacked = data.to_stacked_array(\"y\", sample_dims=[\"x\"])\n\nprint(\"Attempting to unstack back into a Dataset with stacked.to_unstacked_dataset('y')...\")\nunstacked = stacked.to_unstacked_dataset(\"y\")\n\n# We want the final result to be identical to the original \"data\"\nprint(\"Checking if unstacked is identical to original dataset...\")\nif unstacked.identical(data):\nprint(\"PASS: Unstacked dataset is identical.\")\nsys.exit(0)\nelse:\nprint(\"FAIL: Unstacked dataset is NOT identical.\")\nprint(\"Original:\", data)\nprint(\"Unstacked:\", unstacked)\nsys.exit(1)\n\nexcept Exception as e:\nprint(\"FAIL: Exception encountered.\", e)\nsys.exit(2)\n",
        "xarray/core/dataarray.py": "index b0df8749..268a8715 100644\n         return self._from_temp_dataset(ds)\n \n     def to_unstacked_dataset(self, dim, level=0):\n         \"\"\"\nUnstack DataArray expanding to Dataset along a given level of a stacked coordinate.\n\nFor single-dimension variables, we:\n- index out the multiindex level with drop=True so no leftover coordinate remains\n- merge slices with compat='override' to avoid MergeError conflicts\n\n\"\"\"\nimport pandas as pd\nimport xarray\n\n         idx = self.indexes[dim]\n         if not isinstance(idx, pd.MultiIndex):\n             raise ValueError(f\"'{dim}' is not a stacked coordinate\")\n\n         level_number = idx._get_level_number(level)\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n\n# Collect sub-arrays (each named after its level value) and drop the multiindex dimension\ndata_arrays = []\n         for k in variables:\narr = self.sel({variable_dim: k}, drop=True).squeeze(drop=True)\narr.name = k\ndata_arrays.append(arr)\n\nreturn xarray.merge(data_arrays, compat='override')\n\n\n\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n"
    },
    "ground_truth_patch": {
        "xarray/core/dataarray.py": "         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\ndata_dict[k] = self.sel({variable_dim: k}, drop=True).squeeze(drop=True)\n \n         # unstacked dataset\n         return Dataset(data_dict)\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they refer to different functionality within the same module. The first sample is focused on creating DataArrays and then converting a stacked dataset back into an unstacked dataset, while the second sample is about retrieving variables from a DataArray and returning a new Dataset. The structures, purposes, and code implementations in these two samples differ significantly.\"}"
}