{
    "instance_id": "django__django-14787",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/utils/decorators.py": "index 5c9a5d01c7..bed7deab5d 100644\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n# Create the bound method and preserve its attributes\n         bound_method = partial(method.__get__(self, type(self)))\n# Update the bound_method with attributes from the original method\nupdate_wrapper(bound_method, method)\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..fad2c3a5b3\nfrom functools import wraps\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ndef log_decorator(func):\n@wraps(func)\ndef inner(*args, **kwargs):\ntry:\nresult = func(*args, **kwargs)\nexcept Exception as e:\nresult = str(e)\nfinally:\nlogger.debug(f\"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}\")\nreturn result\nreturn inner\n\nfrom django.utils.decorators import method_decorator\n\nclass Test:\n@method_decorator(log_decorator)\ndef hello_world(self):\nreturn \"hello\"\n\nif __name__ == \"__main__\":\nTest().hello_world()\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/utils/decorators.py": "         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\nbound_method = wraps(method)(partial(method.__get__(self, type(self))))\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarity with some modifications. Specifically, the first sample uses 'partial(method.__get__(self, type(self)))' while the second sample employs 'wraps(method)(partial(method.__get__(self, type(self))))', indicating that the first method is wrapped differently by the second sample. Apart from that, both have the same structure and logic, indicating changes in implementation but retaining a similar form.\"}"
}