{
    "instance_id": "django__django-13112",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/core/checks/model_checks.py": "index 15d9b7fd86..f7547bbbd0 100644\n         obj is a callback defined locally in Apps.lazy_model_operation() and\n         annotated there with a `func` attribute so as to imitate a partial.\n         \"\"\"\nimport types\n         operation, args, keywords = obj, [], {}\n         while hasattr(operation, 'func'):\n             args.extend(getattr(operation, 'args', []))\n         return operation, args, keywords\n \n     def app_model_error(model_key):\n\"\"\"\nReturn None if both the app and the model exist (case-insensitive).\nOtherwise return an error string.\n\"\"\"\n# 1) Case-insensitive lookup for the app label.\nfound_app_config = next(\n(ac for ac in apps.get_app_configs() if ac.label.lower() == model_key[0].lower()),\nNone\n)\nif found_app_config is None:\n# The app is not installed at all.\nreturn \"app '%s' isn't installed\" % model_key[0]\n\n# 2) Case-insensitive lookup for the model name.\ndesired_model_lower = model_key[1].lower()\nfor m in found_app_config.get_models():\nif m._meta.model_name == desired_model_lower:\n# The model is found; no error to report.\nreturn None\n\n# The app is installed, but the model wasn't found in it.\nreturn \"app '%s' doesn't provide model '%s'\" % model_key\n\n# Next, define the three error-building functions. Each returns None if\n# there's actually no error.\nfrom django.core.checks import Error\n \n     def field_error(model_key, func, args, keywords):\nmodel_err = app_model_error(model_key)\nif model_err is None:\nreturn None\n         error_msg = (\n             \"The field %(field)s was declared with a lazy reference \"\n             \"to '%(model)s', but %(model_error)s.\"\n         params = {\n             'model': '.'.join(model_key),\n             'field': keywords['field'],\n'model_error': model_err,\n         }\n         return Error(error_msg % params, obj=keywords['field'], id='fields.E307')\n \n     def signal_connect_error(model_key, func, args, keywords):\nimport types\nmodel_err = app_model_error(model_key)\nif model_err is None:\nreturn None\n         error_msg = (\n             \"%(receiver)s was connected to the '%(signal)s' signal with a \"\n             \"lazy reference to the sender '%(model)s', but %(model_error)s.\"\n         )\n         receiver = args[0]\n         # The receiver is either a function or an instance of class\n# defining a __call__ method.\n         if isinstance(receiver, types.FunctionType):\n             description = \"The function '%s'\" % receiver.__name__\n         elif isinstance(receiver, types.MethodType):\n             'model': '.'.join(model_key),\n             'receiver': description,\n             'signal': signal_name,\n'model_error': model_err,\n         }\n         return Error(error_msg % params, obj=receiver.__module__, id='signals.E001')\n \n     def default_error(model_key, func, args, keywords):\nmodel_err = app_model_error(model_key)\nif model_err is None:\nreturn None\n         error_msg = \"%(op)s contains a lazy reference to %(model)s, but %(model_error)s.\"\n         params = {\n             'op': func,\n             'model': '.'.join(model_key),\n'model_error': model_err,\n         }\n         return Error(error_msg % params, obj=func, id='models.E022')\n \n     known_lazy = {\n         ('django.db.models.fields.related', 'resolve_related_class'): field_error,\n         ('django.db.models.fields.related', 'set_managed'): None,\n     )), key=lambda error: error.msg)\n \n \n\n\n @register(Tags.models)\n def check_lazy_references(app_configs=None, **kwargs):\n     return _check_lazy_references(apps)\n",
        "django/db/models/fields/related.py": "index c2aea9c730..55329410ac 100644\n \n def resolve_relation(scope_model, relation):\n     \"\"\"\nTransform relation into a string \"AppLabel.ModelName\" or a model class,\nrelative to scope_model. Skip any real model lookups until after apps load.\nThis ensures we don't trigger AppRegistryNotReady.\n \n     The relation argument can be:\n* \"self\" (RECURSIVE_RELATIONSHIP_CONSTANT), returning scope_model\n* A bare model name, in which case scope_model._meta.app_label is prepended\n* An \"app_label.ModelName\" string\n* A model class, returned unchanged\n\nWe'll do minimal case-insensitive fixes on the string:\n1) Fix app label by matching installed apps.\n2) Capitalize() the model portion to match typical class naming.\n\nExample: \"dj_reglogin.category\" => \"DJ_RegLogin.Category\"\n     \"\"\"\nfrom django.apps import apps\nRECURSIVE_RELATIONSHIP_CONSTANT = 'self'\n\n     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\nreturn scope_model\n \n     if isinstance(relation, str):\n# Check if it's a bare model name\nif '.' not in relation:\n# Prepend the current scope's app_label\nreturn f\"{scope_model._meta.app_label}.{relation.capitalize()}\"\n\napp_label, model_name = relation.split('.', 1)\n# Case-insensitive app label fix\nfound_app_config = next(\n(ac for ac in apps.get_app_configs() if ac.label.lower() == app_label.lower()),\nNone\n)\nif found_app_config is not None:\n# Return the fully qualified string with fixed app label,\n# plus a naive capitalize() on the model name\nreturn f\"{found_app_config.label}.{model_name.capitalize()}\"\n\n# If we didn't find an app match, just return relation as is\n# (will fail later if truly missing).\nreturn relation\n \n     return relation\n \n \n\n\n def lazy_related_operation(function, model, *related_models, **kwargs):\n     \"\"\"\n     Schedule `function` to be called once `model` and all `related_models`\n         return errors\n \n     def _check_relation_model_exists(self):\nfrom django.apps import apps\nfrom django.core import checks\n         rel_is_string = isinstance(self.remote_field.model, str)\n\n# If it's a string, try a case-insensitive lookup similar to _check_lazy_references().\nif rel_is_string:\nmodel_str = self.remote_field.model\n# Handle bare model name \"Category\"\nif '.' not in model_str:\n# Prepend this field's own app label\napp_label = self.model._meta.app_label\nobject_name = model_str\nelse:\napp_label, object_name = model_str.split('.', 1)\n\n# Attempt case-insensitive app lookup\nfound_app_config = next(\n(ac for ac in apps.get_app_configs() if ac.label.lower() == app_label.lower()),\nNone\n)\nif found_app_config is not None:\n# Attempt case-insensitive model lookup\nlower_obj = object_name.lower()\nfor m in found_app_config.get_models():\nif m._meta.model_name == lower_obj:\n# Found a matching model class\n# Check if it's abstract\nif m._meta.abstract:\nreturn [\nchecks.Error(\n\"Field defines a relation with model '%s', which is abstract.\" % model_str,\nobj=self,\nid='fields.E300',\n)\n]\n# Otherwise it is installed and valid\nreturn []\n# If not found, fall through and raise E300\nreturn [\nchecks.Error(\n\"Field defines a relation with model '%s', which is either not installed, or is abstract.\"\n% model_str,\nobj=self,\nid='fields.E300',\n)\n]\n\n# Otherwise, the remote_field.model should be an actual model class.\nrel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\nif rel_is_missing and not self.remote_field.model._meta.swapped:\n             return [\n                 checks.Error(\n\"Field defines a relation with model '%s', which is either not installed, or is abstract.\"\n% self.remote_field.model._meta.object_name,\n                     obj=self,\n                     id='fields.E300',\n                 )\n             ]\n         return []\n\n \n     def _check_referencing_to_swapped_model(self):\n         if (self.remote_field.model not in self.opts.apps.get_models() and\n",
        "test_mixed_case_app.py": "new file mode 100644\nindex 0000000000..86fda9b039\n#!/usr/bin/env python3\nimport os\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\n\ndef main():\nprint(\"Step 1: Creating temp directory for test project...\")\nwith tempfile.TemporaryDirectory() as tmpdir:\nos.chdir(tmpdir)\nprint(f\"Working directory is now: {tmpdir}\")\n\nprint(\"Step 2: Initializing Django project...\")\nsubprocess.check_call(['django-admin', 'startproject', 'mysite'])\n\nproject_path = os.path.join(tmpdir, 'mysite')\nos.chdir(project_path)\n\n# Modify settings.py to add DJ_RegLogin to INSTALLED_APPS\nsettings_path = os.path.join(project_path, 'mysite', 'settings.py')\nwith open(settings_path, 'r', encoding='utf-8') as f:\nsettings_lines = f.readlines()\nnew_settings_lines = []\nfor line in settings_lines:\nnew_settings_lines.append(line)\nif 'INSTALLED_APPS = [' in line:\nnew_settings_lines.append(\"    'DJ_RegLogin',\\n\")\nwith open(settings_path, 'w', encoding='utf-8') as f:\nf.writelines(new_settings_lines)\n\nprint(\"Step 3: Creating the DJ_RegLogin app folder with uppercase name...\")\napp_dir = os.path.join(project_path, 'DJ_RegLogin')\nos.mkdir(app_dir)\n\nprint(\"Step 4: Creating apps.py with name='DJ_RegLogin' ...\")\nwith open(os.path.join(app_dir, 'apps.py'), 'w', encoding='utf-8') as f:\nf.write(textwrap.dedent('''\nfrom django.apps import AppConfig\n\nclass DJ_RegLoginConfig(AppConfig):\nname = 'DJ_RegLogin'\n''').strip() + '\\n')\n\nprint(\"Step 5: Creating models.py referencing a lowercase cluster 'dj_reglogin.category' forcibly...\")\nwith open(os.path.join(app_dir, 'models.py'), 'w', encoding='utf-8') as f:\nf.write(textwrap.dedent('''\nfrom django.db import models\n\nclass Category(models.Model):\ntitle = models.CharField(max_length=100)\n\nclass Content(models.Model):\ntitle = models.CharField(max_length=100)\n# Force a scenario referencing the uppercase app in a manner that\n# triggers the 'dj_reglogin.category' mismatch:\ncategory = models.ForeignKey(\n\"dj_reglogin.Category\",\non_delete=models.CASCADE\n)\n''').strip() + '\\n')\n\n# Put an __init__.py in app folder\nopen(os.path.join(app_dir, '__init__.py'), 'w').close()\n\n# Register the app config\nwith open(os.path.join(app_dir, '__init__.py'), 'a', encoding='utf-8') as f:\nf.write(\"default_app_config = 'DJ_RegLogin.apps.DJ_RegLoginConfig'\\n\")\n\nprint(\"Step 6: Running 'python manage.py migrate' to see if the error appears.\")\nmanage_py = os.path.join(project_path, 'manage.py')\ncmd = [sys.executable, manage_py, 'migrate', '--verbosity', '2']\ntry:\nsubprocess.check_call(cmd)\nprint(\"Migration succeeded. The bug is presumably fixed.\")\nsys.exit(0)\nexcept subprocess.CalledProcessError:\nprint(\"Migration failed. The bug is present.\")\nsys.exit(1)\n\nif __name__ == '__main__':\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/models/fields/related.py": "         if self.remote_field.parent_link:\n             kwargs['parent_link'] = self.remote_field.parent_link\n         if isinstance(self.remote_field.model, str):\nif '.' in self.remote_field.model:\napp_label, model_name = self.remote_field.model.split('.')\nkwargs['to'] = '%s.%s' % (app_label, model_name.lower())\nelse:\nkwargs['to'] = self.remote_field.model.lower()\n         else:\n             kwargs['to'] = self.remote_field.model._meta.label_lower\n         # If swappable is True, then see if we're actually pointing to the target\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they address different functionalities in the Django framework. Code sample 1 consists of various error handling functions related to model lookup and lazy references, while code sample 2 focuses on a conditional model relation resolution and does not share syntactic or functional equivalence with sample 1. Their purposes and implementations differ significantly.\"}"
}