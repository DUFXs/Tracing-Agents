{
    "instance_id": "astropy__astropy-13579",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "astropy/wcs/wcsapi/wrappers/sliced_wcs.py": "index d7605b078c..46765dc610 100644\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n# Use the actual value from the dropped dimension\nworld_arrays_new.append(self.dropped_world_dimensions['value'][sum(1 for x in range(iworld) if x not in self._world_keep)])\n \n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..a22ca4c7e3\nimport numpy as np\nimport astropy.wcs\nfrom astropy.coordinates import SkyCoord\nimport astropy.units as u\n\n# Create the test WCS\nnx = 100\nny = 25\nnz = 2\nwcs_header = {\n'WCSAXES': 3,\n'CRPIX1': (nx + 1)/2,\n'CRPIX2': (ny + 1)/2,\n'CRPIX3': 1.0,\n'PC1_1': 0.0,\n'PC1_2': -1.0,\n'PC1_3': 0.0,\n'PC2_1': 1.0,\n'PC2_2': 0.0,\n'PC2_3': -1.0,\n'CDELT1': 5,\n'CDELT2': 5,\n'CDELT3': 0.055,\n'CUNIT1': 'arcsec',\n'CUNIT2': 'arcsec',\n'CUNIT3': 'Angstrom',\n'CTYPE1': 'HPLN-TAN',\n'CTYPE2': 'HPLT-TAN',\n'CTYPE3': 'WAVE',\n'CRVAL1': 0.0,\n'CRVAL2': 0.0,\n'CRVAL3': 1.05,\n}\n\nfits_wcs = astropy.wcs.WCS(header=wcs_header)\n\n# Test unsliced WCS\npt = SkyCoord(Tx=0*u.arcsec, Ty=0*u.arcsec, frame=astropy.wcs.utils.wcs_to_celestial_frame(fits_wcs))\nprint(\"\\nUnsliced WCS world_to_pixel:\")\nprint(fits_wcs.world_to_pixel(pt, 1.05*u.angstrom))\n\n# Test sliced WCS\nll_sliced_wcs = astropy.wcs.wcsapi.SlicedLowLevelWCS(fits_wcs, 0)\nhl_sliced_wcs = astropy.wcs.wcsapi.HighLevelWCSWrapper(ll_sliced_wcs)\nprint(\"\\nSliced WCS world_to_pixel:\")\nprint(hl_sliced_wcs.world_to_pixel(pt))\n\n# Test pixel_to_world operations\npx, py, pz = fits_wcs.world_to_pixel(pt, 1.05*u.Angstrom)\nprint(\"\\nUnsliced WCS pixel_to_world:\")\nprint(fits_wcs.pixel_to_world(px, py, pz))\nprint(\"\\nSliced WCS pixel_to_world:\")\nprint(hl_sliced_wcs.pixel_to_world(px, py))\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "astropy/wcs/wcsapi/wrappers/sliced_wcs.py": "         return world_arrays\n \n     def world_to_pixel_values(self, *world_arrays):\nsliced_out_world_coords = self._pixel_to_world_values_all(*[0]*len(self._pixel_keep))\n\n         world_arrays = tuple(map(np.asanyarray, world_arrays))\n         world_arrays_new = []\n         iworld_curr = -1\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\nworld_arrays_new.append(sliced_out_world_coords[iworld])\n \n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share significant structural similarities, but they contain added and modified statements. For example, sample 1 includes the actual value from the dropped dimension which is not present in sample 2, indicating that while they achieve similar functionalities, they are not identical due to the additional statements and context in the logic.\"}"
}