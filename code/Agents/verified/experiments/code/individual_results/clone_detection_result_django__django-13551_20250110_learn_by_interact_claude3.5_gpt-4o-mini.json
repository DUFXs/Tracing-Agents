{
    "instance_id": "django__django-13551",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "django/contrib/auth/tokens.py": "index 93e2d71af2..d45225cb59 100644\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n            a password reset.\n3. The email field (if the user has one) will invalidate the token if\nchanged.\n         Failing those things, settings.PASSWORD_RESET_TIMEOUT eventually\n         invalidates the token.\n \n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\n# Get the user's email field value if it exists\nemail_field_name = user.get_email_field_name() if hasattr(user, 'get_email_field_name') else 'email'\nemail = getattr(user, email_field_name, '') or ''\nreturn str(user.pk) + user.password + str(login_timestamp) + str(timestamp) + email\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\n \n \n default_token_generator = PasswordResetTokenGenerator()\n\n",
        "reproduce_issue.py": "new file mode 100644\nindex 0000000000..af7e366d19\nimport os\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n\nfrom django.conf import settings\nsettings.configure(\nSECRET_KEY='test-key-not-for-production',\nPASSWORD_HASHERS=['django.contrib.auth.hashers.SHA1PasswordHasher'],\nINSTALLED_APPS=[\n'django.contrib.auth',\n'django.contrib.contenttypes',\n],\nUSE_TZ=False,\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n}\n)\n\nimport django\ndjango.setup()\n\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.tokens import default_token_generator\n\n# Create a test user\nUser = get_user_model()\nuser = User()\nuser.pk = 1\nuser.password = 'test_password'\nuser.email = 'foo@example.com'\n\n# Generate password reset token\ntoken = default_token_generator.make_token(user)\nprint(f\"Generated token: {token}\")\nprint(f\"Token valid before email change: {default_token_generator.check_token(user, token)}\")\n\n# Change email\nuser.email = 'bar@example.com'\nprint(f\"Token valid after email change: {default_token_generator.check_token(user, token)}\")\n\n"
    },
    "ground_truth_patch": {
        "django/contrib/auth/tokens.py": " \n     def _make_hash_value(self, user, timestamp):\n         \"\"\"\nHash the user's primary key, email (if available), and some user state\nthat's sure to change after a password reset to produce a token that is\ninvalidated when it's used:\n         1. The password field will change upon a password reset (even if the\n            same password is chosen, due to password salting).\n         2. The last_login field will usually be updated very shortly after\n         # Truncate microseconds so that tokens are consistent even if the\n         # database doesn't support microseconds.\n         login_timestamp = '' if user.last_login is None else user.last_login.replace(microsecond=0, tzinfo=None)\nemail_field = user.get_email_field_name()\nemail = getattr(user, email_field, '') or ''\nreturn f'{user.pk}{user.password}{login_timestamp}{timestamp}{email}'\n \n     def _num_seconds(self, dt):\n         return int((dt - datetime(2001, 1, 1)).total_seconds())\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-2\", \"reasoning\": \"These code samples are type-2 clones because they are nearly identical in structure and logic but differ in identifier names and whitespace. For example, in the first sample, the variable 'email_field_name' is used, while in the second sample, it is simply 'email_field'. Additionally, there are minor differences in the string formatting used in the return statement.\"}"
}