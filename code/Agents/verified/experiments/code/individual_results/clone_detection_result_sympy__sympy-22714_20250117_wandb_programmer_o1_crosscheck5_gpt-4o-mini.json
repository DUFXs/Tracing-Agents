{
    "instance_id": "sympy__sympy-22714",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "sympy/geometry/point.py": "index 73c20334d0..3a608c7f3a 100644\n     is_Point = True\n \n     def __new__(cls, *args, **kwargs):\nevaluate = kwargs.get(\"evaluate\", global_parameters.evaluate)\non_morph = kwargs.get(\"on_morph\", \"ignore\")\n\n         # unpack into coords\n         coords = args[0] if len(args) == 1 else args\n\n         # check args and handle quickly handle Point instances\n         if isinstance(coords, Point):\n             # even if we're mutating the dimension of a point, we\n             # don't reevaluate its coordinates\n             evaluate = False\nif len(coords) == kwargs.get(\"dim\", len(coords)):\n                 return coords\n\n         if not is_sequence(coords):\nraise TypeError(\"Expecting sequence of coordinates, not '{}'\".format(func_name(coords)))\n# A point where only dim is specified is initialized to zeros.\nif len(coords) == 0 and kwargs.get(\"dim\", None):\ncoords = (S.Zero,) * kwargs.get(\"dim\")\n\n         coords = Tuple(*coords)\ndim = kwargs.get(\"dim\", len(coords))\n\n         if len(coords) < 2:\nraise ValueError(\"Point requires 2 or more coordinates or keyword 'dim' > 1.\")\n         if len(coords) != dim:\nmessage = \"Dimension of {} needs to be changed from {} to {}.\".format(coords, len(coords), dim)\nif on_morph == \"ignore\":\n                 pass\n             elif on_morph == \"error\":\n                 raise ValueError(message)\nelif on_morph == \"warn\":\n                 warnings.warn(message)\n             else:\nraise ValueError(\"on_morph value should be 'error','warn' or 'ignore'.\")\n\n         if any(coords[dim:]):\nraise ValueError(\"Nonzero coordinates cannot be removed.\")\n\n# Fix: only forbid definitely non-real (i.e. extended_real == False).\nif any(a.is_number and a.is_extended_real == False for a in coords):\nraise ValueError(\"Imaginary coordinates are not permitted.\")\n\n         if not all(isinstance(a, Expr) for a in coords):\nraise TypeError(\"Coordinates must be valid SymPy expressions.\")\n\n         # pad with zeros appropriately\n         coords = coords[:dim] + (S.Zero,)*(dim - len(coords))\n\n         # Turn any Floats into rationals and simplify\n         # any expressions before we instantiate\n         if evaluate:\n             coords = coords.xreplace({\n                 f: simplify(nsimplify(f, rational=True))\nfor f in coords.atoms(Float)\n})\n\n         # return 2D or 3D instances\n         if len(coords) == 2:\nkwargs[\"_nocheck\"] = True\n             return Point2D(*coords, **kwargs)\n         elif len(coords) == 3:\nkwargs[\"_nocheck\"] = True\n             return Point3D(*coords, **kwargs)\n\n         # the general Point\n         return GeometryEntity.__new__(cls, *coords)\n\n\n \n     def __abs__(self):\n         \"\"\"Returns the distance between this point and the origin.\"\"\"\n",
        "test_evaluate_false_bug.py": "new file mode 100644\nindex 0000000000..7dc40efff5\nimport sys\nimport sympy as sp\n\ndef main():\nprint(\"TEST: Reproducing bug with global evaluate(False)...\")\ntry:\nwith sp.evaluate(False):\n# This should not raise ValueError\nresult = sp.S(\"Point2D(Integer(1), Integer(2))\")\nprint(\"TEST: Constructed result =\", result)\nprint(\"SUCCESS: No error was triggered, test passes!\")\nsys.exit(0)\nexcept Exception as e:\nprint(\"FAILURE: Unexpected error triggered:\", e)\n# We want to fail with non-zero exit to confirm the bug\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "sympy/geometry/point.py": "                         'warn' or 'ignore'.'''))\n         if any(coords[dim:]):\n             raise ValueError('Nonzero coordinates cannot be removed.')\nif any(a.is_number and im(a).is_zero is False for a in coords):\n             raise ValueError('Imaginary coordinates are not permitted.')\n         if not all(isinstance(a, Expr) for a in coords):\n             raise TypeError('Coordinates must be valid SymPy expressions.')\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share syntactical similarities but have modifications in some statements, particularly in the handling of coordinates and error checking. The context and structure are similar, but some conditions and messages are altered.\"}"
}