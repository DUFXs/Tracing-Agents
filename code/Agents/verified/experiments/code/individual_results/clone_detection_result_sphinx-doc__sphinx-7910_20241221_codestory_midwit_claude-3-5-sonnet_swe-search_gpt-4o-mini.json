{
    "instance_id": "sphinx-doc__sphinx-7910",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "reproduce_error.py": "new file mode 100644\nindex 000000000..5ec195770\nfrom functools import wraps\nfrom sphinx.ext.napoleon import Config, GoogleDocstring\n\ndef my_decorator(func):\n@wraps(func)\ndef wrapper(*args, **kwargs):\nreturn func(*args, **kwargs)\nreturn wrapper\n\n# Test case 1: Simple decorated __init__\nclass DistributedTrainerReplicated:\n@my_decorator\ndef __init__(self, param1):\n\"\"\"Initialize the trainer.\n\nArgs:\nparam1: A test parameter\n\"\"\"\nself.param1 = param1\n\n# Test case 2: Nested class with decorated __init__\nclass Outer:\nclass Inner:\n@my_decorator\ndef __init__(self, param1):\n\"\"\"Initialize inner class.\n\nArgs:\nparam1: A test parameter\n\"\"\"\nself.param1 = param1\n\n# Test case 3: Multiple decorators\ndef another_decorator(func):\n@wraps(func)\ndef wrapper(*args, **kwargs):\nreturn func(*args, **kwargs)\nreturn wrapper\n\nclass MultiDecorated:\n@my_decorator\n@another_decorator\ndef __init__(self, param1):\n\"\"\"Initialize with multiple decorators.\n\nArgs:\nparam1: A test parameter\n\"\"\"\nself.param1 = param1\n\n# Create a mock config\nconfig = Config(napoleon_include_init_with_doc=True)\n\ndef process_class(cls, name):\nprint(f\"\\nTesting {name}:\")\nobj = cls.__init__\nwhat = 'method'\nobj_doc = obj.__doc__\nprint(\"Original docstring:\", obj_doc)\ndocstring = GoogleDocstring(obj_doc, config, app=None, what=what, name='__init__',\nobj=obj, options=None)\nprint(\"Processed docstring:\", str(docstring))\n\n# Test all cases\nprocess_class(DistributedTrainerReplicated, \"Simple decorated class\")\nprocess_class(Outer.Inner, \"Nested class\")\nprocess_class(MultiDecorated, \"Multiple decorated class\")\n\\ No newline at end of file\n",
        "sphinx/ext/napoleon/__init__.py": "index 10b1ff3a3..711978af4 100644\n             cls_path, _, _ = qualname.rpartition('.')\n             if cls_path:\n                 try:\nimport importlib\nimport functools\n\nmod = importlib.import_module(obj.__module__)\nmod_path = cls_path.split('.')\ncls = functools.reduce(getattr, mod_path, mod) if '.' in cls_path else getattr(mod, cls_path)\n                 except Exception:\n# Fallback to __globals__ for backward compatibility\ntry:\ncls = obj.__globals__[cls_path]\nexcept Exception:\ncls_is_owner = False\n                 else:\n                     cls_is_owner = (cls and hasattr(cls, name) and  # type: ignore\n                                     name in cls.__dict__)\n"
    },
    "ground_truth_patch": {
        "sphinx/ext/napoleon/__init__.py": " from sphinx import __display_version__ as __version__\n from sphinx.application import Sphinx\n from sphinx.ext.napoleon.docstring import GoogleDocstring, NumpyDocstring\nfrom sphinx.util import inspect\n \n \n class Config:\n                         mod_path = cls_path.split('.')\n                         cls = functools.reduce(getattr, mod_path, mod)\n                     else:\ncls = inspect.unwrap(obj).__globals__[cls_path]\n                 except Exception:\n                     cls_is_owner = False\n                 else:\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they contain different functionality and structure. The first code sample has a full implementation with decorated classes and a testing mechanism, while the second code sample only shows part of an import statement and some logic related to class handling. The contexts and purposes of the code are dissimilar.\"}"
}