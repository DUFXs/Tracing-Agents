{
    "instance_id": "pytest-dev__pytest-7571",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "repro_test.py": "new file mode 100644\nindex 000000000..6a36b8897\nimport pytest\n\ndef test_foo(caplog):\ncaplog.set_level(42)\nprint(\"Set level to 42 in test_foo.\")\n\ndef test_bar(caplog):\n# This should be restored to 0 or a default level right after test_foo finishes.\nprint(\"Handler level in test_bar is:\", caplog.handler.level)\nif caplog.handler.level == 42:\nprint(\"BUG: The level was not restored!\")\nassert False, \"caplog.handler.level is still 42.\"\nelse:\nprint(\"OK: Handler level was restored to\", caplog.handler.level)\n",
        "src/_pytest/logging.py": "index 11031f2f2..328b869f1 100644\n         self._item = item\n         # dict of log name -> log level\n         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n# store original handler level\nself._initial_handler_level = self.handler.level\n \n     def _finalize(self) -> None:\n         \"\"\"Finalizes the fixture.\n             logger = logging.getLogger(logger_name)\n             logger.setLevel(level)\n \n# also restore the handler's original level\nself.handler.setLevel(self._initial_handler_level)\n\n     @property\n     def handler(self) -> LogCaptureHandler:\n         \"\"\"\n     @property\n     def messages(self) -> List[str]:\n         \"\"\"Returns a list of format-interpolated log messages.\n\nUnlike 'records', which contains the format string and parameters for interpolation, \nlog messages in this list are all interpolated.\nUnlike 'text', which contains the output from the handler, log messages in this list \nare unadorned with levels, timestamps, etc.\n\n         .. versionadded:: 3.7\n         \"\"\"\n         return [r.getMessage() for r in self.records]\n             self.handler.setLevel(handler_orig_level)\n \n \n\n @pytest.fixture\n def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n     \"\"\"Access and control log capturing.\n",
        "test_caplog_restore.py": "new file mode 100644\nindex 000000000..4678111c1\n#!/usr/bin/env python3\n\nimport sys\nimport subprocess\n\ndef main():\nprint(\"Reproduction script for the caplog fixture level restore issue.\")\n# Create a minimal pytest test file.\ntest_file_content = \"\"\"import pytest\n\ndef test_foo(caplog):\ncaplog.set_level(42)\nprint(\"Set level to 42 in test_foo.\")\n\ndef test_bar(caplog):\n# This should be restored to 0 or a default level right after test_foo finishes.\nprint(\"Handler level in test_bar is:\", caplog.handler.level)\nif caplog.handler.level == 42:\nprint(\"BUG: The level was not restored!\")\nassert False, \"caplog.handler.level is still 42.\"\nelse:\nprint(\"OK: Handler level was restored to\", caplog.handler.level)\n\"\"\"\n\n# Write the test file\nwith open(\"repro_test.py\", \"w\") as f:\nf.write(test_file_content)\n\n# Now run the test\ncmd = [\"pytest\", \"repro_test.py\", \"--disable-warnings\"]\nprint(\"Running:\", \" \".join(cmd))\nresult = subprocess.run(cmd, capture_output=True)\nstdout = result.stdout.decode()\nstderr = result.stderr.decode()\nprint(\"Pytest stdout:\")\nprint(stdout)\nprint(\"Pytest stderr:\")\nprint(stderr)\n\nif result.returncode == 0:\nprint(\"The bug is FIXED. Exiting with code 0.\")\nsys.exit(0)\nelse:\nprint(\"The bug is PRESENT. Exiting with code 1.\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "src/_pytest/logging.py": "         \"\"\"Creates a new funcarg.\"\"\"\n         self._item = item\n         # dict of log name -> log level\nself._initial_handler_level = None  # type: Optional[int]\n         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n \n     def _finalize(self) -> None:\n         This restores the log levels changed by :meth:`set_level`.\n         \"\"\"\n         # restore log levels\nif self._initial_handler_level is not None:\nself.handler.setLevel(self._initial_handler_level)\n         for logger_name, level in self._initial_logger_levels.items():\n             logger = logging.getLogger(logger_name)\n             logger.setLevel(level)\n         # save the original log-level to restore it during teardown\n         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n         logger_obj.setLevel(level)\nself._initial_handler_level = self.handler.level\n         self.handler.setLevel(level)\n \n     @contextmanager\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they contain different logic and functionality. Code sample 1 includes test functions for checking log levels, while code sample 2 deals with setting and restoring handler levels and appears to be part of a logging framework, not a test. The context and purpose of each sample are significantly different.\"}"
}