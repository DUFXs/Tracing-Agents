{
    "instance_id": "django__django-12304",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/enums.py": "index f48143ddaf..960aac694c 100644\n \n class ChoicesMeta(enum.EnumMeta):\n     \"\"\"A metaclass for creating a enum choices.\"\"\"\n     def __new__(metacls, classname, bases, classdict):\n         labels = []\n         for key in classdict._member_names:\n         # that is passed in as \"self\" as the value to use when looking up the\n         # label in the choices.\n         cls.label = property(lambda self: cls._value2label_map_.get(self.value))\n\n# New fix: set do_not_call_in_templates = True at the class level\ncls.do_not_call_in_templates = True\n\n         return enum.unique(cls)\n \n     def __contains__(cls, member):\n         return [value for value, _ in cls.choices]\n \n \n\n class Choices(enum.Enum, metaclass=ChoicesMeta):\n     \"\"\"Class for creating enumerated choices.\"\"\"\n \n         return str(self.value)\n \n \n\n\n class IntegerChoices(int, Choices):\n     \"\"\"Class for creating enumerated integer choices.\"\"\"\n     pass\n",
        "test_enum_templaterender.py": "new file mode 100644\nindex 0000000000..db509356ec\nimport sys\nimport django\nfrom django.conf import settings\n\ndef main():\nif not settings.configured:\nsettings.configure(\nINSTALLED_APPS=[],\nTEMPLATES=[\n{\n\"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n}\n],\nDATABASES={\n\"default\": {\n\"ENGINE\": \"django.db.backends.sqlite3\",\n\"NAME\": \":memory:\",\n}\n},\n)\ndjango.setup()\n\nfrom django.template import Template, Context\nfrom django.db.models import TextChoices\n\nclass YearInSchool(TextChoices):\nFRESHMAN = \"FR\", \"Freshman\"\nSOPHOMORE = \"SO\", \"Sophomore\"\n\ntemplate_string = \"\"\"\n{% if year_in_school == YearInSchool.FRESHMAN %}\nThis Works\n{% else %}\nThis Does Not Work\n{% endif %}\n\nClass value: {{ YearInSchool }}\n\"\"\"\n\nprint(\"==> Creating Template with content:\")\nprint(template_string)\n\nt = Template(template_string)\ncontext_data = {\n\"year_in_school\": YearInSchool.FRESHMAN,\n\"YearInSchool\": YearInSchool\n}\nprint(\"==> Rendering Template with context:\", context_data)\n\ntry:\nrendered = t.render(Context(context_data))\nprint(\"==> Rendered output:\", repr(rendered))\nexcept Exception as e:\nprint(f\"==> Rendering failed with exception: {e}\")\nsys.exit(1)\n\n# Check whether \"This Works\" appears\nif \"This Works\" in rendered:\nprint(\"==> Test passed.\")\nsys.exit(0)\nelse:\nprint(\"==> Test failed.\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/models/enums.py": "         # that is passed in as \"self\" as the value to use when looking up the\n         # label in the choices.\n         cls.label = property(lambda self: cls._value2label_map_.get(self.value))\ncls.do_not_call_in_templates = True\n         return enum.unique(cls)\n \n     def __contains__(cls, member):\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for differences in whitespace and comments. Both samples show similar code segments where the properties for the enum are defined and the do_not_call_in_templates attribute is set on the cls object.\"}"
}