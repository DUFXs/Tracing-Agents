{
    "instance_id": "django__django-12155",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index 238fb3a200..521baaa795 100644\n tests/.coverage\n build/\n tests/report/\n.aider/\n",
        "django/contrib/admindocs/utils.py": "index 4c0e7e2a56..5e5ff228c9 100644\n         return ''\n     # Convert tabs to spaces and split into lines\n     lines = docstring.expandtabs().splitlines()\n# Skip first line when calculating indent to handle docstrings that start on first line\n# For single line docstrings, use indent of 0\nif len(lines) <= 1:\nindent = 0\nelse:\nindent = min((len(line) - len(line.lstrip()) for line in lines[1:] if line.lstrip()), default=0)\n     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n     return \"\\n\".join(trimmed).strip()\n"
    },
    "ground_truth_patch": {
        "django/contrib/admindocs/utils.py": " import re\n from email.errors import HeaderParseError\n from email.parser import HeaderParser\nfrom inspect import cleandoc\n \n from django.urls import reverse\n from django.utils.regex_helper import _lazy_re_compile\n     return mod_name + '.' + view_name\n \n \n def parse_docstring(docstring):\n     \"\"\"\n     Parse out the parts of a docstring.  Return (title, body, metadata).\n     \"\"\"\nif not docstring:\nreturn '', '', {}\ndocstring = cleandoc(docstring)\n     parts = re.split(r'\\n{2,}', docstring)\n     title = parts[0]\n     if len(parts) == 1:\n",
        "django/contrib/admindocs/views.py": " import inspect\n from importlib import import_module\nfrom inspect import cleandoc\n from pathlib import Path\n \n from django.apps import apps\n                     continue\n                 verbose = func.__doc__\n                 verbose = verbose and (\nutils.parse_rst(cleandoc(verbose), 'model', _('model:') + opts.model_name)\n                 )\n                 # Show properties and methods without arguments as fields.\n                 # Otherwise, show as a 'method with arguments'.\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they are syntactically dissimilar and serve different functionalities. The first code sample deals with processing docstrings and modifying their format, while the second code sample involves document parsing and handling imports, which indicates they perform distinct tasks.\"}"
}