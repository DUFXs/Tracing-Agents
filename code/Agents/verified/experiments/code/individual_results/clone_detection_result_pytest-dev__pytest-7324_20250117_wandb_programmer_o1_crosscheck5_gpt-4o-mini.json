{
    "instance_id": "pytest-dev__pytest-7324",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "src/_pytest/mark/expression.py": "index 04c73411a..4cea2f468 100644\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n# We'll rename special keywords here (False/True/None etc.),\n# so Python's debug builds do not see them as normal 'Name' nodes.\nnew_name = rename_ident(ident.value)\nreturn ast.Name(new_name, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \nRENAME_PREFIX = \"pytestIdent__\"\nRESERVED_KEYWORDS = {\"False\", \"True\", \"None\"}\n\ndef rename_ident(name: str) -> str:\n# If the name is one of Python's reserved booleans or None, rename it.\n# This prevents debug-build crashes (since \"False\" etc. can't appear as an identifier).\nif name in RESERVED_KEYWORDS:\nreturn RENAME_PREFIX + name\nreturn name\n\n\n\n\n\n\n\n \n class MatcherAdapter(Mapping[str, bool]):\n     \"\"\"Adapts a matcher function to a locals mapping as required by eval().\"\"\"\n \n__slots__ = (\"matcher\",)\n\n     def __init__(self, matcher: Callable[[str], bool]) -> None:\n         self.matcher = matcher\n \n     def __getitem__(self, key: str) -> bool:\n# If the expression references a renamed key, convert it back\nif key.startswith(RENAME_PREFIX):\nkey = key[len(RENAME_PREFIX):]\n         return self.matcher(key)\n \n     def __iter__(self) -> Iterator[str]:\n         raise NotImplementedError()\n \n \n\n class Expression:\n     \"\"\"A compiled match expression as used by -k and -m.\n \n",
        "test_bug_expression_crash.py": "new file mode 100644\nindex 000000000..3a3ef47e6\n#!/usr/bin/env python3\n\nimport sys\n\ndef main():\nprint(\"[TEST] Checking Expression.compile('False') AST for presence of 'False' as a name.\")\ntry:\nfrom _pytest.mark.expression import Expression\nexcept ImportError as e:\nprint(\"[TEST] Failed to import Expression:\", e)\nsys.exit(1)\n\nexpr = Expression.compile(\"False\")\nnames = expr.code.co_names\nprint(f\"[TEST] co_names = {names}\")\nif \"False\" in names:\nprint(\"[TEST] Found 'False' in co_names => BUG is not fixed!\")\nsys.exit(1)\nelse:\nprint(\"[TEST] 'False' not in co_names => BUG is presumably fixed.\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "src/_pytest/mark/expression.py": "         )\n \n \n# True, False and None are legal match expression identifiers,\n# but illegal as Python identifiers. To fix this, this prefix\n# is added to identifiers in the conversion to Python AST.\nIDENT_PREFIX = \"$\"\n\n\n def expression(s: Scanner) -> ast.Expression:\n     if s.accept(TokenType.EOF):\n         ret = ast.NameConstant(False)  # type: ast.expr\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\nreturn ast.Name(IDENT_PREFIX + ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n \n         self.matcher = matcher\n \n     def __getitem__(self, key: str) -> bool:\nreturn self.matcher(key[len(IDENT_PREFIX) :])\n \n     def __iter__(self) -> Iterator[str]:\n         raise NotImplementedError()\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarities but contain modifications in identifiers and values as well as added comments. For example, the prefixes used in 'return ast.Name(new_name, ast.Load())' and 'return ast.Name(IDENT_PREFIX + ident.value, ast.Load())' are different (RENAME_PREFIX vs. IDENT_PREFIX), indicating there has been a change in implementation while maintaining a similar structure.\"}"
}