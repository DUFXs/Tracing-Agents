{
    "instance_id": "scikit-learn__scikit-learn-13124",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "sklearn/model_selection/_split.py": "index 24394f869..06687a4d9 100644\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\nrng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\n                            \" be less than n_splits=%d.\"\n                            % (min_groups, self.n_splits)), Warning)\n \ntest_folds = np.zeros(n_samples, dtype=np.int)\n\n# If shuffle is True, shuffle indices within each class separately\nclass_indices = []\nfor cls in unique_y:\ncls_idx = np.where(y == cls)[0]\nif self.shuffle:\nrng.shuffle(cls_idx)\nclass_indices.append(cls_idx)\n\n         per_cls_cvs = [\nKFold(self.n_splits, shuffle=False,\nrandom_state=None).split(np.zeros(max(count, self.n_splits)))\n             for count in y_counts]\n \n         for test_fold_indices, per_cls_splits in enumerate(zip(*per_cls_cvs)):\nfor cls_idx, (_, test_split) in zip(class_indices, per_cls_splits):\ncls_test_folds = test_folds[cls_idx]\n                 # the test split can be too big because we used\n                 # KFold(...).split(X[:max(c, n_splits)]) when data is not 100%\n                 # stratifiable for all the classes\n                 test_split = test_split[test_split < len(cls_test_folds)]\n                 cls_test_folds[test_split] = test_fold_indices\ntest_folds[cls_idx] = cls_test_folds\n \n         return test_folds\n \n         params[key] = value\n \n     return '%s(%s)' % (class_name, _pprint(params, offset=len(class_name)))\n\n"
    },
    "ground_truth_patch": {
        "sklearn/model_selection/_split.py": "             ``n_splits`` default value will change from 3 to 5 in v0.22.\n \n     shuffle : boolean, optional\nWhether to shuffle each class's samples before splitting into batches.\n \n     random_state : int, RandomState instance or None, optional, default=None\n         If int, random_state is the seed used by the random number generator;\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\nrng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-4\", \"reasoning\": \"These code samples are syntactically dissimilar but functionally equivalent. While they include the same core logic, they showcase different formatting, introductory comments, and possibly differing levels of detail in their documentation or description.\"}"
}