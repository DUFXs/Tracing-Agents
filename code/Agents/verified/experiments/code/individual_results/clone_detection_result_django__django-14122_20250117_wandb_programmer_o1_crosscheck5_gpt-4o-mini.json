{
    "instance_id": "django__django-14122",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/sql/compiler.py": "index 850734709d..955ec1fa38 100644\n         \"\"\"\n         Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the\n         ORDER BY clause.\n\n         The order_by clause can alter the select clause (for example it\n         can add aliases to clauses that do not yet have one, or it can\n         add totally new select clauses).\n         elif self.query.order_by:\n             ordering = self.query.order_by\n         elif self.query.get_meta().ordering:\n# If the query is aggregating, skip meta ordering.\nif self.query.annotation_select or self.query.group_by is not None:\nordering = []\nelse:\nordering = self.query.get_meta().ordering\n             self._meta_ordering = ordering\n         else:\n             ordering = []\n             asc, desc = ORDER_DIR['ASC']\n         else:\n             asc, desc = ORDER_DIR['DESC']\n\n         order_by = []\n         for field in ordering:\n             if hasattr(field, 'resolve_expression'):\n             if field == '?':  # random\n                 order_by.append((OrderBy(Random()), False))\n                 continue\n\n             col, order = get_order_dir(field, asc)\n             descending = order == 'DESC'\n\n             if col in self.query.annotation_select:\n                 # Reference to expression in SELECT clause\n                 order_by.append((\n                         expr = Cast(expr, expr.output_field)\n                 order_by.append((OrderBy(expr, descending=descending), False))\n                 continue\n\n             if '.' in field:\n                 # This came in through an extra(order_by=...) addition. Pass it\n                 # on verbatim.\n                         descending=descending\n                     ), False))\n                 continue\n\n             if not self.query.extra or col not in self.query.extra:\n                 # 'col' is of the form 'field' or 'field1__field2' or\n                 # '-field1__field2__field', etc.\n                         True))\n         result = []\n         seen = set()\n\n         for expr, is_ref in order_by:\n             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n             if self.query.combinator and self.select:\n             seen.add((without_ordering, params_hash))\n             result.append((resolved, (sql, params, is_ref)))\n         return result\n\n \n     def get_extra_select(self, order_by, select):\n         extra_select = []\n",
        "repro_test_script.py": "new file mode 100644\nindex 0000000000..581d7a98f9\n#!/usr/bin/env python\nimport subprocess\nimport sys\n\nprint(\"Reproduction test script for Meta.ordering GROUP BY bug.\")\ncmd = [\"python\", \"tests/runtests.py\", \"test_bug\"]\nprint(f\"Running command: {cmd}\")\nresult = subprocess.run(cmd)\nprint(f\"Test return code: {result.returncode}\")\nsys.exit(result.returncode)\n",
        "tests/test_bug/__init__.py": "new file mode 100644\nindex 0000000000..659fedd0cb\n# Make test_bug a test app submodule.\n\\ No newline at end of file\n",
        "tests/test_bug/models.py": "new file mode 100644\nindex 0000000000..81d103183d\nfrom django.db import models\n\nclass TestModel(models.Model):\nname = models.CharField(max_length=50)\nval = models.IntegerField()\n\nclass Meta:\nordering = ['name']\napp_label = 'test_bug'\n",
        "tests/test_bug/test_ordering_groupby.py": "new file mode 100644\nindex 0000000000..faf54fb864\nfrom django.test import TestCase\nfrom django.db.models import Sum\nfrom .models import TestModel\n\nclass TestDefaultOrderingGroupBy(TestCase):\n@classmethod\ndef setUpTestData(cls):\n# Insert 2 rows that share the same val, but different name.\n# If the query incorrectly groups on 'name' due to Meta.ordering,\n# we get 2 groups instead of 1.\ncls.m1 = TestModel.objects.create(name='a', val=1)\ncls.m2 = TestModel.objects.create(name='b', val=1)\n\ndef test_meta_ordering_not_in_groupby(self):\n# Aggregation by 'val'. With correct behavior, we'll get a single row whose 'cnt' is 2.\n# If 'name' is erroneously added to GROUP BY, there will be 2 rows.\nqs = TestModel.objects.values('val').annotate(cnt=Sum('val'))\nself.assertEqual(\nlen(qs),\n1,\nf\"Expected exactly one group by val. Got: {qs}\"\n)\nself.assertEqual(\nqs[0]['cnt'],\n2,\nf\"Expected cnt=2, got {qs[0]['cnt']} from {qs[0]}\"\n)\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/compiler.py": "             cols = expr.get_group_by_cols()\n             for col in cols:\n                 expressions.append(col)\nif not self._meta_ordering:\nfor expr, (sql, params, is_ref) in order_by:\n# Skip references to the SELECT clause, as all expressions in\n# the SELECT clause are already part of the GROUP BY.\nif not is_ref:\nexpressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they are syntactically dissimilar and do not have functional equivalence. Sample 1 contains a complete implementation of an ORDER BY clause, which provides details about handling ordering in queries, while Sample 2 includes a small fragment related to constructing group by expressions in a different context. Their operations and focus differ significantly, indicating they are not clones.\"}"
}