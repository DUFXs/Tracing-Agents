{
    "instance_id": "pydata__xarray-4094",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "reproduce.py": "new file mode 100644\nindex 00000000..14631f16\nimport xarray as xr\nimport numpy as np\n\narr = xr.DataArray(\nnp.arange(3),\ncoords=[(\"x\", [0, 1, 2])],\n)\ndata = xr.Dataset({\"a\": arr, \"b\": arr})\nprint(\"Original data:\", data)\nprint(\"\\nStacked array:\", data.to_stacked_array('y', sample_dims=['x']))\nprint(\"\\nNow attempting to unstack...\")\nunstacked = data.to_stacked_array('y', sample_dims=['x']).to_unstacked_dataset('y')\nprint(\"\\nUnstacked result:\", unstacked)\n",
        "xarray/core/dataarray.py": "index b0df8749..7eeae197 100644\n         level_number = idx._get_level_number(level)\n         variables = idx.levels[level_number]\n         variable_dim = idx.names[level_number]\n         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\n# Get the data for this variable, handling missing values in the index\nvar_data = self.sel({variable_dim: k}, drop=True)\nif var_data.size > 0:  # Only include non-empty selections\ndata_dict[k] = var_data.squeeze(drop=True)\n \n         # unstacked dataset\nreturn Dataset(data_dict, attrs=self.attrs)\n\n \n     def transpose(self, *dims: Hashable, transpose_coords: bool = True) -> \"DataArray\":\n         \"\"\"Return a new DataArray object with transposed dimensions.\n \n # priority most be higher than Variable to properly work with binary ufuncs\n ops.inject_all_ops_and_reduce_methods(DataArray, priority=60)\n\n\n"
    },
    "ground_truth_patch": {
        "xarray/core/dataarray.py": "         # pull variables out of datarray\n         data_dict = {}\n         for k in variables:\ndata_dict[k] = self.sel({variable_dim: k}, drop=True).squeeze(drop=True)\n \n         # unstacked dataset\n         return Dataset(data_dict)\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-4\", \"reasoning\": \"These code samples are type-4 clones because they are syntactically dissimilar but functionally equivalent. Both code samples are dealing with extracting variables from a DataArray and returning a Dataset. However, they are expressed differently in terms of structure and layout. The first sample includes additional logic and formatting not found in the second, such as handling missing values in the index, which is implicitly indicated in the second sample.\"}"
}