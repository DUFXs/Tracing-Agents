{
    "instance_id": "django__django-15368",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "django/db/models/query.py": "index f8d848e926..b99513a09b 100644\n                 when_statements = []\n                 for obj in batch_objs:\n                     attr = getattr(obj, field.attname)\nif not isinstance(attr, (Expression, F)):\n                         attr = Value(attr, output_field=field)\n\n                     when_statements.append(When(pk=obj.pk, then=attr))\n                 case_statement = Case(*when_statements, output_field=field)\n                 if requires_casting:\n         rel_cls = RelatedPopulator(rel_klass_info, select, db)\n         iterators.append(rel_cls)\n     return iterators\n\n",
        "repro.py": "new file mode 100644\nindex 0000000000..8fe753964b\nimport os\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n\nfrom django.conf import settings\nsettings.configure(\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\nINSTALLED_APPS=['django.contrib.contenttypes'],\nDEBUG=True,  # Enable query logging\n)\n\nimport django\ndjango.setup()\n\nfrom django.db import models, connection\nfrom django.db.models import F\n\n# Create a simple model for testing\nclass SelfRef(models.Model):\nname = models.CharField(max_length=100)\nc8 = models.CharField(max_length=100)\n\nclass Meta:\napp_label = 'contenttypes'\n\n# Create table\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(SelfRef)\n\n# Test case\nobj = SelfRef.objects.create(name='test', c8='old')\nprint(f\"Initial values - name: {obj.name}, c8: {obj.c8}\")\n\n# Try bulk_update with F expression\nobj.c8 = F('name')\nSelfRef.objects.bulk_update([obj], ['c8'])\n\n# Check the result\nobj.refresh_from_db()\nprint(f\"After bulk_update - name: {obj.name}, c8: {obj.c8}\")\n\n# Print the actual SQL query for verification\nprint(\"\\nExecuted SQL:\")\nfor query in connection.queries:\nprint(query['sql'])\n"
    },
    "ground_truth_patch": {
        "django/db/models/query.py": " from django.db.models import AutoField, DateField, DateTimeField, sql\n from django.db.models.constants import LOOKUP_SEP, OnConflict\n from django.db.models.deletion import Collector\nfrom django.db.models.expressions import Case, F, Ref, Value, When\n from django.db.models.functions import Cast, Trunc\n from django.db.models.query_utils import FilteredRelation, Q\n from django.db.models.sql.constants import CURSOR, GET_ITERATOR_CHUNK_SIZE\n                 when_statements = []\n                 for obj in batch_objs:\n                     attr = getattr(obj, field.attname)\nif not hasattr(attr, 'resolve_expression'):\n                         attr = Value(attr, output_field=field)\n                     when_statements.append(When(pk=obj.pk, then=attr))\n                 case_statement = Case(*when_statements, output_field=field)\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarity but have modified statements. In the first sample, the attribute check is done with `isinstance(attr, (Expression, F))`, while in the second sample it uses `hasattr(attr, 'resolve_expression')`. Additionally, the context in which these fragments are found is slightly different, indicating added or modified code surrounding them.\"}"
}