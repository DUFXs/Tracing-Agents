{
    "instance_id": "django__django-14787",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/utils/decorators.py": "index 5c9a5d01c7..0704ab2a96 100644\n         decorators = [decorators]\n \n     def _wrapper(self, *args, **kwargs):\n@wraps(method)\ndef bound_method(*a, **k):\nreturn method.__get__(self, type(self))(*a, **k)\n\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n     return _wrapper\n \n \n\n def method_decorator(decorator, name=''):\n     \"\"\"\n     Convert a function decorator into a method decorator\n",
        "test_method_decorator_preserve_wrapper_assignments.py": "new file mode 100644\nindex 0000000000..2e60339a99\n#!/usr/bin/env python3\nimport sys\nimport logging\nfrom functools import wraps\nfrom django.utils.decorators import method_decorator\n\nlogger = logging.getLogger(__name__)\n\ndef logger_decorator(func):\n@wraps(func)\ndef inner(*args, **kwargs):\ntry:\nresult = func(*args, **kwargs)\nexcept Exception as e:\nresult = str(e)\nfinally:\nlogging.debug(f\"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}\")\nreturn result\nreturn inner\n\nclass Test:\n@method_decorator(logger_decorator)\ndef hello_world(self):\nreturn \"hello\"\n\ndef main():\ntry:\n# This should fail on HEAD if method_decorator incorrectly uses partial without preserving __name__.\nresult = Test().hello_world()\n# If no AttributeError was raised, let's check if the name was preserved\nactual_name = Test().hello_world.__name__\nif actual_name != \"hello_world\":\nprint(f\"ERROR: The name is not 'hello_world'. Found '{actual_name}'\")\nsys.exit(1)\nprint(\"SUCCESS: method_decorator preserved the wrapper assignments.\")\nsys.exit(0)\nexcept AttributeError as e:\nprint(f\"ERROR: {e}\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/utils/decorators.py": "         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\nbound_method = wraps(method)(partial(method.__get__(self, type(self))))\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they are syntactically similar but have added, modified, or removed statements. The second code sample appears to be a part of the same logic as the first but includes additional comments and variations in the way certain operations are performed (like using `wraps` with `partial`). They both involve decorators and function wrapping, indicating they serve similar purposes.\"}"
}