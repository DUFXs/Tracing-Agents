{
    "instance_id": "matplotlib__matplotlib-25311",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "lib/matplotlib/legend.py": "index ff6abdb958..835f5f01be 100644\n \n         super().__init__(legend, legend._legend_box, use_blit=use_blit)\n \ndef __getstate__(self):\n# Return a reduced state for pickling\nstate = self.__dict__.copy()\n# Remove unpicklable canvas reference\nstate.pop('canvas', None)\nstate.pop('background', None)\nstate.pop('_last_pos', None)\nreturn state\n\ndef __setstate__(self, state):\n# Restore instance attributes\nself.__dict__.update(state)\n# Initialize canvas-dependent attributes as None\nself.canvas = None\nself.background = None\nself._last_pos = None\n\n     def finalize_offset(self):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n         raise TypeError('Invalid arguments to legend.')\n \n     return handles, labels, extra_args, kwargs\n\n",
        "reproduce_bug.py": "new file mode 100644\nindex 0000000000..92ff6b89d0\nimport matplotlib\nmatplotlib.use('Qt5Agg')  # Force Qt backend\nimport matplotlib.pyplot as plt\nimport pickle\n\nfig = plt.figure()\nax = fig.add_subplot(111)\n\ntime=[0,1,2,3,4]\nspeed=[40,43,45,47,48]\n\nax.plot(time,speed,label=\"speed\")\n\nleg=ax.legend()\nleg.set_draggable(True)  # This line causes the pickling error\n\ntry:\npickle.dumps(fig)\nprint(\"Successfully pickled figure!\")\nexcept Exception as e:\nprint(f\"Error pickling figure: {str(e)}\")\n\nplt.close()\n\n",
        "test_legend_pickle.py": "new file mode 100644\nindex 0000000000..19d1817039\nimport matplotlib.pyplot as plt\nimport pickle\n\n# Create a figure with draggable legend\nfig = plt.figure()\nax = fig.add_subplot(111)\n\ntime=[0,1,2,3,4]\nspeed=[40,43,45,47,48]\n\nax.plot(time,speed,label=\"speed\")\n\nleg=ax.legend()\nleg.set_draggable(True)\n\n# Test pickling\ntry:\n# Try to pickle the figure\npickled_data = pickle.dumps(fig)\nprint(\"Successfully pickled figure!\")\n\n# Try to unpickle and verify\nunpickled_fig = pickle.loads(pickled_data)\nprint(\"Successfully unpickled figure!\")\n\n# Verify the legend is still draggable\nunpickled_leg = unpickled_fig.axes[0].get_legend()\nif hasattr(unpickled_leg, '_draggable'):\nprint(\"Legend is still draggable!\")\nelse:\nprint(\"Error: Legend lost draggable state!\")\n\nexcept Exception as e:\nprint(f\"Error: {str(e)}\")\n"
    },
    "ground_truth_patch": {
        "lib/matplotlib/offsetbox.py": "         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n         self._use_blit = use_blit and self.canvas.supports_blit\n         self.cids = [\n             self.canvas.callbacks._connect_picklable(\n                 'button_release_event', self.on_release),\n         ]\n \n# A property, not an attribute, to maintain picklability.\ncanvas = property(lambda self: self.ref_artist.figure.canvas)\n\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they relate to different functionalities and do not exhibit structural or syntactical similarity. Code sample 1 deals with methods for pickling a legend in a Matplotlib figure, while code sample 2 focuses on managing pickable artists in the offset box, which is a different aspect of Matplotlib's interaction model.\"}"
}