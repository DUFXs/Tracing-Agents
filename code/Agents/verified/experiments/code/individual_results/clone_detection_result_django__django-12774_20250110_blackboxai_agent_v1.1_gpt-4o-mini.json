{
    "instance_id": "django__django-12774",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index 238fb3a200..521baaa795 100644\n tests/.coverage\n build/\n tests/report/\n.aider/\n",
        "django/db/models/query.py": "index d9c9b0db04..980be88f8d 100644\n     DJANGO_VERSION_PICKLE_KEY, IntegrityError, NotSupportedError, connections,\n     router, transaction,\n )\nfrom django.db.models import AutoField, DateField, DateTimeField, sql, UniqueConstraint\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.deletion import Collector\n from django.db.models.expressions import Case, Expression, F, Value, When\n         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\nif field_name != 'pk':\nfield = self.model._meta.get_field(field_name)\nfield_unique = field.unique\n# Check if field has a single-field total unique constraint\nhas_unique_constraint = any(\nlen(constraint.fields) == 1 and \nconstraint.fields[0] == field_name and \nconstraint.condition is None\nfor constraint in self.model._meta.constraints\nif isinstance(constraint, UniqueConstraint)\n)\nif not (field_unique or has_unique_constraint):\nraise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n                 return {}\n"
    },
    "ground_truth_patch": {
        "django/db/models/query.py": "         \"\"\"\n         assert not self.query.is_sliced, \\\n             \"Cannot use 'limit' or 'offset' with in_bulk\"\nopts = self.model._meta\nunique_fields = [\nconstraint.fields[0]\nfor constraint in opts.total_unique_constraints\nif len(constraint.fields) == 1\n]\nif (\nfield_name != 'pk' and\nnot opts.get_field(field_name).unique and\nfield_name not in unique_fields\n):\n             raise ValueError(\"in_bulk()'s field_name must be a unique field but %r isn't.\" % field_name)\n         if id_list is not None:\n             if not id_list:\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactic similarity but contain added, modified, or removed statements. While both samples contain similar logic regarding the handling of field names and unique constraints, the first sample has additional context and logic that is not present in the second sample, leading to a syntactically similar yet altered structure.\"}"
}