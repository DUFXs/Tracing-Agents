{
    "instance_id": "scikit-learn__scikit-learn-14053",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "edge_cases.py": "new file mode 100644\nindex 000000000..a93b1e1e6\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.tree.export import export_text\nfrom sklearn.datasets import load_iris\nimport numpy as np\n\n# Load data\nX, y = load_iris(return_X_y=True)\nX = X[:, 0].reshape(-1, 1)\n\n# Test case 1: No feature names provided\ntree1 = DecisionTreeClassifier(max_depth=2)\ntree1.fit(X, y)\nprint(\"Test 1: No feature names\")\nprint(export_text(tree1))\nprint(\"\\n\" + \"=\"*50 + \"\\n\")\n\n# Test case 2: Empty feature names list\ntree2 = DecisionTreeClassifier(max_depth=2)\ntree2.fit(X, y)\nprint(\"Test 2: Empty feature names list\")\ntry:\nprint(export_text(tree2, feature_names=[]))\nexcept ValueError as e:\nprint(\"Expected error:\", str(e))\nprint(\"\\n\" + \"=\"*50 + \"\\n\")\n\n# Test case 3: Single feature with custom name\ntree3 = DecisionTreeClassifier(max_depth=2)\ntree3.fit(X, y)\nprint(\"Test 3: Single feature with custom name\")\nprint(export_text(tree3, feature_names=['custom_feature']))\n\\ No newline at end of file\n",
        "reproduce_error.py": "new file mode 100644\nindex 000000000..8c39c586b\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.tree.export import export_text\nfrom sklearn.datasets import load_iris\n\nX, y = load_iris(return_X_y=True)\nX = X[:, 0].reshape(-1, 1)\n\ntree = DecisionTreeClassifier()\ntree.fit(X, y)\ntree_text = export_text(tree, feature_names=['sepal_length'])\nprint(tree_text)\n\\ No newline at end of file\n",
        "sklearn/tree/export.py": "index 1fe11e596..e88eee4da 100644\n         value_fmt = \"{}{} value: {}\\n\"\n \n     if feature_names:\nfeature_names_ = [feature_names[i] if i != _tree.TREE_UNDEFINED else None\nfor i in tree_.feature]\n     else:\nfeature_names_ = [\"feature_{}\".format(i) if i != _tree.TREE_UNDEFINED else None\nfor i in tree_.feature]\n \n     export_text.report = \"\"\n \n \n             if tree_.feature[node] != _tree.TREE_UNDEFINED:\n                 name = feature_names_[node]\nif name is None:  # Handle the case where feature_names_[node] is None\nname = \"feature_{}\".format(tree_.feature[node])\n                 threshold = tree_.threshold[node]\n                 threshold = \"{1:.{0}f}\".format(decimals, threshold)\n                 export_text.report += right_child_fmt.format(indent,\n"
    },
    "ground_truth_patch": {
        "sklearn/tree/export.py": "         value_fmt = \"{}{} value: {}\\n\"\n \n     if feature_names:\nfeature_names_ = [feature_names[i] if i != _tree.TREE_UNDEFINED\nelse None for i in tree_.feature]\n     else:\n         feature_names_ = [\"feature_{}\".format(i) for i in tree_.feature]\n \n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because Code Sample 1 contains entire test cases and usages of the DecisionTreeClassifier from sklearn, while Code Sample 2 consists solely of a small section of function implementation from the sklearn library. They are functionally dissimilar, with one being a complete use-case example and the other a part of the library's internal logic.\"}"
}