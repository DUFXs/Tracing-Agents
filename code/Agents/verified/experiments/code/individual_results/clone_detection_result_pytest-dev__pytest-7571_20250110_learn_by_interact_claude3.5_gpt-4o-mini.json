{
    "instance_id": "pytest-dev__pytest-7571",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "reproduce.py": "new file mode 100644\nindex 000000000..a381355d7\nimport pytest\n\ndef test_foo(caplog):\nprint(\"Before set_level:\", caplog.handler.level)\ncaplog.set_level(42)\nprint(\"After set_level:\", caplog.handler.level)\n\ndef test_bar(caplog):\nprint(\"Handler level in second test:\", caplog.handler.level)\n",
        "src/_pytest/logging.py": "index 11031f2f2..56750b405 100644\n         self._item = item\n         # dict of log name -> log level\n         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\nself._initial_handler_level = None  # type: Optional[int]\n \n     def _finalize(self) -> None:\n         \"\"\"Finalizes the fixture.\n         for logger_name, level in self._initial_logger_levels.items():\n             logger = logging.getLogger(logger_name)\n             logger.setLevel(level)\n# restore handler level if it was changed\nif self._initial_handler_level is not None:\nself.handler.setLevel(self._initial_handler_level)\n \n     @property\n     def handler(self) -> LogCaptureHandler:\n         logger_obj = logging.getLogger(logger)\n         # save the original log-level to restore it during teardown\n         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n# save the original handler level if not already saved\nif self._initial_handler_level is None:\nself._initial_handler_level = self.handler.level\n         logger_obj.setLevel(level)\n         self.handler.setLevel(level)\n \n\n     @contextmanager\n     def at_level(\n         self, level: int, logger: Optional[str] = None\n     def handleError(self, record: logging.LogRecord) -> None:\n         # Handled by LogCaptureHandler.\n         pass\n\n\n\n\n"
    },
    "ground_truth_patch": {
        "src/_pytest/logging.py": "         \"\"\"Creates a new funcarg.\"\"\"\n         self._item = item\n         # dict of log name -> log level\nself._initial_handler_level = None  # type: Optional[int]\n         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n \n     def _finalize(self) -> None:\n         This restores the log levels changed by :meth:`set_level`.\n         \"\"\"\n         # restore log levels\nif self._initial_handler_level is not None:\nself.handler.setLevel(self._initial_handler_level)\n         for logger_name, level in self._initial_logger_levels.items():\n             logger = logging.getLogger(logger_name)\n             logger.setLevel(level)\n         # save the original log-level to restore it during teardown\n         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n         logger_obj.setLevel(level)\nself._initial_handler_level = self.handler.level\n         self.handler.setLevel(level)\n \n     @contextmanager\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-4\", \"reasoning\": \"These code samples are type-4 clones because they are syntactically dissimilar and contain different comments and documentation strings, yet they provide similar functionality in managing logger levels.\"}"
}