{
    "instance_id": "django__django-11433",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/forms/models.py": "index 5edbbd376f..cc998e7be2 100644\n \n def construct_instance(form, instance, fields=None, exclude=None):\n     \"\"\"\nConstruct and return a model instance from the bound form's cleaned_data,\nbut do not save it to the database.\n\nDefault Django logic:\n- Skip uneditable fields or fields not in cleaned_data.\n- Skip fields if they're not listed in `fields` (unless the developer\nprovided a non-empty override in cleaned_data for a field that doesn't\nactually exist on the form).\n- Skip fields if they're in the exclude list.\n- Skip fields if the user truly omitted them from data and cleaned_data\nfor that field is empty/blank.\n\nOtherwise, apply cleaned_data to the instance, preserving the possibility\nfor form.clean() to override a default even if the field wasn't exposed\nas a form field at all.\n     \"\"\"\n     from django.db import models\n     opts = instance._meta\n \n     cleaned_data = form.cleaned_data\n     file_field_list = []\n\n     for f in opts.fields:\n# 1) Skip if not editable, or if the field isn't in cleaned_data at all.\nif not f.editable or isinstance(f, models.AutoField) or (f.name not in cleaned_data):\n             continue\n\noverride_val = cleaned_data[f.name]\n\n# 2) If fields is specified but doesn't include f.name, skip if the\n#    form does actually have that field (user input scenario).\n#    If there's no such field on the form, it might be a developer override.\n         if fields is not None and f.name not in fields:\nif f.name in form.fields:\n# The user provided data for a field not in fields => skip.\ncontinue\nelse:\n# No real form field => check if override is empty.\nif override_val in (None, '', [], (), {}):\ncontinue\n\n# 3) Skip if in exclude.\n         if exclude and f.name in exclude:\n             continue\n\n# 4) Check if the user truly omitted input for this field\n#    and cleaned_data is empty => keep default.\nformfield = form.fields.get(f.name)\nif formfield is not None:\nomitted = formfield.widget.value_omitted_from_data(\nform.data, form.files, form.add_prefix(f.name)\n)\nempty_values = getattr(formfield, 'empty_values', [None, '', [], (), {}])\nelse:\nomitted = (f.name not in form.data)\nempty_values = [None, '', [], (), {}]\n\nif omitted and override_val in empty_values:\n             continue\n\n# Defer file field updates until after other fields.\n         if isinstance(f, models.FileField):\n             file_field_list.append(f)\n         else:\nf.save_form_data(instance, override_val)\n \n# Now save file fields.\n     for f in file_field_list:\n         f.save_form_data(instance, cleaned_data[f.name])\n \n     return instance\n \n \n\n\n\n\n\n\n\n # ModelForms #################################################################\n \n def model_to_dict(instance, fields=None, exclude=None):\n",
        "test_allow_cleaned_data_overwrite.py": "new file mode 100644\nindex 0000000000..cf1a655fb5\nimport sys\nimport os\n\n# Minimal Django setup to allow in-memory testing\nimport django\nfrom django.conf import settings\nfrom django.db import models\nfrom django.forms import ModelForm\n\n# Configure settings for an in-memory test DB.\n# The app_label can be anything that's not used by the django/django suite.\n# Also ensure INSTALLED_APPS includes this \"testapp\" so the model is recognized.\nif not settings.configured:\nsettings.configure(\nDEBUG=True,\nSECRET_KEY='test_key',\nINSTALLED_APPS=['testapp'],\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\nMIDDLEWARE=[],\nTEMPLATES=[],\n)\n\ndjango.setup()\n\n# Define a testapp models module on the fly to hold our test model\nclass MyModel(models.Model):\nname = models.CharField(max_length=100, default='default_name')\n\nclass Meta:\napp_label = 'testapp'\n\n# Create or mutate a migrations module in memory if needed\n# We'll create the table manually\nfrom django.core.management import call_command\ntry:\ncall_command('makemigrations', 'testapp', interactive=False, verbosity=0)\ncall_command('migrate', interactive=False, verbosity=0)\nexcept Exception as e:\nprint(\"Error creating in-memory DB schema:\", e)\nsys.exit(2)\n\n# Now define a ModelForm that omits \"name\" from the data payload,\n# but tries to set it in cleaned_data.\nclass MyModelForm(ModelForm):\nclass Meta:\nmodel = MyModel\nfields = []  # intentionally empty\n\ndef clean(self):\ncd = super().clean()\n# The user wants to override \"name\" even though it isn't in posted data:\ncd[\"name\"] = \"overridden_in_cleaned_data\"\nreturn cd\n\ndef main():\ntry:\n# Simulate a post with no data for \"name\".\ndata = {}\nform = MyModelForm(data=data)\nif not form.is_valid():\n# If the form is invalid for some reason, the issue is overshadowed\nprint(\"FAIL: The form is unexpectedly invalid:\", form.errors)\nsys.exit(1)\n\n# Save the instance\ninstance = form.save(commit=True)\n\n# We EXPECT instance.name == \"overridden_in_cleaned_data\" if the bug is fixed.\n# On HEAD (unpatched), instance.name will remain \"default_name\" due to the skip logic.\nif instance.name == \"overridden_in_cleaned_data\":\nprint(\"PASS: The form's cleaned_data successfully overwrote the default value.\")\nsys.exit(0)\nelse:\nprint(\"FAIL: instance.name =\", instance.name, \"did not overwrite the default.\")\nsys.exit(1)\n\nexcept Exception as e:\nprint(\"FAIL: Exception occurred while testing:\", e)\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n",
        "testapp/__init__.py": "new file mode 100644\nindex 0000000000..e69de29bb2\n",
        "testapp/migrations/0001_initial.py": "new file mode 100644\nindex 0000000000..40e76a2cd2\n# Generated by Django 3.0.dev20190603194455 on 2025-01-13 10:15\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\ninitial = True\n\ndependencies = [\n]\n\noperations = [\nmigrations.CreateModel(\nname='MyModel',\nfields=[\n('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n('name', models.CharField(default='default_name', max_length=100)),\n],\n),\n]\n",
        "testapp/migrations/__init__.py": "new file mode 100644\nindex 0000000000..e69de29bb2\n"
    },
    "ground_truth_patch": {
        "django/forms/models.py": "continue\n# Leave defaults for fields that aren't in POST data, except for\n# checkbox inputs because they don't appear in POST data if not checked.\nif (\n    f.has_default()\n    and form[f.name].field.widget.value_omitted_from_data(\n        form.data, form.files, form.add_prefix(f.name)\n    )\n    and cleaned_data.get(f.name) in form[f.name].field.empty_values\n):\n    continue\n# Defer saving file-type fields until after the other fields, so a\n# callable upload_to can use the values from other fields.\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they are syntactically dissimilar and serve different purposes within the codebase. The first sample is a long function definition dealing with the construction of a model instance from a Django form, while the second sample consists of a small piece of logic that checks for default values when processing fields. There are no significant syntactic similarities or functional equivalences to suggest they are clones, and they cover different scenarios.\"}"
}