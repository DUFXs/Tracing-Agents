{
    "instance_id": "django__django-12193",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/forms/widgets.py": "index 6fe220bea7..0b25787ebc 100644\n \n     def get_context(self, name, value, attrs):\n         if self.check_test(value):\nattrs = {} if attrs is None else attrs.copy()\n             attrs['checked'] = True\n         return super().get_context(name, value, attrs)\n \n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..6ff93ed96a\nimport django\nfrom django.conf import settings\nfrom django.forms import BooleanField, Form, MultiValueField, MultiWidget\n\n# Configure Django settings\nif not settings.configured:\nsettings.configure(\nUSE_I18N=True,\nUSE_L10N=True,\nUSE_TZ=True,\nDATABASES={},\nINSTALLED_APPS=['django.contrib.contenttypes'],\nLANGUAGE_CODE='en-us',\n)\ndjango.setup()\n\nclass BooleanArrayWidget(MultiWidget):\ndef __init__(self, size, attrs=None):\nwidgets = [BooleanField().widget for _ in range(size)]\nsuper().__init__(widgets, attrs)\n\ndef decompress(self, value):\nif value:\nreturn value\nreturn [None] * len(self.widgets)\n\nclass BooleanArrayField(MultiValueField):\ndef __init__(self, size=3, **kwargs):\nfields = [BooleanField(required=False) for _ in range(size)]\nwidget = BooleanArrayWidget(size)\nsuper().__init__(fields, widget=widget, require_all_fields=False, **kwargs)\n\ndef compress(self, data_list):\nreturn data_list\n\nclass TestForm(Form):\nbool_array = BooleanArrayField()\n\n# Create a form with initial data where some values are True and others are False\nform = TestForm(initial={'bool_array': [True, False, False]})\n\n# Get the rendered HTML to show the issue\nhtml = form.as_p()\nprint(\"Form HTML output:\")\nprint(html)\n\n# The issue is that all checkboxes after the first True will be checked\n# even though their values are False in the initial data\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/forms/widgets.py": " \n     def get_context(self, name, value, attrs):\n         if self.check_test(value):\nattrs = {**(attrs or {}), 'checked': True}\n         return super().get_context(name, value, attrs)\n \n     def value_from_datadict(self, data, files, name):\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share similar functionality in the `get_context` method, but have modifications in how the `attrs` dictionary is manipulated. The first sample uses a check for `None`, while the second sample uses dictionary unpacking with a default empty dictionary. Additionally, the second sample includes an extra method `value_from_datadict`, which is not present in the first.\"}"
}