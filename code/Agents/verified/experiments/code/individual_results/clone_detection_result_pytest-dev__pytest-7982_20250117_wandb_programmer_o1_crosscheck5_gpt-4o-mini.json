{
    "instance_id": "pytest-dev__pytest-7982",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "src/_pytest/pathlib.py": "index f0bdb1481..15e2e630d 100644\n     return result\n \n \ndef visit(path: str, recurse: Callable[[os.DirEntry], bool]) -> Iterator[os.DirEntry]:\n\"\"\"Walk a directory recursively, in breadth-first order.\"\"\"\n     entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n     yield from entries\n     for entry in entries:\nif entry.is_dir() and recurse(entry):\n             yield from visit(entry.path, recurse)\n \n \n\n def absolutepath(path: Union[Path, str]) -> Path:\n     \"\"\"Convert a path to an absolute path using os.path.abspath.\n \n",
        "testing/symlinkdir_test_script.py": "new file mode 100644\nindex 000000000..4b4c01367\n#!/usr/bin/env python3\n\nimport os\nimport sys\nimport tempfile\nimport subprocess\nimport shutil\n\ndef main():\nprint(\"Step 1: Create temp directory structure.\")\ntmpdir = tempfile.mkdtemp(prefix=\"pytest_symlink_test_\")\ntry:\n# This directory will actually hold the tests.\nactual_tests_dir = os.path.join(tmpdir, \"actual_tests_dir\")\nos.mkdir(actual_tests_dir)\n\ntest_file_path = os.path.join(actual_tests_dir, \"test_in_symlink.py\")\nwith open(test_file_path, \"w\") as f:\nf.write(\"def test_symlinked_dir():\\n    assert True\\n\")\nprint(f\"Wrote test file: {test_file_path}\")\n\n# topdir is where we will run pytest. It only contains a symlink.\ntopdir = os.path.join(tmpdir, \"topdir\")\nos.mkdir(topdir)\nprint(f\"Created top-level directory: {topdir}\")\n\n# Create symlink to the actual tests inside topdir\nsymlink_path = os.path.join(topdir, \"my_symlink\")\nos.symlink(actual_tests_dir, symlink_path)\nprint(f\"Symlink created: {symlink_path} -> {actual_tests_dir}\")\n\nprint(\"Step 2: Run pytest on topdir, capturing output.\")\ncmd = [\"pytest\", topdir]\nprint(\"Running command:\", cmd)\nproc = subprocess.run(cmd, capture_output=True, text=True)\nstdout = proc.stdout\nstderr = proc.stderr\nreturncode = proc.returncode\n\nprint(\"Pytest stdout:\")\nprint(stdout)\nprint(\"Pytest stderr:\")\nprint(stderr)\nprint(f\"Pytest return code: {returncode}\")\n\n# If symlinks are ignored, we get 0 tests collected. We expect no \"1 passed\" in the output.\n# We want this script to fail if we do NOT see \"1 passed\".\n# So if \"1 passed\" is found, that means the symlink directory was correctly collected.\nif \"1 passed\" in stdout and returncode == 0:\nprint(\"Symlinked test was collected and run successfully (BUG FIXED).\")\nsys.exit(0)\nelse:\nprint(\"Symlinked test was NOT collected or did not run successfully (BUG PRESENT).\")\nsys.exit(1)\nfinally:\nprint(\"Cleaning up temp directory.\")\nshutil.rmtree(tmpdir, ignore_errors=True)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "src/_pytest/pathlib.py": "     entries = sorted(os.scandir(path), key=lambda entry: entry.name)\n     yield from entries\n     for entry in entries:\nif entry.is_dir() and recurse(entry):\n             yield from visit(entry.path, recurse)\n \n \n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical in content, with differences only in whitespace and layout. The code lines are the same, but the formatting and indentation differ.\"}"
}