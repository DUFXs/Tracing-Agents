{
    "instance_id": "django__django-15561",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/backends/base/schema.py": "index 9d6952df21..c6091fed1d 100644\n             \"related_query_name\",\n             \"validators\",\n             \"verbose_name\",\n\"choices\",\n         ]\n         for attr in non_database_attrs:\n             old_kwargs.pop(attr, None)\n             new_kwargs.pop(attr, None)\nreturn (\nself.quote_name(old_field.column) != self.quote_name(new_field.column)\nor (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)\n)\n\n \n     def _field_should_be_indexed(self, model, field):\n         return field.db_index and not field.unique\n",
        "test_sqlite_choices_alter.py": "new file mode 100644\nindex 0000000000..f9bfd4621f\nimport sys\nimport textwrap\nimport django\nfrom django.conf import settings\nfrom django.db import connection, models\n\n# Configure minimal Django settings if not already configured.\nif not settings.configured:\nsettings.configure(\nINSTALLED_APPS=[\n\"django.contrib.contenttypes\",\n],\nDATABASES={\n\"default\": {\n\"ENGINE\": \"django.db.backends.sqlite3\",\n\"NAME\": \":memory:\",\n}\n},\nSECRET_KEY=\"dummy\",\nUSE_I18N=False,\nUSE_L10N=False,\nUSE_TZ=False,\n)\ndjango.setup()\n\ndef main():\n\"\"\"\n1) Create an in-memory SQLite db.\n2) Define a test model with initial 'choices'.\n3) Use schema_editor(collect_sql=True) to alter the field with new 'choices'.\n4) If \"CREATE TABLE \\\"NEW__\" is found in the SQL (uppercase), we fail with code 1.\n\"\"\"\n\nprint(\"Step 1: Defining a test model with a 'choices' attribute.\")\nclass TestModel(models.Model):\nname = models.CharField(\nmax_length=20,\nchoices=[(\"A\",\"A label\"), (\"B\",\"B label\")],\n)\nclass Meta:\napp_label = \"test_app_choices_alter\"\n\nwith connection.schema_editor(collect_sql=True) as editor:\neditor.create_model(TestModel)\n\nprint(\"Step 2: Attempting to alter only the field's choices.\")\nold_field = TestModel._meta.get_field(\"name\")\nnew_field = models.CharField(\nmax_length=20,\nchoices=[(\"A\",\"A label\"), (\"C\",\"C label\")],  # changed from B->C\n)\nnew_field.set_attributes_from_name(\"name\")\n\nwith connection.schema_editor(collect_sql=True) as editor:\neditor.alter_field(TestModel, old_field, new_field)\ngenerated_sql = \"\\n\".join(editor.collected_sql)\n\nprint(\"Collected SQL:\\n\", textwrap.indent(generated_sql, \"    \"))\n\n# Check if a new table is created.\n# The actual snippet is CREATE TABLE \"new__..., so we look for CREATE TABLE \\\"NEW__ in uppercase:\nif \"CREATE TABLE \\\"NEW__\" in generated_sql.upper():\nprint(\"ERROR: Found 'CREATE TABLE \\\"NEW__' => unwanted table remake => bug present.\")\nsys.exit(1)\nelse:\nprint(\"SUCCESS: No 'CREATE TABLE \\\"NEW__' => no unwanted table remake => bug appears fixed.\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/backends/base/schema.py": "         # - changing only a field name\n         # - changing an attribute that doesn't affect the schema\n         # - adding only a db_column and the column name is not changed\nfor attr in old_field.non_db_attrs:\n             old_kwargs.pop(attr, None)\nfor attr in new_field.non_db_attrs:\n             new_kwargs.pop(attr, None)\n         return self.quote_name(old_field.column) != self.quote_name(\n             new_field.column\n",
        "django/db/models/fields/__init__.py": "     system_check_deprecated_details = None\n     system_check_removed_details = None\n \n# Attributes that don't affect a column definition.\n# These attributes are ignored when altering the field.\nnon_db_attrs = (\n\"blank\",\n\"choices\",\n\"db_column\",\n\"editable\",\n\"error_messages\",\n\"help_text\",\n\"limit_choices_to\",\n# Database-level options are not supported, see #21961.\n\"on_delete\",\n\"related_name\",\n\"related_query_name\",\n\"validators\",\n\"verbose_name\",\n)\n\n     # Field flags\n     hidden = False\n \n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactic similarities while containing added and removed statements. Both samples operate on the context of Django models, specifically regarding the manipulation of non-database attributes and field attributes. However, there are notable differences in the approach taken and additional context present in each sample, indicating they are not identical but share a functional structure.\"}"
}