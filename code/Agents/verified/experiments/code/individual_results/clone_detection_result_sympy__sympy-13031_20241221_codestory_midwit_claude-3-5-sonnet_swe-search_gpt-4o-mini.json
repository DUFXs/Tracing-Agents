{
    "instance_id": "sympy__sympy-13031",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..c05044e39b\nimport sympy as sy\n\n# Test case 1: Empty rows hstack\nM1 = sy.Matrix.zeros(0, 0)\nM2 = sy.Matrix.zeros(0, 1)\nM3 = sy.Matrix.zeros(0, 2)\nM4 = sy.Matrix.zeros(0, 3)\nresult1 = sy.Matrix.hstack(M1, M2, M3, M4).shape\nprint(\"Test case 1 (empty rows hstack):\", result1)\n# Expected: (0, 6)\n\n# Test case 2: Non-empty rows hstack\nM1 = sy.Matrix.zeros(1, 0)\nM2 = sy.Matrix.zeros(1, 1)\nM3 = sy.Matrix.zeros(1, 2)\nM4 = sy.Matrix.zeros(1, 3)\nresult2 = sy.Matrix.hstack(M1, M2, M3, M4).shape\nprint(\"Test case 2 (non-empty rows hstack):\", result2)\n# Expected: (1, 6)\n\n# Test case 3: Empty cols vstack\nM1 = sy.Matrix.zeros(0, 0)\nM2 = sy.Matrix.zeros(1, 0)\nM3 = sy.Matrix.zeros(2, 0)\nM4 = sy.Matrix.zeros(3, 0)\nresult3 = sy.Matrix.vstack(M1, M2, M3, M4).shape\nprint(\"Test case 3 (empty cols vstack):\", result3)\n# Expected: (6, 0)\n\\ No newline at end of file\n",
        "sympy/matrices/common.py": "index 7ef51bc847..29cd330e78 100644\n         if len(args) == 0:\n             return cls._new()\n \n# Handle empty matrices specially\nall_empty_rows = all(mat.rows == 0 for mat in args)\nif all_empty_rows:\ntotal_cols = sum(mat.cols for mat in args)\nreturn cls._new(0, total_cols, [])\n\n# For non-empty matrices, use standard row_join\n         kls = type(args[0])\n         return reduce(kls.row_join, args)\n \n         row\n         col_join\n         \"\"\"\n# Special handling for empty matrices\nif self.cols == 0:\nif self.rows == 0:\n# If self is 0x0, use other's rows\nreturn self._new(other.rows, 0, []).row_join(other)\nelif self.rows != other.rows:\n# If self has 0 cols but non-zero rows, match other's rows\nreturn self._new(other.rows, 0, []).row_join(other)\n \n         if self.rows != other.rows:\n             raise ShapeError(\n         if len(args) == 0:\n             return cls._new()\n \n# Handle empty matrices specially\nall_empty_cols = all(mat.cols == 0 for mat in args)\nif all_empty_cols:\ntotal_rows = sum(mat.rows for mat in args)\nreturn cls._new(total_rows, 0, [])\n\n# For non-empty matrices, use standard col_join\n         kls = type(args[0])\n         return reduce(kls.col_join, args)\n \n"
    },
    "ground_truth_patch": {
        "sympy/matrices/sparse.py": "         >>> C == A.row_insert(A.rows, Matrix(B))\n         True\n         \"\"\"\n# A null matrix can always be stacked (see  #10770)\nif self.rows == 0 and self.cols != other.cols:\nreturn self._new(0, other.cols, []).col_join(other)\n\n         A, B = self, other\n         if not A.cols == B.cols:\n             raise ShapeError()\n         >>> C == A.col_insert(A.cols, B)\n         True\n         \"\"\"\n# A null matrix can always be stacked (see  #10770)\nif self.cols == 0 and self.rows != other.rows:\nreturn self._new(other.rows, 0, []).row_join(other)\n\n         A, B = self, other\n         if not A.rows == B.rows:\n             raise ShapeError()\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they focus on different functionalities related to matrices. The first sample deals with various test cases for stacking empty and non-empty matrices, while the second sample discusses conditions for handling null matrices and shape errors during operations. The contexts and purposes of the code are distinct, leading to syntactical dissimilarity and functional differences.\"}"
}