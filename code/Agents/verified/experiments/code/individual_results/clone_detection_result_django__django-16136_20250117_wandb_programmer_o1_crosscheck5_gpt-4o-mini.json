{
    "instance_id": "django__django-16136",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/views/generic/base.py": "index db1842e3e5..ff22ce8dc7 100644\n             request.path,\n             extra={\"status_code\": 405, \"request\": request},\n         )\nif self.view_is_async:\nasync def func():\nreturn HttpResponseNotAllowed(self._allowed_methods())\nreturn func()\nelse:\nreturn HttpResponseNotAllowed(self._allowed_methods())\n\n \n     def options(self, request, *args, **kwargs):\n         \"\"\"Handle responding to requests for the OPTIONS HTTP verb.\"\"\"\n",
        "test_async_http_not_allowed.py": "new file mode 100644\nindex 0000000000..d1e4309d0e\nimport sys\nimport django\nfrom django.conf import settings\nfrom django.test import Client\nfrom django.urls import path\nfrom django.http import HttpResponse\nfrom django.views import View\n\n\nclass Demo(View):\nasync def post(self, request):\nreturn HttpResponse(\"ok\")\n\n\nurlpatterns = [\npath(\"test/\", Demo.as_view()),\n]\n\n\ndef main():\nprint(\"Starting test_async_http_not_allowed.py\")\nprint(\"Configuring minimal Django settings for the test.\")\nsettings.configure(\nDEBUG=True,\nSECRET_KEY=\"secret\",\nROOT_URLCONF=__name__,\nALLOWED_HOSTS=[\"*\"],\nMIDDLEWARE=[],\nINSTALLED_APPS=[\"django.contrib.contenttypes\", \"django.contrib.auth\"],\n)\ndjango.setup()\n\nprint(\"Making a GET request to /test/ where the view only defines async POST.\")\nclient = Client()\nresponse = client.get(\"/test/\")\nprint(f\"Response status code: {response.status_code}\")\n\nif response.status_code == 405:\nprint(\"RESULT: test_async_http_not_allowed is FIXED => got 405.\")\nsys.exit(0)\nelse:\nprint(\"RESULT: test_async_http_not_allowed is FAILING => expected 405, got\", response.status_code)\nsys.exit(1)\n\n\nif __name__ == '__main__':\nmain()\n"
    },
    "ground_truth_patch": {
        "django/views/generic/base.py": "             request.path,\n             extra={\"status_code\": 405, \"request\": request},\n         )\nresponse = HttpResponseNotAllowed(self._allowed_methods())\n\nif self.view_is_async:\n\nasync def func():\nreturn response\n\nreturn func()\nelse:\nreturn response\n \n     def options(self, request, *args, **kwargs):\n         \"\"\"Handle responding to requests for the OPTIONS HTTP verb.\"\"\"\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they are syntactically similar but have added, modified, or removed statements. The second sample has a different structure in the response handling where the creation and return of the `HttpResponseNotAllowed` object is streamlined and isolated in its own variable, instead of being repeated as seen in the first sample. Additionally, the way the returned function `func` handles the response is slightly altered, denoting a functional yet changed syntax.\"}"
}