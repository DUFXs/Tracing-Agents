{
    "instance_id": "matplotlib__matplotlib-14623",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "lib/matplotlib/axes/_base.py": "index da2dea6f57..dbf13964d2 100644\n         \"\"\"\n         return tuple(self.viewLim.intervaly)\n \ndef set_ylim(self, bottom=None, top=None, emit=True, auto=False, *, ymin=None, ymax=None):\n         if top is None and np.iterable(bottom):\n             bottom, top = bottom\n         if ymin is not None:\n             if bottom is not None:\nraise TypeError('Cannot pass both ymin and bottom')\n             bottom = ymin\n         if ymax is not None:\n             if top is not None:\nraise TypeError('Cannot pass both ymax and top')\n             top = ymax\n\n         self._process_unit_info(ydata=(bottom, top))\n         bottom = self._validate_converted_limits(bottom, self.convert_yunits)\n         top = self._validate_converted_limits(top, self.convert_yunits)\n\n         old_bottom, old_top = self.get_ylim()\n\n         if bottom is None:\n             bottom = old_bottom\n         if top is None:\n             top = old_top\n\n         if self.get_yscale() == 'log':\n             if bottom <= 0:\n                 cbook._warn_external(\n'Attempted to set non-positive bottom ylim on a log-scaled axis.\\n'\n'Invalid limit will be ignored.'\n)\n                 bottom = old_bottom\n             if top <= 0:\n                 cbook._warn_external(\n'Attempted to set non-positive top ylim on a log-scaled axis.\\n'\n'Invalid limit will be ignored.'\n)\n                 top = old_top\n\n         if bottom == top:\n             cbook._warn_external(\nf'Attempting to set identical bottom == top == {bottom} results in singular '\n'transformations; automatically expanding.'\n)\n\n# Patch: Skip nonsingular if the user explicitly reversed the limits\nif bottom < top:\nbottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n\n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\n             self._autoscaleYon = bool(auto)\n\n         if emit:\n             self.callbacks.process('ylim_changed', self)\n             for other in self._shared_y_axes.get_siblings(self):\n                 if other is not self:\nother.set_ylim(self.viewLim.intervaly, emit=False, auto=auto)\n                     if other.figure != self.figure:\n                         other.figure.canvas.draw_idle()\n         self.stale = True\n         return bottom, top\n\n \n     def get_yscale(self):\n         \"\"\"\n",
        "test_invert_log_axis.py": "new file mode 100644\nindex 0000000000..2119614ab0\nimport sys\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef main():\nprint(\"Running test_invert_log_axis.py\")\n# Create data and axis\ny = np.linspace(1000, 1, 5)\nwant_bottom, want_top = max(y), min(y)  # reversed\nprint(f\"Requested bottom={want_bottom}, top={want_top}\")\n\nfig, ax = plt.subplots()\nax.set_yscale(\"log\")\n# Attempt to invert by setting reversed limits\nax.set_ylim(want_bottom, want_top)\nfinal_bottom, final_top = ax.get_ylim()\nprint(f\"Resulting bottom={final_bottom}, top={final_top}\")\n\n# Check if the final axis is actually reversed\n# We allow some floating tolerance\nif np.isclose(final_bottom, want_bottom) and np.isclose(final_top, want_top):\nprint(\"SUCCESS: The y-axis is inverted in log scale as requested.\")\nsys.exit(0)\nelse:\nprint(\"FAILURE: The y-axis is NOT properly inverted in log scale.\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "lib/matplotlib/axes/_base.py": "             cbook._warn_external(\n                 f\"Attempting to set identical left == right == {left} results \"\n                 f\"in singular transformations; automatically expanding.\")\nswapped = left > right\n         left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n         left, right = self.xaxis.limit_range_for_scale(left, right)\nif swapped:\nleft, right = right, left\n \n         self.viewLim.intervalx = (left, right)\n         if auto is not None:\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\nswapped = bottom > top\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\nif swapped:\nbottom, top = top, bottom\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\n",
        "lib/matplotlib/ticker.py": "         return locs\n \n     def nonsingular(self, v0, v1):\n\"\"\"Expand a range as needed to avoid singularities.\"\"\"\nreturn mtransforms.nonsingular(v0, v1, expander=.05)\n \n     def view_limits(self, vmin, vmax):\n         \"\"\"\n",
        "lib/mpl_toolkits/mplot3d/axes3d.py": "             cbook._warn_external(\n                 f\"Attempting to set identical left == right == {left} results \"\n                 f\"in singular transformations; automatically expanding.\")\nswapped = left > right\n         left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n         left, right = self.xaxis.limit_range_for_scale(left, right)\nif swapped:\nleft, right = right, left\n         self.xy_viewLim.intervalx = (left, right)\n \n         if auto is not None:\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\nswapped = bottom > top\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\nif swapped:\nbottom, top = top, bottom\n         self.xy_viewLim.intervaly = (bottom, top)\n \n         if auto is not None:\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\nswapped = bottom > top\n         bottom, top = self.zaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.zaxis.limit_range_for_scale(bottom, top)\nif swapped:\nbottom, top = top, bottom\n         self.zz_viewLim.intervalx = (bottom, top)\n \n         if auto is not None:\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they accomplish different tasks and are not syntactically similar. The first sample contains a function `set_ylim` that sets the y-axis limits based on various checks and conditions for a log-scaled axis, while the second sample focuses on a different functionality, involving the x-axis with two different variables, `left` and `right`, and adjustments to make sure they are nonsingular. The logic, context, and variable purposes are entirely different, indicating they are distinct pieces of code.\"}"
}