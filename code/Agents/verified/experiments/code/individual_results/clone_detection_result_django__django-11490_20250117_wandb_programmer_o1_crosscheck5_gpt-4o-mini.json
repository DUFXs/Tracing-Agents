{
    "instance_id": "django__django-11490",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "compose_queries_bug_test.py": "new file mode 100644\nindex 0000000000..557c4bd6b2\nimport sys\nimport django\nfrom django.conf import settings\n\nif not settings.configured:\nsettings.configure(\nINSTALLED_APPS=[\n'django.contrib.contenttypes',\n'django.contrib.auth',\n'test_app.apps.TestAppConfig',\n],\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\nMIDDLEWARE=[],\n)\n\ndjango.setup()\n\nfrom django.core.management import call_command\nfrom test_app.models import TestReservedName\n\n# Create DB tables for this new model.\ncall_command('migrate', '--run-syncdb', verbosity=0)\n\nprint(\"Creating a TestReservedName instance ...\")\nTestReservedName.objects.create(name='a', order=2)\n\nqs1 = TestReservedName.objects.all()\n\nprint(\"Attempting first union with .values_list('name', 'order')\")\nresult1 = qs1.union(qs1).values_list('name', 'order').get()\nprint(\"Result1:\", result1)\n\nprint(\"Attempting second union with .values_list('order')\")\nresult2 = qs1.union(qs1).values_list('order').get()\nprint(\"Result2:\", result2)\n\n# If the bug is fixed, result2 should be (2,), i.e. only the \"order\" value\nif result2 == (2,):\nprint(\"Test passed: expected (2,) and got\", result2)\nsys.exit(0)\nelse:\nprint(\"Test failed: expected (2,) but got\", result2)\nsys.exit(1)\n",
        "django/db/models/sql/compiler.py": "index a44adfc760..484d709b8e 100644\n         parts = ()\n         for compiler in compilers:\n             try:\n# If the columns list is limited, then all combined queries must have\n# the same columns list. However, only overwrite the child's columns if\n# the child doesn't have columns yet or it has the same model.\nif self.query.values_select:\nchild_model = getattr(compiler.query, 'model', None)\nchild_has_columns = bool(compiler.query.values_select or compiler.query.annotation_select or compiler.query.extra_select)\nsame_model = child_model == self.query.model\nif not child_has_columns or same_model:\ncompiler.query.set_values((\n*self.query.extra_select,\n*self.query.values_select,\n*self.query.annotation_select,\n))\n                 part_sql, part_args = compiler.as_sql()\n                 if compiler.query.combinator:\n# Wrap in a subquery if wrapping in parentheses isn't supported.\n                     if not features.supports_parentheses_in_compound:\n                         part_sql = 'SELECT * FROM ({})'.format(part_sql)\n                     # Add parentheses when combining with compound query if not\n         for part in args_parts:\n             params.extend(part)\n         return result, params\n\n\n \n     def as_sql(self, with_limits=True, with_col_aliases=False):\n         \"\"\"\n",
        "test_app/__init__.py": "new file mode 100644\nindex 0000000000..c96b87b0cb\n# Empty init file to make this a valid Python package\n",
        "test_app/apps.py": "new file mode 100644\nindex 0000000000..d15f13972a\nfrom django.apps import AppConfig\n\nclass TestAppConfig(AppConfig):\nname = 'test_app'\n",
        "test_app/models.py": "new file mode 100644\nindex 0000000000..1fe88e1efd\nfrom django.db import models\n\nclass TestReservedName(models.Model):\nname = models.CharField(max_length=50)\norder = models.IntegerField()\n\nclass Meta:\napp_label = 'test_app'\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/compiler.py": "                 # must have the same columns list. Set the selects defined on\n                 # the query on all combined queries, if not already set.\n                 if not compiler.query.values_select and self.query.values_select:\ncompiler.query = compiler.query.clone()\n                     compiler.query.set_values((\n                         *self.query.extra_select,\n                         *self.query.values_select,\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share syntactical similarities in how they formulate database query handling in Django, but they also have added, modified, or removed statements, which makes them not completely identical.\"}"
}