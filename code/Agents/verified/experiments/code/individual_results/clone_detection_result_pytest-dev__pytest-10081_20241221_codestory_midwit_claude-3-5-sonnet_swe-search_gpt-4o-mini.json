{
    "instance_id": "pytest-dev__pytest-10081",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "reproduce_error.py": "new file mode 100644\nindex 000000000..74b8c5307\nimport unittest\n\n@unittest.skip(\"hello\")\nclass MyTestCase(unittest.TestCase):\ndef setUp(self):\nxxx\ndef test_one(self):\npass\ndef tearDown(self):\nxxx\n\nif __name__ == '__main__':\nimport pytest\npytest.main(['--pdb', __file__])\n\\ No newline at end of file\n",
        "src/_pytest/unittest.py": "index 851e4943b..63abde961 100644\n \n         assert self._testcase is not None\n \n# Check if the test or test class is skipped\nif _is_skipped(self._testcase) or _is_skipped(self.obj):\nreason = getattr(self._testcase, \"__unittest_skip_why__\", \"\") or getattr(self.obj, \"__unittest_skip_why__\", \"\")\nraise pytest.skip.Exception(reason, _use_item_location=True)\n\n         maybe_wrap_pytest_function_for_tracing(self)\n \n         # Let the unittest framework handle async functions.\n             # Arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed.\nif self.config.getoption(\"usepdb\"):\n                 self._explicit_tearDown = self._testcase.tearDown\n                 setattr(self._testcase, \"tearDown\", lambda *args: None)\n \n"
    },
    "ground_truth_patch": {
        "src/_pytest/unittest.py": "# Arguably we could always postpone tearDown(), but this changes the moment where the\n# TestCase instance interacts with the results object, so better to only do it\n# when absolutely needed.\n# We need to consider if the test itself is skipped, or the whole class.\nassert isinstance(self.parent, UnitTestCase)\nskipped = _is_skipped(self.obj) or _is_skipped(self.parent.obj)\nif self.config.getoption(\"usepdb\") and not skipped:\n    self._explicit_tearDown = self._testcase.tearDown\n    setattr(self._testcase, \"tearDown\", lambda *args: None)\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they are syntactically dissimilar and address different aspects of the unittest functionality. The first code sample contains a test case structure with setup and teardown methods, while the second sample involves logic for handling skipped tests within a pytest context. Therefore, they do not meet the criteria for any type of clones.\"}"
}