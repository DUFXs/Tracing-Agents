{
    "instance_id": "psf__requests-5414",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "requests/models.py": "index e7d292d5..4df8e033 100644\n             url = url.decode('utf8')\n         else:\n             url = unicode(url) if is_py2 else str(url)\n\n         # Remove leading whitespaces from url\n         url = url.lstrip()\n\n         # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n         # `data` etc to work around exceptions from `url_parse`, which\n         # handles RFC 3986 only.\n         if ':' in url and not url.lower().startswith('http'):\n             self.url = url\n             return\n\n         # Support for unicode domain names and paths.\n         try:\n             scheme, auth, host, port, path, query, fragment = parse_url(url)\n         except LocationParseError as e:\n             raise InvalidURL(*e.args)\n\n         if not scheme:\n             error = (\"Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?\")\n             error = error.format(to_native_string(url, 'utf8'))\n             raise MissingSchema(error)\n\n         if not host:\n             raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n\n         # In general, we want to try IDNA encoding the hostname if the string contains\n         # non-ASCII characters. This allows users to automatically get the correct IDNA\n         # behaviour. For strings containing only ASCII characters, we need to also verify\n                 raise InvalidURL('URL has an invalid label.')\n         elif host.startswith(u'*'):\n             raise InvalidURL('URL has an invalid label.')\n\n# Ensure we don't have an empty label (leading dot, double dot, etc.)\nif any(len(label) == 0 for label in host.split('.')):\nraise InvalidURL('URL has an invalid label.')\n\n         # Carefully reconstruct the network location\n         netloc = auth or ''\n         if netloc:\n         netloc += host\n         if port:\n             netloc += ':' + str(port)\n\n         # Bare domains aren't valid URLs.\n         if not path:\n             path = '/'\n\n         if is_py2:\n             if isinstance(scheme, str):\n                 scheme = scheme.encode('utf-8')\n                 query = query.encode('utf-8')\n             if isinstance(fragment, str):\n                 fragment = fragment.encode('utf-8')\n\n         if isinstance(params, (str, bytes)):\n             params = to_native_string(params)\n\n         enc_params = self._encode_params(params)\n         if enc_params:\n             if query:\n                 query = '%s&%s' % (query, enc_params)\n             else:\n                 query = enc_params\n\n         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))\n         self.url = url\n\n \n     def prepare_headers(self, headers):\n         \"\"\"Prepares the given HTTP headers.\"\"\"\n",
        "test_leading_dot_domain.py": "new file mode 100644\nindex 00000000..c1433211\n#!/usr/bin/env python\nimport sys\nimport traceback\nimport requests\n\ndef main():\nprint(\"Testing leading dot domain scenario: 'http://.example.com'\")\ntry:\nrequests.get(\"http://.example.com\")\nprint(\"FAIL: Did not raise an exception\")\nsys.exit(1)\nexcept requests.exceptions.InvalidURL:\nprint(\"PASS: Got InvalidURL as expected\")\nsys.exit(0)\nexcept Exception as e:\nprint(\"FAIL: Got exception other than InvalidURL:\", e)\ntraceback.print_exc()\nsys.exit(1)\n\nif __name__ == '__main__':\nmain()\n"
    },
    "ground_truth_patch": {
        "requests/models.py": "                 host = self._get_idna_encoded_host(host)\n             except UnicodeError:\n                 raise InvalidURL('URL has an invalid label.')\nelif host.startswith((u'*', u'.')):\n             raise InvalidURL('URL has an invalid label.')\n \n         # Carefully reconstruct the network location\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarity but have modified statements. The first sample is part of a larger code block dealing with the parsing and validation of URLs, while the second sample introduces the handling of the `host` variable with IDNA encoding and additional exception handling. Though both pieces of code relate to URL validation and error handling, the second sample includes different logic and structure related to the `host` variable, making them syntactically similar yet not identical.\"}"
}