{
    "instance_id": "pytest-dev__pytest-7571",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "reproduce_error.py": "new file mode 100644\nindex 000000000..568028dc1\nimport pytest\n\ndef test_foo(caplog):\nprint(\"Initial level:\", caplog.handler.level)\ncaplog.set_level(42)\nprint(\"After setting level:\", caplog.handler.level)\n\ndef test_bar(caplog):\nprint(\"Level in second test:\", caplog.handler.level)\n\\ No newline at end of file\n",
        "src/_pytest/logging.py": "index 11031f2f2..6de4f9772 100644\n     def __init__(self, item: nodes.Node) -> None:\n         \"\"\"Creates a new funcarg.\"\"\"\n         self._item = item\n# dict of log name -> (logger level, handler level)\nself._initial_logger_levels = {}  # type: Dict[Optional[str], Tuple[int, int]]\n \n     def _finalize(self) -> None:\n         \"\"\"Finalizes the fixture.\n         This restores the log levels changed by :meth:`set_level`.\n         \"\"\"\n         # restore log levels\nfor logger_name, (logger_level, handler_level) in self._initial_logger_levels.items():\n             logger = logging.getLogger(logger_name)\nlogger.setLevel(logger_level)\nself.handler.setLevel(handler_level)\n \n     @property\n     def handler(self) -> LogCaptureHandler:\n         \"\"\"\n         logger_obj = logging.getLogger(logger)\n         # save the original log-level to restore it during teardown\nself._initial_logger_levels.setdefault(logger, (logger_obj.level, self.handler.level))\n         logger_obj.setLevel(level)\n         self.handler.setLevel(level)\n \n"
    },
    "ground_truth_patch": {
        "src/_pytest/logging.py": "         \"\"\"Creates a new funcarg.\"\"\"\n         self._item = item\n         # dict of log name -> log level\nself._initial_handler_level = None  # type: Optional[int]\n         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n \n     def _finalize(self) -> None:\n         This restores the log levels changed by :meth:`set_level`.\n         \"\"\"\n         # restore log levels\nif self._initial_handler_level is not None:\nself.handler.setLevel(self._initial_handler_level)\n         for logger_name, level in self._initial_logger_levels.items():\n             logger = logging.getLogger(logger_name)\n             logger.setLevel(level)\n         # save the original log-level to restore it during teardown\n         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n         logger_obj.setLevel(level)\nself._initial_handler_level = self.handler.level\n         self.handler.setLevel(level)\n \n     @contextmanager\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarities with modifications. The structure of the functions and overall logic is similar, but there are added and modified statements in the second patch, such as the presence of 'self._initial_handler_level' and the context manager declaration without a corresponding declaration in the first patch.\"}"
}