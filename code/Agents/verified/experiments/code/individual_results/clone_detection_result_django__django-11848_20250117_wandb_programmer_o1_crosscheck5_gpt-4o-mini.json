{
    "instance_id": "django__django-11848",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/utils/http.py": "index 572cfb4347..0c54745b89 100644\n \n     Return an integer expressed in seconds since the epoch, in UTC.\n     \"\"\"\n     for regex in RFC1123_DATE, RFC850_DATE, ASCTIME_DATE:\n         m = regex.match(date)\n         if m is not None:\n         raise ValueError(\"%r is not in a valid HTTP date format\" % date)\n     try:\n         year = int(m.group('year'))\n# Dynamic pivot based on the current year to comply with RFC 7231.\nif 0 <= year <= 99:\nnow_year = datetime.datetime.utcnow().year\ntest_year = (now_year - (now_year % 100)) + year\n# If test_year is more than 50 years in the future, interpret it as the past.\nif test_year - now_year > 50:\ntest_year -= 100\nyear = test_year\n\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n         raise ValueError(\"%r is not a valid date\" % date) from exc\n \n \n\n def parse_http_date_safe(date):\n     \"\"\"\n     Same as parse_http_date, but return None if the input is invalid.\n",
        "test_parse_http_date_future.py": "new file mode 100644\nindex 0000000000..4c5390379f\nimport sys\nimport datetime\nfrom django.utils.http import parse_http_date\n\nclass MockDateTime(datetime.datetime):\n@classmethod\ndef utcnow(cls):\n# Force the 'current year' to 2017\nreturn cls(2017, 1, 1)\n\ndef main():\nprint(\"Testing parse_http_date's handling of two-digit year when current year is mocked to 2017.\")\n# Monkey patch datetime\nreal_datetime = datetime.datetime\ndatetime.datetime = MockDateTime\ntry:\n# RFC 850 date requires day of week to be 6-9 letters\ndate_str = \"Saturday, 27-May-68 09:13:12 GMT\"\nprint(f\"Parsing date: {date_str}\")\nparsed = parse_http_date(date_str)\ndt = datetime.datetime.utcfromtimestamp(parsed)\nprint(f\"Parsed to: {dt.isoformat()}\")\n# The code on HEAD interprets year=68 as 2068, which is 51 years after 2017\n# RFC 7231 says a 2-digit year more than 50 years in the future must be in the past\n# so it should be 1968, not 2068.\nif dt.year == 1968:\nprint(\"PASS: Correctly interpreted (1968).\")\nsys.exit(0)\nelse:\nprint(f\"FAIL: Returned year={dt.year}, expected 1968 per RFC 7231.\")\nsys.exit(1)\nfinally:\n# Restore real datetime\ndatetime.datetime = real_datetime\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/utils/http.py": "     try:\n         year = int(m.group('year'))\n         if year < 100:\ncurrent_year = datetime.datetime.utcnow().year\ncurrent_century = current_year - (current_year % 100)\nif year - (current_year % 100) > 50:\n# year that appears to be more than 50 years in the future are\n# interpreted as representing the past.\nyear += current_century - 100\n             else:\nyear += current_century\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they are syntactically similar but have differences in implementation. The logic for handling the year is rewritten with different condition checks and variable assignments, but the overall structure and intent remain similar.\"}"
}