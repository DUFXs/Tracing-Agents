{
    "instance_id": "django__django-13741",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/contrib/auth/forms.py": "index b9eb33329f..9a6614a809 100644\n \n     def __init__(self, *args, **kwargs):\n         kwargs.setdefault(\"required\", False)\nkwargs.setdefault(\"disabled\", True)\n         super().__init__(*args, **kwargs)\n \n     def bound_data(self, data, initial):\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..13accee69b\nimport os\nimport django\nfrom django.conf import settings\nfrom django.core.management import call_command\n\n# Configure Django settings\nif not settings.configured:\nsettings.configure(\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\nINSTALLED_APPS=[\n'django.contrib.auth',\n'django.contrib.contenttypes',\n],\nSECRET_KEY='dummy-key-for-tests',\n)\ndjango.setup()\n# Run migrations\ncall_command('migrate', verbosity=0)\n\nfrom django.contrib.auth.forms import UserChangeForm, ReadOnlyPasswordHashField\nfrom django.contrib.auth.models import User\n\n# Create a custom form without clean_password to demonstrate the issue\nclass CustomUserChangeForm(UserChangeForm):\nclass Meta:\nmodel = User\nfields = ('username', 'password')\n\ndef main():\n# Create a test user\nuser = User.objects.create_user(username='testuser', password='testpass123')\n\n# Create form instance with the user\nform = CustomUserChangeForm(instance=user)\n\n# Check if the password field is disabled\npassword_field = form.fields['password']\nprint(f\"Is password field disabled? {getattr(password_field, 'disabled', False)}\")\n\n# Try to submit form with modified password\ndata = {\n'username': 'testuser',\n'password': 'modified_password'\n}\nform = CustomUserChangeForm(data, instance=user)\n\nif form.is_valid():\nprint(\"Form is valid\")\n# Get the actual password value that would be saved\npassword_value = form.cleaned_data.get('password')\nprint(f\"Password value that would be saved: {password_value}\")\n# This should be the initial value, not the modified one\nelse:\nprint(\"Form is invalid\")\nprint(\"Errors:\", form.errors)\n\nif __name__ == '__main__':\nmain()\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/contrib/auth/forms.py": " \n     def __init__(self, *args, **kwargs):\n         kwargs.setdefault(\"required\", False)\nkwargs.setdefault('disabled', True)\n         super().__init__(*args, **kwargs)\n \n \n class UsernameField(forms.CharField):\n     def to_python(self, value):\n         if user_permissions:\n             user_permissions.queryset = user_permissions.queryset.select_related('content_type')\n \n \n class AuthenticationForm(forms.Form):\n     \"\"\"\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they have different structures and functionalities. Code sample 1 primarily focuses on a custom user change form using Django's forms, while code sample 2 includes different class definitions (UsernameField and AuthenticationForm) and lacks the context of the first sample, suggesting functionality that is unrelated to the specific task of modifying user forms. There is no syntactical similarity or functionality that aligns between the two samples.\"}"
}