{
    "instance_id": "django__django-12713",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/contrib/admin/options.py": "index 69a5fbf389..61d1ffeae3 100644\n         if not db_field.remote_field.through._meta.auto_created:\n             return None\n         db = kwargs.get('using')\n\n         autocomplete_fields = self.get_autocomplete_fields(request)\nif 'widget' not in kwargs:\nif db_field.name in autocomplete_fields:\nkwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\nelif db_field.name in self.raw_id_fields:\nkwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\nelif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\nkwargs['widget'] = widgets.FilteredSelectMultiple(\ndb_field.verbose_name,\ndb_field.name in self.filter_vertical\n)\n\n         if 'queryset' not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n             if queryset is not None:\n                 kwargs['queryset'] = queryset\n\n         form_field = db_field.formfield(**kwargs)\nif (\nisinstance(form_field.widget, SelectMultiple) and\nnot isinstance(form_field.widget, (CheckboxSelectMultiple, AutocompleteSelectMultiple))\n):\n             msg = _('Hold down \u201cControl\u201d, or \u201cCommand\u201d on a Mac, to select more than one.')\n             help_text = form_field.help_text\n             form_field.help_text = format_lazy('{} {}', help_text, msg) if help_text else msg\n         return form_field\n\n \n     def get_autocomplete_fields(self, request):\n         \"\"\"\n",
        "test_widget_override_m2m.py": "new file mode 100644\nindex 0000000000..553c6ca1e4\n#!/usr/bin/env python3\nimport sys\nprint(\"Step: Starting the widget override test for many-to-many fields.\")\n\ntry:\nimport django\nfrom django.conf import settings\nfrom django.db import models\nfrom django import forms\nfrom django.contrib import admin\n\n# Configure minimal Django settings using only built-in apps.\nsettings.configure(\nINSTALLED_APPS=[\n'django.contrib.admin',\n'django.contrib.auth',\n'django.contrib.contenttypes',\n],\nDATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\nSECRET_KEY='testsecretkey',\nMIDDLEWARE=[],\nROOT_URLCONF=None,\n)\ndjango.setup()\n\nclass Tag(models.Model):\nname = models.CharField(max_length=50)\n\nclass Meta:\n# Use a built-in label to avoid importing a missing package.\napp_label = 'admin'\nmanaged = False\n\nclass Article(models.Model):\ntitle = models.CharField(max_length=50)\ntags = models.ManyToManyField(Tag)\n\nclass Meta:\napp_label = 'admin'\nmanaged = False\n\nclass ArticleAdmin(admin.ModelAdmin):\nfilter_horizontal = ('tags',)\n\ndef formfield_for_manytomany(self, db_field, request, **kwargs):\nif db_field.name == 'tags':\nprint(\"Step: Overriding widget in formfield_for_manytomany.\")\nkwargs['widget'] = forms.CheckboxSelectMultiple\nreturn super().formfield_for_manytomany(db_field, request, **kwargs)\n\n# Instantiate the admin and retrieve the form field for 'tags'.\nadmin_site = admin.AdminSite()\ntest_admin = ArticleAdmin(Article, admin_site)\nfield = test_admin.formfield_for_manytomany(Article._meta.get_field('tags'), request=None)\n\nactual_widget_type = type(field.widget)\nintended_widget_type = forms.CheckboxSelectMultiple\nprint(f\"Step: The final widget is {actual_widget_type}, intended is {intended_widget_type}.\")\n\nif actual_widget_type is not intended_widget_type:\nprint(\"Result: FAIL (the widget override was lost). Exiting with status 1.\")\nsys.exit(1)\nelse:\nprint(\"Result: PASS (the widget override was preserved). Exiting with status 0.\")\nsys.exit(0)\n\nexcept Exception as e:\nprint(\"An unexpected exception occurred:\")\nimport traceback\ntraceback.print_exc()\nprint(\"Result: ERROR. Exiting with status 2.\")\nsys.exit(2)\n"
    },
    "ground_truth_patch": {
        "django/contrib/admin/options.py": "             return None\n         db = kwargs.get('using')\n \nif 'widget' not in kwargs:\nautocomplete_fields = self.get_autocomplete_fields(request)\nif db_field.name in autocomplete_fields:\nkwargs['widget'] = AutocompleteSelectMultiple(\ndb_field.remote_field,\nself.admin_site,\nusing=db,\n)\nelif db_field.name in self.raw_id_fields:\nkwargs['widget'] = widgets.ManyToManyRawIdWidget(\ndb_field.remote_field,\nself.admin_site,\nusing=db,\n)\nelif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\nkwargs['widget'] = widgets.FilteredSelectMultiple(\ndb_field.verbose_name,\ndb_field.name in self.filter_vertical\n)\n         if 'queryset' not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n             if queryset is not None:\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for differences in whitespace, layout, and the presence of comments. The core logic and structure of both samples are the same.\"}"
}