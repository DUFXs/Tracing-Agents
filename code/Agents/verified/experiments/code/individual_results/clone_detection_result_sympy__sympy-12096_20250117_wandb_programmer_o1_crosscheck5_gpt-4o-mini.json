{
    "instance_id": "sympy__sympy-12096",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "sympy/core/function.py": "index 1b8005e1d2..1d4256a22f 100644\n             return False\n \n     def _eval_evalf(self, prec):\n# Only evaluate if all args are numeric\nif not all(a.is_number for a in self.args):\nreturn None\n\n         fname = self.func.__name__\n         try:\n             if not hasattr(mpmath, fname):\n             func = getattr(mpmath, fname)\n         except (AttributeError, KeyError):\n             try:\nimp_val = self._imp_(*self.args)\nif isinstance(imp_val, Basic):\nreturn imp_val.evalf(prec)\nelse:\nreturn Float(imp_val, prec)\n             except (AttributeError, TypeError, ValueError):\n                 return\n\n# Convert all args to mpf or mpc at higher precision\n         try:\n             args = [arg._to_mpmath(prec + 5) for arg in self.args]\n             def bad(m):\n                 from mpmath import mpf, mpc\n                 if isinstance(m, mpf):\n                     m = m._mpf_\nreturn m[1] != 1 and m[-1] == 1\n                 elif isinstance(m, mpc):\n                     m, n = m._mpc_\nreturn (m[1] != 1 and m[-1] == 1 and\nn[1] != 1 and n[-1] == 1)\n                 else:\n                     return False\n             if any(bad(a) for a in args):\nraise ValueError\n         except ValueError:\n             return\n\n         with mpmath.workprec(prec):\n             v = func(*args)\n\n         return Expr._from_mpmath(v, prec)\n\n\n \n     def _eval_derivative(self, s):\n         # f(x).diff(s) -> x.diff(s) * f.fdiff(1)(s)\n",
        "test_evalf_implemented_recursive.py": "new file mode 100644\nindex 0000000000..e6fe57a14d\nimport sys\nfrom sympy.utilities.lambdify import implemented_function\nfrom sympy import Symbol\n\nprint(\"Reproduction test for evalf not recursing on _imp_.\")\nx = Symbol(\"x\")\nf = implemented_function(\"f\", lambda u: u**2)\ng = implemented_function(\"g\", lambda u: 2*u)\n\nval = f(g(2)).evalf()\nprint(f\"f(g(2)) = {val}\")\nprint(\"Expected numeric 16. Checking...\")\n\nif val != 16:\nprint(f\"TEST FAILED: expected 16, got {val}\")\nsys.exit(1)\nprint(\"TEST PASSED!\")\nsys.exit(0)\n"
    },
    "ground_truth_patch": {
        "sympy/core/function.py": "             func = getattr(mpmath, fname)\n         except (AttributeError, KeyError):\n             try:\nreturn Float(self._imp_(*[i.evalf(prec) for i in self.args]), prec)\n             except (AttributeError, TypeError, ValueError):\n                 return\n \n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarity but have differences in the implementation of statements. For example, the first sample has a more elaborate structure and additional handling of arguments, while the second sample simplifies one of the return statements and modifies how arguments are passed to the function. They both relate to evaluating and returning results based on the function attributes but are not identical.\"}"
}