{
    "instance_id": "django__django-12708",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "django/db/backends/base/schema.py": "index 61f88401ab..39ab614c01 100644\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n# Filter for index-type constraints only when deleting an index\nif constraint_kwargs.get('index'):\nconstraint_names = [name for name in constraint_names if name.endswith('_idx')]\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\n             'param_types': ','.join(param_types),\n         }\n         self.execute(sql)\n\n",
        "reproduce_issue.py": "new file mode 100644\nindex 0000000000..196d4a06dc\nfrom django.db import models\nfrom django.db import migrations\nfrom django.db.backends.base.schema import BaseDatabaseSchemaEditor\nfrom django.db.migrations.state import ProjectState\nfrom django.db.backends.sqlite3.base import DatabaseWrapper\nfrom django.conf import settings\nimport django\n\n# Configure Django settings\nif not settings.configured:\nsettings.configure(\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n'TIME_ZONE': None,\n'CONN_MAX_AGE': 0,\n'OPTIONS': {},\n'AUTOCOMMIT': True,\n}\n},\nINSTALLED_APPS=['django.contrib.contenttypes'],\nDEFAULT_AUTO_FIELD='django.db.models.AutoField',\nTIME_ZONE=None,\nUSE_TZ=False,\n)\ndjango.setup()\n\n# Create a test model class\nclass TestModel(models.Model):\nfield1 = models.CharField(max_length=100)\nfield2 = models.CharField(max_length=100)\n\nclass Meta:\napp_label = 'testapp'\ndb_table = 'test_model'\n\n# Create schema editor\nconnection = DatabaseWrapper({\n'NAME': ':memory:',\n'TIME_ZONE': None,\n'CONN_MAX_AGE': 0,\n'OPTIONS': {},\n'AUTOCOMMIT': True,\n'ENGINE': 'django.db.backends.sqlite3',\n})\nschema_editor = BaseDatabaseSchemaEditor(connection)\n\n# Create tables\nschema_editor.execute(\"\"\"\nCREATE TABLE test_model (\nid INTEGER PRIMARY KEY AUTOINCREMENT,\nfield1 varchar(100) NOT NULL,\nfield2 varchar(100) NOT NULL\n)\n\"\"\")\n\n# Create unique constraint\nschema_editor.execute(\"\"\"\nCREATE UNIQUE INDEX test_model_field1_field2_uniq \nON test_model(field1, field2)\n\"\"\")\n\n# Create index\nschema_editor.execute(\"\"\"\nCREATE INDEX test_model_field1_field2_idx \nON test_model(field1, field2)\n\"\"\")\n\n# Now try to delete just the index\ntry:\n# This should trigger the bug because _delete_composed_index will find both\n# the unique constraint and the index\nschema_editor._delete_composed_index(\nTestModel,\n('field1', 'field2'),\n{'index': True},\nschema_editor.sql_delete_index\n)\nexcept ValueError as e:\nprint(f\"Error occurred: {e}\")\n\n"
    },
    "ground_truth_patch": {
        "django/db/backends/base/schema.py": "         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\nself._delete_composed_index(\nmodel,\nfields,\n{'index': True, 'unique': False},\nself.sql_delete_index,\n)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n"
    },
    "response": "{\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they are syntactically dissimilar and do not share a functional equivalence in their logic. The first sample deals with setting up database models and executing SQL commands, while the second sample focuses on index management directly related to existing indexes. The structure and purpose of the code are distinctly different, indicating that they do not fit any clone classification.\"}"
}