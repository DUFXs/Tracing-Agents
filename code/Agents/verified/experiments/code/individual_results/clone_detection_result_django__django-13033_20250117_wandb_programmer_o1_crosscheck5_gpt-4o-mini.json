{
    "instance_id": "django__django-13033",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/sql/compiler.py": "index abbb1e37cb..3bd467858f 100644\n                     params.append(p)\n         return result, params\n \ndef find_ordering_name(self, name, opts, alias=None, default_order='ASC', already_seen=None):\n         name, order = get_order_dir(name, default_order)\ndescending = (order == 'DESC')\n         pieces = name.split(LOOKUP_SEP)\n         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)\n\n         # If we get to this point and the field is a relation to another model,\n# append the default ordering for that model unless it is the pk or\n# the actual column attname (meaning the user wants the raw column).\nlast_piece = pieces[-1]\nif field.is_relation and opts.ordering and last_piece != getattr(field, 'attname', None) and name != 'pk':\n# Avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\n             if join_tuple in already_seen:\n                 raise FieldError('Infinite loop caused by ordering.')\n             already_seen.add(join_tuple)\n\n             results = []\n             for item in opts.ordering:\n                 if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):\n                 if isinstance(item, OrderBy):\n                     results.append((item, False))\n                     continue\nresults.extend(self.find_ordering_name(item, opts, alias, order, already_seen))\n             return results\n\n# Otherwise, just order by this column (or columns).\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\nreturn [\n(OrderBy(transform_function(t, alias), descending=descending), False)\nfor t in targets\n]\n\n \n     def _setup_joins(self, pieces, opts, alias):\n         \"\"\"\n",
        "test_self_ref_bug.py": "new file mode 100644\nindex 0000000000..5dab723f94\n#!/usr/bin/env python3\n\nimport sys\nimport django\nfrom django.conf import settings\nfrom django.db import models, connection\n\ndef setup_django():\nif not settings.configured:\nsettings.configure(\nDEBUG=True,\nUSE_TZ=False,\nSECRET_KEY=\"testkey\",\nDATABASES={\n\"default\": {\n\"ENGINE\": \"django.db.backends.sqlite3\",\n\"NAME\": \":memory:\",  # Use in-memory DB to avoid leftover tables\n}\n},\nINSTALLED_APPS=[\"django.contrib.contenttypes\"],  # minimal needed\n)\ndjango.setup()\n\ndef main():\nprint(\"Setting up Django environment...\")\nsetup_django()\n\nprint(\"Defining ephemeral models post-setup...\")\n\nclass OneModel(models.Model):\nclass Meta:\napp_label = \"test_app\"\nordering = (\"-id\",)\nid = models.BigAutoField(primary_key=True)\nroot = models.ForeignKey(\"OneModel\", on_delete=models.CASCADE, null=True)\noneval = models.BigIntegerField(null=True)\n\nclass TwoModel(models.Model):\nclass Meta:\napp_label = \"test_app\"\nid = models.BigAutoField(primary_key=True)\nrecord = models.ForeignKey(OneModel, on_delete=models.CASCADE)\ntwoval = models.BigIntegerField(null=True)\n\nprint(\"Creating tables using schema_editor...\")\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(OneModel)\nschema_editor.create_model(TwoModel)\n\nprint(\"Creating test data...\")\nroot1 = OneModel.objects.create(oneval=1)\nroot2 = OneModel.objects.create(oneval=2)\nchild1 = OneModel.objects.create(oneval=3, root=root1)\nchild2 = OneModel.objects.create(oneval=3, root=root2)\nTwoModel.objects.create(twoval=10, record=root1)\nTwoModel.objects.create(twoval=20, record=child1)\nTwoModel.objects.create(twoval=30, record=root2)\nTwoModel.objects.create(twoval=40, record=child2)\n\nprint(\"Running the test query that exhibits unexpected DESC ordering from self-ref FK:\")\nqs = TwoModel.objects.filter(record__oneval__in=[1,2,3]).order_by(\"record__root_id\")\nactual_sql = str(qs.query)\nprint(\"Compiled SQL:\\n\", actual_sql)\n\n# If the bug is present, we'll see T3.\"id\" DESC or T3.id DESC in the final ordering.\nif \"T3.\\\"id\\\" DESC\" in actual_sql or \"T3.id DESC\" in actual_sql:\nprint(\"FAIL: Found unexpected DESC for T3.id in SQL!\")\nprint(\"Test script is failing (or still pathing incorrectly).\")\nsys.exit(1)\nelse:\nprint(\"PASS: Did not find the unexpected DESC ordering for T3.id. Possibly fixed.\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n",
        "test_self_ref_bug_db.sqlite3": "new file mode 100644\nindex 0000000000..825d6935e9\nBinary files /dev/null and b/test_self_ref_bug_db.sqlite3 differ\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/compiler.py": "# If we get to this point and the field is a relation to another model,\n# append the default ordering for that model unless it is the pk\n# shortcut or the attribute name of the field that is specified.\nif (\n    field.is_relation\n    and opts.ordering\n    and getattr(field, \"attname\", None) != pieces[-1]\n    and name != \"pk\"\n):\n    # Firstly, avoid infinite loops.\n    already_seen = already_seen or set()\n    join_tuple = tuple(\n        getattr(self.query.alias_map[j], \"join_cols\", None) for j in joins\n    )\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-2\", \"reasoning\": \"These code samples are type-2 clones because they are identical in logic and structure but have differences in literal values and syntax. The first sample uses single quotes and several variable names and layout formatting that differ from the second sample which employs double quotes and a slightly different structure.\"}"
}