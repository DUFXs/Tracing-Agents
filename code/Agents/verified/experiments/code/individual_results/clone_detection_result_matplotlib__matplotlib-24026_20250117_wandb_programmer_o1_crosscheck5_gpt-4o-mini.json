{
    "instance_id": "matplotlib__matplotlib-24026",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "lib/matplotlib/stackplot.py": "index c580043eeb..ca05fe5e75 100644\n \n import numpy as np\n \nimport matplotlib.colors as mcolors\n\n\n\n from matplotlib import _api\n \n __all__ = ['stackplot']\n     baseline : {'zero', 'sym', 'wiggle', 'weighted_wiggle'}\n         Method used to calculate the baseline:\n \n- 'zero': Constant zero baseline, i.e. a simple stacked plot.\n- 'sym':  Symmetric around zero and is sometimes called\n           'ThemeRiver'.\n- 'wiggle': Minimizes the sum of the squared slopes.\n- 'weighted_wiggle': Does the same but weights to account for\n           size of each layer. It is also called 'Streamgraph'-layout. More\n           details can be found at http://leebyron.com/streamgraph/.\n \n         DATA_PARAMETER_PLACEHOLDER\n \n     **kwargs\nAll other keyword arguments are passed to .Axes.fill_between.\n \n     Returns\n     -------\nlist of .PolyCollection\nA list of .PolyCollection instances, one for each element in the\n         stacked area plot.\n     \"\"\"\nimport numpy as np\nfrom matplotlib import _api\n \n     y = np.row_stack(args)\n \n     labels = iter(labels)\n     if colors is not None:\ntry:\ncolors = mcolors.to_rgba_array(colors)\nexcept ValueError as e:\nraise ValueError(\nf\"Could not convert one or more entries in 'colors' \"\nf\"to a valid RGBA color: {colors}\"\n) from e\n         axes.set_prop_cycle(color=colors)\n \n     # Assume data passed has not been 'stacked', so stack it here.\n     stack = np.cumsum(y, axis=0, dtype=np.promote_types(y.dtype, np.float32))\n \n     _api.check_in_list(['zero', 'sym', 'wiggle', 'weighted_wiggle'],\n \n     elif baseline == 'weighted_wiggle':\n         total = np.sum(y, 0)\n         inv_total = np.zeros_like(total)\n         mask = total > 0\n         inv_total[mask] = 1.0 / total[mask]\n         first_line = center - 0.5 * total\n         stack += first_line\n \n     color = axes._get_lines.get_next_color()\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=color, label=next(labels, None),\n     coll.sticky_edges.y[:] = [0]\n     r = [coll]\n \n     for i in range(len(y) - 1):\n         color = axes._get_lines.get_next_color()\nr.append(\naxes.fill_between(\nx, stack[i, :], stack[i + 1, :],\nfacecolor=color, label=next(labels, None),\n**kwargs\n)\n)\n     return r\n\n",
        "test_stackplot_color_alias.py": "new file mode 100644\nindex 0000000000..05b1e07750\nimport sys\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nimport numpy as np\n\ndef main():\nprint(\"Reproducing the stackplot color alias bug with 'C2','C3','C4'...\")\nmy_data = np.array([[1, 1, 1],\n[1, 2, 3],\n[4, 3, 2]])\nfig, ax = plt.subplots()\n# Use 'C0' for line\nax.plot([1, 3], [1, 3], color='C0')\n# Use 'C1' for rectangle patch\nax.add_patch(Rectangle(xy=(1.5, 1.5), width=0.5, height=0.5, facecolor='C1'))\n# Trigger the bug by using colors=['C2','C3','C4']\ntry:\nax.stackplot([1, 2, 3], my_data, colors=['C2', 'C3', 'C4'])\n# If no error is raised, print success; otherwise, fail.\nprint(\"No error raised. This indicates the issue is fixed.\")\nsys.exit(0)\nexcept Exception as e:\nprint(\"Caught an exception (expected on HEAD).\")\nprint(\"Exception was:\", e)\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "lib/matplotlib/stackplot.py": " (https://stackoverflow.com/users/66549/doug)\n \"\"\"\n \nimport itertools\n\n import numpy as np\n \n from matplotlib import _api\n \n     labels = iter(labels)\n     if colors is not None:\ncolors = itertools.cycle(colors)\nelse:\ncolors = (axes._get_lines.get_next_color() for _ in y)\n \n     # Assume data passed has not been 'stacked', so stack it here.\n     # We'll need a float buffer for the upcoming calculations.\n         stack += first_line\n \n     # Color between x = 0 and the first array.\n     coll = axes.fill_between(x, first_line, stack[0, :],\nfacecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n     coll.sticky_edges.y[:] = [0]\n     r = [coll]\n \n     # Color between array i-1 and array i\n     for i in range(len(y) - 1):\n         r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],\nfacecolor=next(colors),\nlabel=next(labels, None),\n                                    **kwargs))\n     return r\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they have similar structures and logic, but they include modifications to variable names, the logic flow (like the way colors are handled), and additional comments. They represent syntactically similar code with added or modified statements, particularly in how colors are iterated or accessed.\"}"
}