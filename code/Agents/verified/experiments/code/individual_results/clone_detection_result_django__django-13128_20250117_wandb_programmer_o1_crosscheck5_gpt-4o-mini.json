{
    "instance_id": "django__django-13128",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/expressions.py": "index d913658291..90d3f6b6b7 100644\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n         c = self.copy()\n         c.is_summary = summarize\n# Resolve subexpressions first.\n         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n# Only attempt to convert to TemporalSubtraction if we're really a CombinedExpression,\n# not a subclass like TemporalSubtraction, to avoid infinite recursion.\nif type(self) is CombinedExpression:\ntry:\nlhs_type = c.lhs.output_field.get_internal_type()\nrhs_type = c.rhs.output_field.get_internal_type()\nexcept (AttributeError, FieldError):\nreturn c\ndatetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\nif c.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\n# Return a TemporalSubtraction that also has its subexpressions resolved.\nreturn TemporalSubtraction(c.lhs, c.rhs).resolve_expression(query, allow_joins, reuse, summarize, for_save)\n         return c\n\n\n \n \n class DurationExpression(CombinedExpression):\n         rhs = compiler.compile(self.rhs)\n         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)\n \ndef get_source_expressions(self):\n# Don\u2019t expose datetime subexpressions so unification sees only DurationField.\nreturn []\n\ndef get_source_fields(self):\n# Temporally subtracting two datetime fields yields a duration.\nreturn [self.output_field]\n\n\n\n \n @deconstructible\n class F(Combinable):\n",
        "migrations/0001_initial.py": "new file mode 100644\nindex 0000000000..c92ae068c6\n# Generated by Django 3.2 on 2025-01-13 04:36\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\ninitial = True\n\ndependencies = [\n]\n\noperations = [\nmigrations.CreateModel(\nname='Experiment',\nfields=[\n('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n('start', models.DateTimeField()),\n('end', models.DateTimeField()),\n],\n),\n]\n",
        "migrations/__init__.py": "new file mode 100644\nindex 0000000000..e69de29bb2\n",
        "test_temporal_subtraction_bug.py": "new file mode 100644\nindex 0000000000..8cd35cf8b3\nimport sys\nimport datetime\nfrom django.conf import settings\nfrom django.db import models, connection\nfrom django import setup\n\ndef main():\nprint(\"Setting up Django in-memory test for temporal subtraction bug.\")\nsettings.configure(\nINSTALLED_APPS=[\"__main__\"],\nDATABASES={\"default\": {\"ENGINE\": \"django.db.backends.sqlite3\", \"NAME\": \":memory:\"}},\nSECRET_KEY=\"abc123\",\n)\nsetup()\n\nclass Experiment(models.Model):\nstart = models.DateTimeField()\nend = models.DateTimeField()\nclass Meta:\napp_label = \"__main__\"\n\nprint(\"Creating table for Experiment model via schema_editor...\")\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(Experiment)\n\ntry:\nprint(\"Creating data and running problematic query...\")\ne = Experiment.objects.create(\nstart=datetime.datetime(2023, 1, 1, 12, 0, 0),\nend=datetime.datetime(2023, 1, 1, 14, 30, 0),\n)\nfrom django.db.models import F, Value, DurationField\nqs = Experiment.objects.annotate(\ndelta=F(\"end\") - F(\"start\") + Value(datetime.timedelta(), output_field=DurationField())\n)\nresults = list(qs)\nfor obj in results:\nprint(f\"experiment ID={obj.id}, delta={obj.delta}\")\nprint(\"No FieldError encountered. Test passes => bug is fixed.\")\nsys.exit(0)\nexcept Exception as ex:\nprint(f\"Error encountered: {ex}\")\nprint(\"Bug present => test fails.\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/models/expressions.py": "         self.lhs, self.rhs = exprs\n \n     def as_sql(self, compiler, connection):\n         expressions = []\n         expression_params = []\n         sql, params = compiler.compile(self.lhs)\n         return expression_wrapper % sql, expression_params\n \n     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\nlhs = self.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\nrhs = self.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\nif not isinstance(self, (DurationExpression, TemporalSubtraction)):\ntry:\nlhs_type = lhs.output_field.get_internal_type()\nexcept (AttributeError, FieldError):\nlhs_type = None\ntry:\nrhs_type = rhs.output_field.get_internal_type()\nexcept (AttributeError, FieldError):\nrhs_type = None\nif 'DurationField' in {lhs_type, rhs_type} and lhs_type != rhs_type:\nreturn DurationExpression(self.lhs, self.connector, self.rhs).resolve_expression(\nquery, allow_joins, reuse, summarize, for_save,\n)\ndatetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\nif self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\nreturn TemporalSubtraction(self.lhs, self.rhs).resolve_expression(\nquery, allow_joins, reuse, summarize, for_save,\n)\n         c = self.copy()\n         c.is_summary = summarize\nc.lhs = lhs\nc.rhs = rhs\n         return c\n \n \n         return compiler.compile(side)\n \n     def as_sql(self, compiler, connection):\nif connection.features.has_native_duration_field:\nreturn super().as_sql(compiler, connection)\n         connection.ops.check_expression_support(self)\n         expressions = []\n         expression_params = []\n"
    },
    "response": "{\"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarities but have added, modified, or removed statements. Both samples revolve around resolving expressions in a Django context, with function signatures and some logic appearing similar, but certain statements and structures have been changed, indicating that they are not identical.\"}"
}