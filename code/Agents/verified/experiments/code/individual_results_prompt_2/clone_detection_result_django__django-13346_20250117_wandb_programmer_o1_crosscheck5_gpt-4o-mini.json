{
    "instance_id": "django__django-13346",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/fields/json.py": "index fafc1beee8..68df0bc5b1 100644\n class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):\n     pass\n \nclass KeyTransformIn(lookups.In):\ncan_use_none_as_rhs = True\n\ndef process_lhs(self, compiler, connection):\nlhs, lhs_params = super().process_lhs(compiler, connection)\n# For SQLite or other backends, we can add special-case logic for null if needed.\nreturn lhs, lhs_params\n\ndef process_rhs(self, compiler, connection):\nimport json\nrhs, rhs_params = super().process_rhs(compiler, connection)\n# Treat None as 'null' for consistency with JSONExact.\nif rhs == '%s' and rhs_params == [None]:\nrhs_params = ['null']\n\n# MySQL: Wrap each param in JSON_EXTRACT(...).\nif connection.vendor == 'mysql':\nfunc = [\"JSON_EXTRACT(%s, '$')\"] * len(rhs_params)\nrhs = rhs % tuple(func)\n\n# Oracle: Convert each param into JSON_QUERY(...) or JSON_VALUE(...), same pattern as KeyTransformExact\nelif connection.vendor == 'oracle':\nfunc = []\nfor value in rhs_params:\nif value == 'null':\nval = None\nelse:\nval = json.loads(value)\nfunction = 'JSON_QUERY' if isinstance(val, (list, dict)) else 'JSON_VALUE'\njson_data = json.dumps({'value': val})\nfunc.append(\"%s('%s', '$.value')\" % (function, json_data))\nrhs = rhs % tuple(func)\nrhs_params = []\n\n# SQLite: Use JSON_EXTRACT for non-null values, matching KeyTransformExact.\nelif connection.vendor == 'sqlite':\nfunc = [\"JSON_EXTRACT(%s, '$')\" if param != 'null' else '%s' for param in rhs_params]\nrhs = rhs % tuple(func)\n\nreturn rhs, rhs_params\n\ndef as_oracle(self, compiler, connection):\n# Handle the special case of a single 'null' in the IN list just as KeyTransformExact does.\nrhs, rhs_params = super().process_rhs(compiler, connection)\nif rhs_params == ['null']:\n# Field has key and it's NULL.\nhas_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)\nhas_key_sql, has_key_params = has_key_expr.as_oracle(compiler, connection)\nis_null_expr = self.lhs.get_lookup('isnull')(self.lhs, True)\nis_null_sql, is_null_params = is_null_expr.as_sql(compiler, connection)\nreturn (\n'%s AND %s' % (has_key_sql, is_null_sql),\ntuple(has_key_params) + tuple(is_null_params),\n)\nreturn super().as_sql(compiler, connection)\n\n\nKeyTransform.register_lookup(KeyTransformIn)\n\n\n\n \n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n",
        "test_json_key_transform_in.py": "new file mode 100644\nindex 0000000000..921c13cc7b\nimport sys\nimport json\nimport django\nfrom django.conf import settings\nfrom django.db import models, connection\n\ndef main():\nprint(\"Step 1: Configure settings.\")\nsettings.configure(\nDEBUG=True,\nSECRET_KEY=\"testsecret\",\nDATABASES={\n\"default\": {\n\"ENGINE\": \"django.db.backends.sqlite3\",\n\"NAME\": \":memory:\",\n}\n},\nINSTALLED_APPS=[\n\"django.contrib.contenttypes\",\n],\n)\n\nprint(\"Step 2: Setup Django.\")\ndjango.setup()\n\nprint(\"Step 3: Define inline model with JSONField, pointing to contenttypes as the app_label.\")\nclass OurModel(models.Model):\nour_field = models.JSONField()\n\nclass Meta:\napp_label = \"contenttypes\"\ndb_table = \"testjson_ourmodel\"\nmanaged = False\n\nprint(\"Step 4: Create table via schema_editor.\")\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(OurModel)\n\nprint(\"Step 5: Insert sample objects where our_field.key = 0.\")\ninsert_sql = \"INSERT INTO testjson_ourmodel (our_field) VALUES (%s)\"\nfor _ in range(312):\nwith connection.cursor() as cursor:\ncursor.execute(insert_sql, (json.dumps({\"key\": 0}),))\n\nprint(\"Step 6: Run the two filters to see if the 'in' lookup uses KeyTransformIn properly.\")\nfirst_items = OurModel.objects.filter(our_field__key__in=[0])\nlen_first = len(first_items)\nprint(f\"len_first={len_first}\")\n\nsecond_items = OurModel.objects.filter(our_field__key=0)\nlen_second = len(second_items)\nprint(f\"len_second={len_second}\")\n\nif len_first == len_second:\nprint(f\"Success: KeyTransformIn is working as expected. Both are {len_first}.\")\nsys.exit(0)\nelse:\nprint(f\"Failure: KeyTransformIn is not working. len_first={len_first}, len_second={len_second}\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/models/fields/json.py": "         return super().as_sql(compiler, connection)\n \n \nclass KeyTransformIn(lookups.In):\ndef process_rhs(self, compiler, connection):\nrhs, rhs_params = super().process_rhs(compiler, connection)\nif not connection.features.has_native_json_field:\nfunc = ()\nif connection.vendor == 'oracle':\nfunc = []\nfor value in rhs_params:\nvalue = json.loads(value)\nfunction = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'\nfunc.append(\"%s('%s', '$.value')\" % (\nfunction,\njson.dumps({'value': value}),\n))\nfunc = tuple(func)\nrhs_params = ()\nelif connection.vendor == 'mysql' and connection.mysql_is_mariadb:\nfunc = (\"JSON_UNQUOTE(JSON_EXTRACT(%s, '$'))\",) * len(rhs_params)\nelif connection.vendor in {'sqlite', 'mysql'}:\nfunc = (\"JSON_EXTRACT(%s, '$')\",) * len(rhs_params)\nrhs = rhs % func\nreturn rhs, rhs_params\n\n\n class KeyTransformExact(JSONExact):\n     def process_lhs(self, compiler, connection):\n         lhs, lhs_params = super().process_lhs(compiler, connection)\n     pass\n \n \nKeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines two classes, KeyTransformGte and KeyTransformIn, which are specialized lookup types for Django's ORM, handling JSON fields. It implements methods for processing the left-hand side and right-hand side of queries, focusing on JSON functionality and vendor-specific implementations (e.g., for MySQL and Oracle). The sample includes a test script that configures Django settings and tests the lookup functionality on an in-memory SQLite database. In contrast, the code in code sample 2 focuses solely on the KeyTransformIn class and its method for processing the right-hand side of a query with additional checks for different database vendors when dealing with JSON fields. It also includes a reference to registering KeyTransform lookups but lacks the broader context of Django setup and testing present in sample 1.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they have differing functionalities, implementations, and structures. Sample 1 is a more complete setup and includes testing, while sample 2 is a partial implementation with different handling of JSON processing.\"}"
}