{
    "instance_id": "django__django-13121",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/backends/base/operations.py": "index 2e283a3193..622e6da76e 100644\n         return []\n \n     def convert_durationfield_value(self, value, expression, connection):\n\"\"\"\nConvert the database return value for DurationField into a Python timedelta.\nHandle strings by trying parse_duration. If parse_duration fails, treat the\nstring as microseconds. If it's an int/float, treat it as microseconds directly.\n\"\"\"\n         if value is not None:\n# If it's numeric (int, float, Decimal), interpret as microseconds directly.\nif isinstance(value, (int, float)):\nreturn datetime.timedelta(microseconds=value)\ntry:\nfrom decimal import Decimal\nif isinstance(value, Decimal):\nreturn datetime.timedelta(microseconds=float(value))\nexcept ImportError:\npass\n\n# If we have a string, try parse_duration first:\nif isinstance(value, str):\nfrom django.utils.dateparse import parse_duration\ntd = parse_duration(value)\nif td is not None:\nreturn td\n# If that fails, assume value is a string microsecond count:\ntry:\nmicros = float(value)\nreturn datetime.timedelta(microseconds=micros)\nexcept (ValueError, TypeError):\nraise ValueError(f\"Cannot interpret {value!r} as a duration.\")\n# Fallback: if it's not recognized above, treat it as microseconds\nreturn datetime.timedelta(microseconds=value)\nreturn value\n\n \n     def check_expression_support(self, expression):\n         \"\"\"\n",
        "tests/test_issue_duration_expr.py": "new file mode 100644\nindex 0000000000..bee1bf7e06\nimport sys\nimport traceback\nimport django\nimport os\nfrom django.conf import settings\nfrom django.db import connection, models\nfrom django.db.models import F\nimport datetime\n\nprint(\"Starting test_issue_duration_expr script...\")\n\n# Configure Django (only if not already configured).\nif not settings.configured:\nsettings.configure(\nSECRET_KEY=\"test\",\nINSTALLED_APPS=[],\nDATABASES={\n\"default\": {\n\"ENGINE\": os.environ.get(\"DB_ENGINE\", \"django.db.backends.sqlite3\"),\n\"NAME\": os.environ.get(\"DB_NAME\", \":memory:\"),\n}\n},\nTIME_ZONE=\"UTC\",\nUSE_TZ=True,\n)\n\ndjango.setup()\n\nclass IssueDurationModel(models.Model):\nestimated_time = models.DurationField()\nclass Meta:\napp_label = 'test_issue_duration_expr'\nmanaged = False  # We'll manually create the table\n\ntry:\n# Create the table using the schema editor.\nwith connection.schema_editor() as editor:\neditor.create_model(IssueDurationModel)\n\n# Insert a test row\nobj = IssueDurationModel.objects.create(estimated_time=datetime.timedelta(hours=2))\nprint(\"Inserted object with estimated_time:\", obj.estimated_time)\n\n# Try an annotation with a 1-day timedelta\nprint(\"Attempting annotate with +1 day on a DurationField.\")\nqs = IssueDurationModel.objects.annotate(\nduration_plus_day=F(\"estimated_time\") + datetime.timedelta(days=1)\n)\nresults = list(qs)\nprint(\"Annotated results length:\", len(results))\nfor r in results:\nprint(\"Annotated duration_plus_day =\", r.duration_plus_day)\n\nprint(\"Test passed: no exceptions raised.\")\nsys.exit(0)\n\nexcept Exception as e:\nprint(\"Test failed with exception:\")\ntraceback.print_exc()\nsys.exit(1)\n"
    },
    "ground_truth_patch": {
        "django/db/backends/base/operations.py": "         \"\"\"\n         raise NotImplementedError('subclasses of BaseDatabaseOperations may require a date_extract_sql() method')\n \n     def date_trunc_sql(self, lookup_type, field_name):\n         \"\"\"\n         Given a lookup_type of 'year', 'month', or 'day', return the SQL that\n",
        "django/db/backends/mysql/operations.py": " from django.conf import settings\n from django.db.backends.base.operations import BaseDatabaseOperations\n from django.utils import timezone\n from django.utils.encoding import force_str\n \n \n         else:\n             return \"TIME(%s)\" % (field_name)\n \n     def fetch_returned_insert_rows(self, cursor):\n         \"\"\"\n         Given a cursor object that has just performed an INSERT...RETURNING\n",
        "django/db/backends/sqlite3/operations.py": " from django.db.models.expressions import Col\n from django.utils import timezone\n from django.utils.dateparse import parse_date, parse_datetime, parse_time\n from django.utils.functional import cached_property\n \n \n         \"\"\"\n         return \"django_date_extract('%s', %s)\" % (lookup_type.lower(), field_name)\n \n     def format_for_duration_arithmetic(self, sql):\n         \"\"\"Do nothing since formatting is handled in the custom function.\"\"\"\n         return sql\n",
        "django/db/models/expressions.py": "     def _combine(self, other, connector, reversed):\n         if not hasattr(other, 'resolve_expression'):\n             # everything must be resolvable to an expression\noutput_field = (\nfields.DurationField()\nif isinstance(other, datetime.timedelta) else\nNone\n)\nother = Value(other, output_field=output_field)\n \n         if reversed:\n             return CombinedExpression(other, connector, self)\n \n     def as_sql(self, compiler, connection):\n         try:\nlhs_type = self.lhs.output_field.get_internal_type()\n         except FieldError:\nlhs_type = None\n         try:\nrhs_type = self.rhs.output_field.get_internal_type()\n         except FieldError:\nrhs_type = None\nif (\nnot connection.features.has_native_duration_field and\n'DurationField' in {lhs_type, rhs_type} and\nlhs_type != rhs_type\n):\n             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)\ndatetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\nif self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\n             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)\n         expressions = []\n         expression_params = []\n \n class DurationExpression(CombinedExpression):\n     def compile(self, side, compiler, connection):\ntry:\noutput = side.output_field\nexcept FieldError:\npass\nelse:\nif output.get_internal_type() == 'DurationField':\nsql, params = compiler.compile(side)\nreturn connection.ops.format_for_duration_arithmetic(sql), params\n         return compiler.compile(side)\n \n     def as_sql(self, compiler, connection):\n         return []\n \n \n class RawSQL(Expression):\n     def __init__(self, sql, params, output_field=None):\n         if output_field is None:\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a function to convert database return values for Django's DurationField into Python's timedelta objects, also handling various types of input values. The second code sample deals with database operations for Django, specifically, it outlines methods for different database backends and how to handle SQL querying and inserting of values, but it does not cover any functionality related to DurationField.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they address entirely different functionalities: code sample 1 focuses on handling DurationField values, while code sample 2 deals with broader database operations and querying.\"}"
}