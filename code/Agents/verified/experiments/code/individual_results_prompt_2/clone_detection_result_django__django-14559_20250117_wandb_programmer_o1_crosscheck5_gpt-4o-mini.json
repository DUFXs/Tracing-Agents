{
    "instance_id": "django__django-14559",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "check_bulk_update_return_value.py": "new file mode 100644\nindex 0000000000..f2cd608608\nimport sys\nimport django\nfrom django.conf import settings\nfrom django.db import models, connection\nfrom django.core.management import call_command\n\nDB_NAME = \":memory:\"\n\n# Minimal Django settings for an in-memory sqlite database.\nsettings.configure(\nINSTALLED_APPS=[],\nDATABASES={\n\"default\": {\n\"ENGINE\": \"django.db.backends.sqlite3\",\n\"NAME\": DB_NAME,\n}\n},\nSECRET_KEY=\"testsecretkey\",\n)\n\ndef main():\nprint(\"Starting test for bulk_update return value.\")\ndjango.setup()\n\nclass BulkUpdateTestModel(models.Model):\nname = models.CharField(max_length=50)\nvalue = models.IntegerField()\n\nclass Meta:\napp_label = \"bulk_update_test_app\"  # Just a placeholder; no real migrations.\n\n# Manually create the table for BulkUpdateTestModel.\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(BulkUpdateTestModel)\n\nprint(\"Creating objects...\")\nobjs = [\nBulkUpdateTestModel.objects.create(name=\"obj1\", value=1),\nBulkUpdateTestModel.objects.create(name=\"obj2\", value=2),\nBulkUpdateTestModel.objects.create(name=\"obj3\", value=3),\n]\n\nfor obj in objs:\nobj.value += 10\n\nprint(\"Calling bulk_update() on these objects...\")\nrows_updated = BulkUpdateTestModel.objects.bulk_update(objs, [\"value\"])\nprint(f\"bulk_update() returned: {rows_updated!r}\")\n\n# Expect an integer equal to the number of updated rows.\nif not isinstance(rows_updated, int):\nprint(\"FAIL: bulk_update() did not return an integer.\")\nsys.exit(1)\nif rows_updated != len(objs):\nprint(f\"FAIL: Expected {len(objs)} but got {rows_updated}\")\nsys.exit(1)\n\nprint(\"PASS: bulk_update() returned an integer matching the number of rows updated.\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n",
        "django/db/models/query.py": "index 387deca527..792e74db7f 100644\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\nreturn 0\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n         batch_size = min(batch_size, max_batch_size) if batch_size else max_batch_size\n         requires_casting = connections[self.db].features.requires_casted_case_in_updates\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\ntotal_updated = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\nupdated_count = self.filter(pk__in=pks).update(**update_kwargs)\ntotal_updated += updated_count\nreturn total_updated\n\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n"
    },
    "ground_truth_patch": {
        "django/db/models/query.py": "         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\nreturn 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\nrows_updated = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\nrows_updated += self.filter(pk__in=pks).update(**update_kwargs)\nreturn rows_updated\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a minimal Django application that sets up an in-memory SQLite database to test the `bulk_update()` method on a Django model called `BulkUpdateTestModel`. It creates instances of the model, updates their values, and checks if the `bulk_update()` returns the expected number of updated objects. The code sample 2, on the other hand, is a portion of the Django query management code implementing the `bulk_update()` method itself. This code checks for primary keys in fields, processes update arguments, and performs the actual bulk update operation within a database transaction.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they serve very different purposes. Code sample 1 is a test script for a Django feature, while code sample 2 is an implementation of the Django feature itself. They do not share structural similarities that would classify them as clones.\"}"
}