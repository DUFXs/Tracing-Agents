{
    "instance_id": "django__django-14559",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index 238fb3a200..521baaa795 100644\n tests/.coverage\n build/\n tests/report/\n.aider/\n",
        "django/db/models/query.py": "index 387deca527..f14ff8d094 100644\n         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\nreturn 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\nrows_updated = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\nrows_updated += self.filter(pk__in=pks).update(**update_kwargs)\nreturn rows_updated\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n"
    },
    "ground_truth_patch": {
        "django/db/models/query.py": "         if any(f.primary_key for f in fields):\n             raise ValueError('bulk_update() cannot be used with primary key fields.')\n         if not objs:\nreturn 0\n         # PK is used twice in the resulting update query, once in the filter\n         # and once in the WHEN. Each field will also have one CAST.\n         max_batch_size = connections[self.db].ops.bulk_batch_size(['pk', 'pk'] + fields, objs)\n                     case_statement = Cast(case_statement, output_field=field)\n                 update_kwargs[field.attname] = case_statement\n             updates.append(([obj.pk for obj in batch_objs], update_kwargs))\nrows_updated = 0\n         with transaction.atomic(using=self.db, savepoint=False):\n             for pks, update_kwargs in updates:\nrows_updated += self.filter(pk__in=pks).update(**update_kwargs)\nreturn rows_updated\n     bulk_update.alters_data = True\n \n     def get_or_create(self, defaults=None, **kwargs):\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 contains a patch for a Python file, which includes logic for handling bulk updates in a Django application through the use of primary keys and a transaction. It checks for primary key fields before executing an update and raises an error if any exist. It then calculates the maximum batch size for the update and applies the updates in an atomic transaction. The code sample also defines a 'get_or_create' method with default parameters. The code in code sample 2 is nearly identical in content and structure and appears to represent the same patch made to the same file with only minor formatting differences. It addresses the same functionality and structure as the first sample.\", \"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for whitespace, layout, and indentation differences.\"}"
}