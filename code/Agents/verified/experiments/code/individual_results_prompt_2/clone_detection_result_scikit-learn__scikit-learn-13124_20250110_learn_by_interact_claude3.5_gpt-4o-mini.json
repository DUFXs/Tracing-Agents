{
    "instance_id": "scikit-learn__scikit-learn-13124",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "sklearn/model_selection/_split.py": "index 24394f869..06687a4d9 100644\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\nrng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\n                            \" be less than n_splits=%d.\"\n                            % (min_groups, self.n_splits)), Warning)\n \ntest_folds = np.zeros(n_samples, dtype=np.int)\n\n# If shuffle is True, shuffle indices within each class separately\nclass_indices = []\nfor cls in unique_y:\ncls_idx = np.where(y == cls)[0]\nif self.shuffle:\nrng.shuffle(cls_idx)\nclass_indices.append(cls_idx)\n\n         per_cls_cvs = [\nKFold(self.n_splits, shuffle=False,\nrandom_state=None).split(np.zeros(max(count, self.n_splits)))\n             for count in y_counts]\n \n         for test_fold_indices, per_cls_splits in enumerate(zip(*per_cls_cvs)):\nfor cls_idx, (_, test_split) in zip(class_indices, per_cls_splits):\ncls_test_folds = test_folds[cls_idx]\n                 # the test split can be too big because we used\n                 # KFold(...).split(X[:max(c, n_splits)]) when data is not 100%\n                 # stratifiable for all the classes\n                 test_split = test_split[test_split < len(cls_test_folds)]\n                 cls_test_folds[test_split] = test_fold_indices\ntest_folds[cls_idx] = cls_test_folds\n \n         return test_folds\n \n         params[key] = value\n \n     return '%s(%s)' % (class_name, _pprint(params, offset=len(class_name)))\n\n"
    },
    "ground_truth_patch": {
        "sklearn/model_selection/_split.py": "             ``n_splits`` default value will change from 3 to 5 in v0.22.\n \n     shuffle : boolean, optional\nWhether to shuffle each class's samples before splitting into batches.\n \n     random_state : int, RandomState instance or None, optional, default=None\n         If int, random_state is the seed used by the random number generator;\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\nrng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a method to create test folds for cross-validation by initializing various parameters and shuffling indices if needed. It computes the splits based on the provided dataset and handles cases where the distribution of classes is uneven. The second code sample provides documentation and describes parameters related to the method, including the defaults. It also includes a call to the super class initializer, indicating it is a method associated with a class. Overall, code sample 2's primary function appears to be documenting the parameters and behavior of the method in code sample 1 rather than replicating its functionality directly.\",\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because code sample 1 implements logic for creating test folds while code sample 2 provides descriptions and documentation regarding the method and its parameters. They serve different purposes and do not share similar code structure or logic.\"}"
}