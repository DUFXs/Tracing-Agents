{
    "instance_id": "pytest-dev__pytest-10081",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "reproduce_error.py": "new file mode 100644\nindex 000000000..74b8c5307\nimport unittest\n\n@unittest.skip(\"hello\")\nclass MyTestCase(unittest.TestCase):\ndef setUp(self):\nxxx\ndef test_one(self):\npass\ndef tearDown(self):\nxxx\n\nif __name__ == '__main__':\nimport pytest\npytest.main(['--pdb', __file__])\n\\ No newline at end of file\n",
        "src/_pytest/unittest.py": "index 851e4943b..63abde961 100644\n \n         assert self._testcase is not None\n \n# Check if the test or test class is skipped\nif _is_skipped(self._testcase) or _is_skipped(self.obj):\nreason = getattr(self._testcase, \"__unittest_skip_why__\", \"\") or getattr(self.obj, \"__unittest_skip_why__\", \"\")\nraise pytest.skip.Exception(reason, _use_item_location=True)\n\n         maybe_wrap_pytest_function_for_tracing(self)\n \n         # Let the unittest framework handle async functions.\n             # Arguably we could always postpone tearDown(), but this changes the moment where the\n             # TestCase instance interacts with the results object, so better to only do it\n             # when absolutely needed.\nif self.config.getoption(\"usepdb\"):\n                 self._explicit_tearDown = self._testcase.tearDown\n                 setattr(self._testcase, \"tearDown\", lambda *args: None)\n \n"
    },
    "ground_truth_patch": {
        "src/_pytest/unittest.py": "# Arguably we could always postpone tearDown(), but this changes the moment where the\n# TestCase instance interacts with the results object, so better to only do it\n# when absolutely needed.\n# We need to consider if the test itself is skipped, or the whole class.\nassert isinstance(self.parent, UnitTestCase)\nskipped = _is_skipped(self.obj) or _is_skipped(self.parent.obj)\nif self.config.getoption(\"usepdb\") and not skipped:\n    self._explicit_tearDown = self._testcase.tearDown\n    setattr(self._testcase, \"tearDown\", lambda *args: None)\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is setting up a unit test class using Python's unittest framework. It includes a setup method (setUp) and a teardown method (tearDown), alongside an actual test method (test_one) that currently does nothing. It also includes a decorator to skip the test and a main block to allow pytest to run it. On the other hand, code sample 2 is part of the implementation of a unittest case in the pytest framework. It checks if a test or class is skipped and handles the teardown functionality conditionally based on pytest options.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because code sample 1 is a complete test case structure for unittest, while code sample 2 is an implementation fragment dealing with skipped tests and teardown logic in pytest, showcasing a functional difference rather than similarity.\"}"
}