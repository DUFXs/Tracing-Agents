{
    "instance_id": "astropy__astropy-14096",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "astropy/coordinates/sky_coordinate.py": "index ab475f7d0d..f8541330dd 100644\n         \"\"\"\n         Overrides getattr to return coordinates that this can be transformed\n         to, based on the alias attr in the primary transform graph.\n\nIf normal Python lookup fails to find attr (including descriptors like\nproperties), we fall back to SkyCoord's custom logic. However, if the\nattribute is actually defined (e.g. as a property) but raises an error,\nwe re-raise that original error rather than swallowing it.\n         \"\"\"\ntry:\nreturn super().__getattribute__(attr)\nexcept AttributeError as e:\n# Distinguish between \"attribute truly doesn't exist\"\n# vs. \"attribute code exists but raised an error.\"\n# If attr is defined in the class's MRO, or in self.__dict__,\n# it's presumably a descriptor/field that was found but raised.\nif any(attr in c.__dict__ for c in self.__class__.__mro__):\nraise\nif attr in self.__dict__:\nraise\n\n# Fallback logic for truly-missing attributes\n         if \"_sky_coord_frame\" in self.__dict__:\n             if self._is_name(attr):\n                 return self  # Should this be a deepcopy of self?\n\nfrom .baseframe import frame_transform_graph\n\n# If the attr is relevant for the current frame then delegate to self.frame\n# Otherwise get it from self._<attr>.\n             if attr in frame_transform_graph.frame_attributes:\n                 if attr in self.frame.frame_attributes:\n                     return getattr(self.frame, attr)\n                 else:\n                     return getattr(self, \"_\" + attr, None)\n\n             # Some attributes might not fall in the above category but still\n             # are available through self._sky_coord_frame.\n             if not attr.startswith(\"_\") and hasattr(self._sky_coord_frame, attr):\n                 return getattr(self._sky_coord_frame, attr)\n\n             # Try to interpret as a new frame for transforming.\n             frame_cls = frame_transform_graph.lookup_name(attr)\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n\n         # Fail\nraise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{attr}'\")\n\n\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\n",
        "test_subclass_skycoord_issue.py": "new file mode 100644\nindex 0000000000..298e7b127b\n#!/usr/bin/env python\n\nimport sys\nimport astropy.coordinates as coord\n\nclass custom_coord(coord.SkyCoord):\n@property\ndef prop(self):\n# This intentionally uses a non-existent attribute\nreturn self.random_attr\n\ndef main():\nprint(\"Running test_subclass_skycoord_issue\")\ntry:\nc = custom_coord('00h42m30s', '+41d12m00s', frame='icrs')\nprint(\"Accessing c.prop ...\")\nc.prop\nprint(\"ERROR: c.prop did NOT raise an AttributeError as expected!\")\nsys.exit(1)\nexcept AttributeError as e:\nprint(\"Caught AttributeError:\", e)\nif \"random_attr\" in str(e):\nprint(\"SUCCESS: Error message references random_attr. Test passes.\")\nsys.exit(0)\nelse:\nprint(\"FAILURE: Error message does NOT reference random_attr.\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "astropy/coordinates/sky_coordinate.py": "             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n# Call __getattribute__; this will give correct exception.\nreturn self.__getattribute__(attr)\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 implements the '__getattribute__' method for a custom class that extends 'SkyCoord', where it overrides attribute retrieval to include custom logic for handling attributes based on their existence and transformability. It raises an 'AttributeError' with a relevant message if the attribute truly does not exist or if there's an issue with existing attributes. The code sample also includes a '__setattr__' method, ensuring that any attributes accessed via '__getattr__' are immutable. In code sample 2, a similar '__getattribute__' logic is present where it calls the superclass's '__getattribute__' method to handle attribute access. It contains a comment indicating this is to ensure correct exception behavior. The '__setattr__' function appears to be identical, with the intent to manage attributes accessed through '__getattr__'.\", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they exhibit syntactical similarity but differ in implementation details and additional logic regarding attribute handling.\"}"
}