{
    "instance_id": "django__django-10097",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "django/core/validators.py": "index 92394a7eae..6c16da4d84 100644\n \n     regex = _lazy_re_compile(\n         r'^(?:[a-z0-9\\.\\-\\+]*)://'  # scheme is validated separately\nr'(?:(?:[a-z0-9\\-._~!$&\\'()*+,;=]|%[0-9a-f]{2})+(?::(?:[a-z0-9\\-._~!$&\\'()*+,;=]|%[0-9a-f]{2})*)?@)?'  # user:pass authentication\n         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n         r'(?::\\d{2,5})?'  # port\n         r'(?:[/?#][^\\s]*)?'  # resource path\n\n         r'\\Z', re.IGNORECASE)\n     message = _('Enter a valid URL.')\n     schemes = ['http', 'https', 'ftp', 'ftps']\n             self.message == other.message and\n             self.code == other.code\n         )\n\n",
        "reproduce.py": "new file mode 100644\nindex 0000000000..5ba069e656\nfrom django.core.validators import URLValidator\nfrom django.core.exceptions import ValidationError\n\nvalidator = URLValidator()\n\ntest_cases = [\n# Invalid cases (should be rejected)\n(\"http://foo/bar@example.com\", False, \"unencoded / in username\"),\n(\"http://foo:p@ss@example.com\", False, \"unencoded @ in password\"),\n(\"http://foo:bar:baz@example.com\", False, \"unencoded : in password\"),\n# Valid cases (should be accepted)\n(\"http://foo:bar@example.com\", True, \"basic auth without special chars\"),\n(\"http://foo%2Fbar:b%40z@example.com\", True, \"properly encoded special chars\"),\n(\"http://example.com\", True, \"no auth part\"),\n]\n\nfor url, should_pass, desc in test_cases:\ntry:\nvalidator(url)\nresult = \"accepted\"\npassed = should_pass\nexcept ValidationError:\nresult = \"rejected\"\npassed = not should_pass\n\nstatus = \"PASS\" if passed else \"FAIL\"\nprint(\"{}: URL '{}' was {} ({})\".format(status, url, result, desc))\n\n"
    },
    "ground_truth_patch": {
        "django/core/validators.py": " \n     regex = _lazy_re_compile(\n         r'^(?:[a-z0-9\\.\\-\\+]*)://'  # scheme is validated separately\nr'(?:[^\\s:@/]+(?::[^\\s:@/]*)?@)?'  # user:pass authentication\n         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n         r'(?::\\d{2,5})?'  # port\n         r'(?:[/?#][^\\s]*)?'  # resource path\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a regular expression pattern used for validating URLs and includes a set of test cases for a URL validator, where it checks several URLs for their validity and prints the results. The code in code sample 2, however, only presents the first part of a regular expression pattern used for URL validation without any additional test cases or functionality.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because code sample 1 includes additional logic for testing URLs and reporting results, while code sample 2 only shows part of the regular expression pattern for URL validation without any context of usage.\"}"
}