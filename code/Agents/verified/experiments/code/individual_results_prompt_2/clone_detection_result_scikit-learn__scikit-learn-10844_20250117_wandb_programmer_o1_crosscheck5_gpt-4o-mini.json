{
    "instance_id": "scikit-learn__scikit-learn-10844",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "sklearn/metrics/cluster/supervised.py": "index a987778ae..c5a75d424 100644\n \n     References\n     ----------\n.. [1] E. B. Fowkles and C. L. Mallows, 1983. \"A method for comparing two\nhierarchical clusterings\". Journal of the American Statistical\nAssociation\n<http://wildfire.stat.ucla.edu/pdflibrary/fowlkes.pdf>_\n \n.. [2] Wikipedia entry for the Fowlkes-Mallows Index\n<https://en.wikipedia.org/wiki/Fowlkes-Mallows_index>_\n     \"\"\"\n     labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n     n_samples, = labels_true.shape\n     tk = np.dot(c.data, c.data) - n_samples\n     pk = np.sum(np.asarray(c.sum(axis=0)).ravel() ** 2) - n_samples\n     qk = np.sum(np.asarray(c.sum(axis=1)).ravel() ** 2) - n_samples\nreturn np.sqrt(tk / pk) * np.sqrt(tk / qk) if tk != 0. else 0.\n\n \n \n def entropy(labels):\n",
        "test_fowlkes_overflow.py": "new file mode 100644\nindex 000000000..f06d9d825\nimport numpy as np\nimport sys\nimport warnings\nfrom sklearn.metrics import fowlkes_mallows_score\n\ndef test_fm_overflow():\n# Create large vectors to make pk and qk beyond 2^31\nlabels_true = np.zeros(50000, dtype=int)\nlabels_pred = np.zeros(50000, dtype=int)\n\nwith warnings.catch_warnings(record=True) as w:\nwarnings.simplefilter(\"always\", RuntimeWarning)\nscore = fowlkes_mallows_score(labels_true, labels_pred)\noverflow_warn = any(\"overflow\" in str(_warning.message).lower() for _warning in w)\nif overflow_warn:\nprint(\"RuntimeWarning detected:\", [str(_warning.message) for _warning in w])\nsys.exit(1)\nelif not np.isfinite(score):\nprint(\"Score is not finite:\", score)\nsys.exit(1)\nelse:\nprint(\"Test passed. Score:\", score)\nsys.exit(0)\n\nif __name__ == \"__main__\":\ntest_fm_overflow()\n"
    },
    "ground_truth_patch": {
        "sklearn/metrics/cluster/supervised.py": "     labels_true, labels_pred = check_clusterings(labels_true, labels_pred)\n     n_samples, = labels_true.shape\n \nc = contingency_matrix(labels_true, labels_pred,\nsparse=True).astype(np.int64)\n     tk = np.dot(c.data, c.data) - n_samples\n     pk = np.sum(np.asarray(c.sum(axis=0)).ravel() ** 2) - n_samples\n     qk = np.sum(np.asarray(c.sum(axis=1)).ravel() ** 2) - n_samples\nreturn np.sqrt(tk / pk) * np.sqrt(tk / qk) if tk != 0. else 0.\n \n \n def entropy(labels):\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a function that computes the Fowlkes-Mallows score based on true and predicted cluster labels. It includes some documentation references and the logic to compute the score using various metrics derived from clustering results. The second code sample is a test case that validates the Fowlkes-Mallows score calculation under specific conditions, particularly when dealing with large vectors that might lead to overflow warnings. It checks if the warning is raised and prints relevant results. Both samples contain a function definition for 'entropy' as part of a larger implementation.\", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they have syntactical similarities but exhibit additional context or different surrounding logic, particularly in the first sample, which lacks the overflow testing logic found in the second sample.\"}"
}