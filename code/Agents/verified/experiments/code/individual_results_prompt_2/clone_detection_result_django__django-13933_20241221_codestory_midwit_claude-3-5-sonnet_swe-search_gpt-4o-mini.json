{
    "instance_id": "django__django-13933",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/forms/models.py": "index 422bc5d178..e03a3803cd 100644\n     # This class is a subclass of ChoiceField for purity, but it doesn't\n     # actually use any of ChoiceField's implementation.\n     default_error_messages = {\n'invalid_choice': _('Select a valid choice. %(value)s is not one of'\n                             ' the available choices.'),\n     }\n     iterator = ModelChoiceIterator\n                 value = getattr(value, key)\n             value = self.queryset.get(**{key: value})\n         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\nraise ValidationError(\nself.error_messages['invalid_choice'],\ncode='invalid_choice',\nparams={'value': value},\n)\n         return value\n \n     def validate(self, value):\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..02e8ea9b1a\nfrom django.conf import settings\nfrom django.db import models\nfrom django.forms import ModelForm, ModelChoiceField\nfrom django.core.exceptions import ValidationError\n\n# Configure Django settings\nsettings.configure(\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\nINSTALLED_APPS=[\n'django.contrib.contenttypes',\n],\nDEFAULT_AUTO_FIELD='django.db.models.AutoField',\n)\n\nimport django\ndjango.setup()\n\n# Create a simple model\nclass DummyModel(models.Model):\nname = models.CharField(max_length=100)\n\ndef __str__(self):\nreturn self.name\n\nclass Meta:\n# This is a hack for the reproduction script\nmanaged = False\napp_label = 'contenttypes'\n\n# Create a form\nclass DummyForm:\ndef __init__(self):\nself.field = ModelChoiceField(queryset=DummyModel.objects.none())\n\ndef test_validation(self):\n# Test with numeric value\ntry:\nself.field.clean('999')\nexcept ValidationError as e:\nprint(\"Numeric value error:\", e.messages[0])\n\n# Test with string value\ntry:\nself.field.clean('invalid_string')\nexcept ValidationError as e:\nprint(\"String value error:\", e.messages[0])\n\n# Test with special characters\ntry:\nself.field.clean('!@#$%^')\nexcept ValidationError as e:\nprint(\"Special chars error:\", e.messages[0])\n\n# Test the validation\nform = DummyForm()\nform.test_validation()\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/forms/models.py": "                 value = getattr(value, key)\n             value = self.queryset.get(**{key: value})\n         except (ValueError, TypeError, self.queryset.model.DoesNotExist):\nraise ValidationError(\nself.error_messages['invalid_choice'],\ncode='invalid_choice',\nparams={'value': value},\n)\n         return value\n \n     def validate(self, value):\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 appears to include parts of a Django form's validation logic, where it checks if a given value matches a choice within a ModelChoiceField and raises a ValidationError if not. This portion is likely part of a class that manages form validation against model choices from a queryset. In contrast, the code in code sample 2 contains a fragment of similar validation logic, specifically dealing with the retrieval of a value from a queryset and exceptions raised in the validation process. Both samples show similar syntax and structure related to exception handling in form validation.\", \"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for differences in whitespace and layout. They are both segments of the same logical operation related to model form validation.\"}"
}