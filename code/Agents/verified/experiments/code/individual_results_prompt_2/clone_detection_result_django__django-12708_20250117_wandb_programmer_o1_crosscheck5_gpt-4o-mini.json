{
    "instance_id": "django__django-12708",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/backends/base/schema.py": "index 61f88401ab..bcd36fdab3 100644\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n# Pass unique=False so that we ignore any unique index constraints.\nself._delete_composed_index(model, fields, {'index': True, 'unique': False}, self.sql_delete_index)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n             self.execute(self._create_index_sql(model, fields, suffix=\"_idx\"))\n\n \n     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}\n",
        "test_delete_index_together.py": "new file mode 100644\nindex 0000000000..103cf1c90e\nimport sys\nimport os\nimport django\nfrom django.conf import settings\nfrom django.db import connection\n\n# We'll use Django's migration API directly:\nfrom django.db.migrations.executor import MigrationExecutor\nfrom django.db.migrations.autodetector import MigrationAutodetector\nfrom django.db.migrations.state import ProjectState, ModelState\nfrom django.db import models\n\n\"\"\"\nThis script reproduces the issue of dropping index_together when a unique_together\nconstraint is on the exact same fields. On HEAD (unpatched), we expect:\nValueError: Found wrong number (2) of constraints...\nIf we catch that error, we exit(1). If we don't catch it, we exit(0).\n\"\"\"\n\n# Minimal Django settings for an in-memory DB\nsettings.configure(\nSECRET_KEY='dummy',\nINSTALLED_APPS=[],\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\n)\n\ndjango.setup()\n\nclass TestModelInitial(models.Model):\nf1 = models.IntegerField()\nf2 = models.IntegerField()\n\nclass Meta:\napp_label = 'test_app'\nunique_together = [('f1', 'f2')]\nindex_together = [('f1', 'f2')]\n\nclass TestModelFinal(models.Model):\nf1 = models.IntegerField()\nf2 = models.IntegerField()\n\nclass Meta:\napp_label = 'test_app'\n# Remove index_together, keep unique_together\nunique_together = [('f1', 'f2')]\n\ndef run_migrations(from_state, to_state):\n\"\"\"\nProgrammatically detect migrations from 'from_state' to 'to_state'\nand apply them. Return True if everything succeeded.\n\"\"\"\n# Autodetect changes\nautodetector = MigrationAutodetector(from_state, to_state)\nchanges = autodetector.changes(graph=MigrationExecutor(connection).loader.graph)\nif not changes:\nreturn True\n# Actually apply these migrations\nexecutor = MigrationExecutor(connection)\nexecutor.apply_changes(changes)\nreturn True\n\ndef main():\nprint(\"Creating empty initial ProjectState...\")\nempty_state = ProjectState()\n\n# Build a state that includes (f1, f2) in both unique_together and index_together\nstate_with_index = ProjectState()\nstate_with_index.add_model(\nModelState.from_model(TestModelInitial)\n)\n\n# Build a state that only has the unique_together\nstate_without_index = ProjectState()\nstate_without_index.add_model(\nModelState.from_model(TestModelFinal)\n)\n\ntry:\nprint(\"Migrating from empty -> (index + unique) state...\")\nrun_migrations(empty_state, state_with_index)\n\nprint(\"Migrating from (index + unique) -> (unique only) state...\")\nrun_migrations(state_with_index, state_without_index)\n\nprint(\"Index removed successfully; this is the FIXED behavior.\")\nsys.exit(0)\nexcept ValueError as e:\nerr_msg = str(e)\nprint(f\"Caught ValueError: {err_msg}\")\nif \"Found wrong number\" in err_msg:\nprint(\"This matches the known bug. Exiting with code 1.\")\nsys.exit(1)\nelse:\nprint(\"Unexpected error! Exiting with code 2.\")\nsys.exit(2)\nexcept Exception as other:\nprint(\"Unexpected exception:\", repr(other))\nsys.exit(2)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/backends/base/schema.py": "         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\nself._delete_composed_index(\nmodel,\nfields,\n{'index': True, 'unique': False},\nself.sql_delete_index,\n)\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a method that manages the creation and deletion of database indexes for a Django model, utilizing a set comprehension to create a new index and checks the existing indexes to delete or create as necessary. It also includes a helper method for deleting composed indexes. In contrast, the code in code sample 2 is a partial piece of the same code focusing on the logic for deleting indexes, with a modified parameter structure in the method call, showcasing similar functionality but differing in formatting and indentation.\", \"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for differences in whitespace and layout.\"}"
}