{
    "instance_id": "django__django-16642",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index 6a67c6eb28..cd0195a6d7 100644\n tests/.coverage*\n build/\n tests/report/\n.aider/\n",
        "django/http/response.py": "index f62dec8ce9..9773ea1e01 100644\n         if self._no_explicit_content_type:\n             if filename:\n                 content_type, encoding = mimetypes.guess_type(filename)\n# Handle special cases for compressed files\nif filename.lower().endswith('.z'):\ncontent_type = 'application/x-compress'\nelif filename.lower().endswith('.br'):\ncontent_type = 'application/x-brotli'\nelse:\n# Encoding isn't set to prevent browsers from automatically\n# uncompressing files.\ncontent_type = {\n\"bzip2\": \"application/x-bzip\",\n\"gzip\": \"application/gzip\",\n\"xz\": \"application/x-xz\",\n}.get(encoding, content_type)\n                 self.headers[\"Content-Type\"] = (\n                     content_type or \"application/octet-stream\"\n                 )\n"
    },
    "ground_truth_patch": {
        "django/http/response.py": "                 # Encoding isn't set to prevent browsers from automatically\n                 # uncompressing files.\n                 content_type = {\n\"br\": \"application/x-brotli\",\n                     \"bzip2\": \"application/x-bzip\",\n\"compress\": \"application/x-compress\",\n                     \"gzip\": \"application/gzip\",\n                     \"xz\": \"application/x-xz\",\n                 }.get(encoding, content_type)\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is handling the determination of the `Content-Type` for an HTTP response based on a specified filename and encoding. It checks if the filename is related to certain compressed formats (like .z or .br), and depending on that, it sets the content type accordingly. If the encoding is specified, it falls back to a predefined dictionary that maps compression types to their corresponding MIME types. Meanwhile, code sample 2 also deals with setting the `Content-Type` based on a dictionary, but it explicitly maps a broader set of encoding types to their MIME types. However, the second sample only shows the dictionary setup and lacks the full context of how it's integrated into the response handling logic. \", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because while they share some similar logic concerning content types, they differ significantly in context and structure. Code sample 2 lacks some of the conditional checks present in sample 1, indicating a divergence in how the functionality is presented.\"}"
}