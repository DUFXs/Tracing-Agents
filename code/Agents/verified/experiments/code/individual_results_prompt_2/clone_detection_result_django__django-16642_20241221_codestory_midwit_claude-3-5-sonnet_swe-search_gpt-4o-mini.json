{
    "instance_id": "django__django-16642",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/http/response.py": "index f62dec8ce9..89a8d8416e 100644\n         if self._no_explicit_content_type:\n             if filename:\n                 content_type, encoding = mimetypes.guess_type(filename)\n# Handle special cases for compression formats\nif filename.lower().endswith('.z'):\nencoding = 'compress'\nelif filename.lower().endswith('.br'):\nencoding = 'br'\n                 # Encoding isn't set to prevent browsers from automatically\n                 # uncompressing files.\n                 content_type = {\n                     \"bzip2\": \"application/x-bzip\",\n                     \"gzip\": \"application/gzip\",\n                     \"xz\": \"application/x-xz\",\n\"br\": \"application/x-brotli\",\n\"compress\": \"application/x-compress\",\n                 }.get(encoding, content_type)\n                 self.headers[\"Content-Type\"] = (\n                     content_type or \"application/octet-stream\"\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..0f52a13543\nfrom django.http import FileResponse\nfrom django.conf import settings\nimport os\nimport mimetypes\n\n# Configure Django settings\nsettings.configure(\nDEBUG=True,\nDEFAULT_CHARSET='utf-8'\n)\n\n# Test cases\ntest_files = [\n'test.html.Z',           # Basic .Z file\n'test.html.br',          # Basic .br file\n'test.tar.Z',           # Archive with .Z\n'test.tar.br',          # Archive with .br\n'test.Z',               # Just .Z\n'test.br',              # Just .br\n'test.HTML.Z',          # Mixed case with .Z\n'test.HTML.BR'          # Mixed case with .BR\n]\n\n# Create and test each file\nfor filename in test_files:\n# Create test file\nwith open(filename, 'wb') as f:\nf.write(b'test content')\n\n# Test FileResponse\nresponse = FileResponse(open(filename, 'rb'))\nprint(f\"Content-Type for {filename}: {response.headers['Content-Type']}\")\n\n# Clean up\nos.unlink(filename)\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/http/response.py": "                 # Encoding isn't set to prevent browsers from automatically\n                 # uncompressing files.\n                 content_type = {\n\"br\": \"application/x-brotli\",\n                     \"bzip2\": \"application/x-bzip\",\n\"compress\": \"application/x-compress\",\n                     \"gzip\": \"application/gzip\",\n                     \"xz\": \"application/x-xz\",\n                 }.get(encoding, content_type)\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 handles the determination of the content type for a file based on its filename, specifically for certain compression formats. It checks if a filename corresponds to specific extensions and associates those with the appropriate content types. The code in code sample 2 is a continuation of the content type assignment where it specifies the mappings for compression types, such as 'bzip2', 'gzip', 'xz', and 'br'. Both samples are parts of the same logical construct which aims to determine and assign a content type based on the file extension.\", \"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for minor differences in whitespace and layout. The content is the same functionality laid out in different portions of the code.\"}"
}