{
    "instance_id": "django__django-13590",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/sql/query.py": "index 4648daf395..b3ce0647be 100644\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\nitems = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n# If this is a namedtuple, expand args. Otherwise, pass them as one iterable.\nif hasattr(value, '_fields'):\nreturn type(value)(*items)\nelse:\nreturn type(value)(items)\n         return value\n\n \n     def solve_lookup_type(self, lookup):\n         \"\"\"\n",
        "test_namedtuple_range.py": "new file mode 100644\nindex 0000000000..1a9479cc26\nimport sys\nimport django\nimport os\nfrom django.conf import settings\nfrom django.db import models, connection\nfrom collections import namedtuple\n\n# Minimal project setup\nif not settings.configured:\nsettings.configure(\nINSTALLED_APPS=[],\nDATABASES={\"default\": {\"ENGINE\": \"django.db.backends.sqlite3\", \"NAME\": \":memory:\"}},\nSECRET_KEY=\"testkey\",\n)\n\ndjango.setup()\n\nclass RangeModel(models.Model):\nvalue = models.IntegerField()\nclass Meta:\napp_label = \"namedtuple_range_app\"\n\n# Create table directly with schema_editor (no migrations).\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(RangeModel)\n\n# Insert sample data.\nRangeModel.objects.create(value=5)\nRangeModel.objects.create(value=10)\n\nMyRange = namedtuple(\"MyRange\", [\"start\", \"end\"])\ntest_tuple = MyRange(start=5, end=10)\n\ntry:\n# This filter triggers the namedtuple range bug on Django <= 3.0\nqs = RangeModel.objects.filter(value__range=test_tuple)\nprint(\"Filter succeeded with namedtuple range argument!\")\nsys.exit(0)\nexcept TypeError as e:\nprint(\"TEST FAILED. Got TypeError for namedtuple range, indicating the bug is present.\")\nprint(f\"Error details: {e}\")\nsys.exit(1)\nexcept Exception as e:\nprint(\"TEST FAILED. An unexpected exception occurred.\")\nprint(f\"Exception details: {e}\")\nsys.exit(1)\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/query.py": "         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\nvalues = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\ntype_ = type(value)\nif hasattr(type_, '_make'):  # namedtuple\nreturn type_(*values)\nreturn type_(values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is handling a situation where it checks if a given value is an instance of a list or tuple. If so, it resolves each item of this iterable independently and collects them into 'items'. The code then checks if the value is a namedtuple (indicated by '_fields'), and creates an instance of that namedtuple using the resolved 'items', or returns the items as a regular iterable otherwise. The function 'solve_lookup_type' is defined after that. In code sample 2, the logic is almost the same, but it uses 'values' for the list of resolved values and checks the type of the input to see if it has a method '_make', indicating it's a namedtuple. It returns accordingly. The structure and purpose of both codes are very similar, tackling namedtuples and lists in Django's ORM querying.\", \"is_clone\": true, \"classification\": \"type-2\", \"reasoning\": \"These code samples are type-2 clones because they are identical in structure and logic but differ in variable names ('items' vs 'values') and have minor syntactical differences that do not affect functionality.\"}"
}