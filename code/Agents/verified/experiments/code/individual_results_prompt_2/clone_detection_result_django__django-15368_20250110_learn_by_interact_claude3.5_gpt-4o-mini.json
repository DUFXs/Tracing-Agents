{
    "instance_id": "django__django-15368",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "django/db/models/query.py": "index f8d848e926..b99513a09b 100644\n                 when_statements = []\n                 for obj in batch_objs:\n                     attr = getattr(obj, field.attname)\nif not isinstance(attr, (Expression, F)):\n                         attr = Value(attr, output_field=field)\n\n                     when_statements.append(When(pk=obj.pk, then=attr))\n                 case_statement = Case(*when_statements, output_field=field)\n                 if requires_casting:\n         rel_cls = RelatedPopulator(rel_klass_info, select, db)\n         iterators.append(rel_cls)\n     return iterators\n\n",
        "repro.py": "new file mode 100644\nindex 0000000000..8fe753964b\nimport os\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n\nfrom django.conf import settings\nsettings.configure(\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\nINSTALLED_APPS=['django.contrib.contenttypes'],\nDEBUG=True,  # Enable query logging\n)\n\nimport django\ndjango.setup()\n\nfrom django.db import models, connection\nfrom django.db.models import F\n\n# Create a simple model for testing\nclass SelfRef(models.Model):\nname = models.CharField(max_length=100)\nc8 = models.CharField(max_length=100)\n\nclass Meta:\napp_label = 'contenttypes'\n\n# Create table\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(SelfRef)\n\n# Test case\nobj = SelfRef.objects.create(name='test', c8='old')\nprint(f\"Initial values - name: {obj.name}, c8: {obj.c8}\")\n\n# Try bulk_update with F expression\nobj.c8 = F('name')\nSelfRef.objects.bulk_update([obj], ['c8'])\n\n# Check the result\nobj.refresh_from_db()\nprint(f\"After bulk_update - name: {obj.name}, c8: {obj.c8}\")\n\n# Print the actual SQL query for verification\nprint(\"\\nExecuted SQL:\")\nfor query in connection.queries:\nprint(query['sql'])\n"
    },
    "ground_truth_patch": {
        "django/db/models/query.py": " from django.db.models import AutoField, DateField, DateTimeField, sql\n from django.db.models.constants import LOOKUP_SEP, OnConflict\n from django.db.models.deletion import Collector\nfrom django.db.models.expressions import Case, F, Ref, Value, When\n from django.db.models.functions import Cast, Trunc\n from django.db.models.query_utils import FilteredRelation, Q\n from django.db.models.sql.constants import CURSOR, GET_ITERATOR_CHUNK_SIZE\n                 when_statements = []\n                 for obj in batch_objs:\n                     attr = getattr(obj, field.attname)\nif not hasattr(attr, 'resolve_expression'):\n                         attr = Value(attr, output_field=field)\n                     when_statements.append(When(pk=obj.pk, then=attr))\n                 case_statement = Case(*when_statements, output_field=field)\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is testing a Django model with a bulk update using F expressions. It defines a model 'SelfRef' with fields 'name' and 'c8', creates an instance of the model, updates one of its fields using an F expression, and checks the results by refreshing the object from the database. Additionally, it prints the executed SQL queries for verification. Meanwhile, the code in code sample 2 is a segment of a Django query handling method which gathers 'when_statements' for a case statement using a loop over 'batch_objs' to assign attributes with appropriate values. It checks the type of each attribute to determine if it requires wrapping in a Value object. Both code samples are working with Django models, but code sample 1 is a standalone testing script, while code sample 2 is part of a larger query handling methodology. The structural similarities are mostly around handling 'when_statements' and utilizing the 'Case' and 'When' constructs from Django's ORM.\", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share the same core logic for creating 'when_statements', but the context of usage and surrounding code is different, which introduces modifications and additional statements in the second sample.\"}"
}