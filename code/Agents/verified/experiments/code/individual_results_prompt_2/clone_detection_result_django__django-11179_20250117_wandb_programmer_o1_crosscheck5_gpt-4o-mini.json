{
    "instance_id": "django__django-11179",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/deletion.py": "index 92fe4affb9..5353d10ade 100644\n         # sort instance collections\n         for model, instances in self.data.items():\n             self.data[model] = sorted(instances, key=attrgetter(\"pk\"))\n\n         # if possible, bring the models in an order suitable for databases that\n         # don't support transactions or cannot defer constraint checks until the\n         # end of a transaction.\n         self.sort()\n         # number of objects deleted for each model label\n         deleted_counter = Counter()\n\n         # Optimize for the case with a single obj and no dependencies\n         if len(self.data) == 1 and len(instances) == 1:\n             instance = list(instances)[0]\n             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\nsetattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n\n         with transaction.atomic(using=self.using, savepoint=False):\n             # send pre_delete signals\n             for model, obj in self.instances_with_model():\n                     signals.pre_delete.send(\n                         sender=model, instance=obj, using=self.using\n                     )\n\n             # fast deletes\n             for qs in self.fast_deletes:\n                 count = qs._raw_delete(using=self.using)\n                 deleted_counter[qs.model._meta.label] += count\n\n             # update fields\n             for model, instances_for_fieldvalues in self.field_updates.items():\n                 for (field, value), instances in instances_for_fieldvalues.items():\n                     query = sql.UpdateQuery(model)\n                     query.update_batch([obj.pk for obj in instances],\n                                        {field.name: value}, self.using)\n\n             # reverse instance collections\n             for instances in self.data.values():\n                 instances.reverse()\n\n             # delete instances\n             for model, instances in self.data.items():\n                 query = sql.DeleteQuery(model)\n                 pk_list = [obj.pk for obj in instances]\n                 count = query.delete_batch(pk_list, self.using)\n                 deleted_counter[model._meta.label] += count\n\n                 if not model._meta.auto_created:\n                     for obj in instances:\n                         signals.post_delete.send(\n                             sender=model, instance=obj, using=self.using\n                         )\n\n         # update collected instances\n         for instances_for_fieldvalues in self.field_updates.values():\n             for (field, value), instances in instances_for_fieldvalues.items():\n             for instance in instances:\n                 setattr(instance, model._meta.pk.attname, None)\n         return sum(deleted_counter.values()), dict(deleted_counter)\n\n",
        "test_pk_delete.py": "new file mode 100644\nindex 0000000000..d3d1ba17cd\nimport sys\nimport django\nimport traceback\nfrom django.conf import settings\nfrom django.db import models, connection\n\nprint(\"Starting test script to verify if PK is cleared after delete with no dependencies.\")\ntry:\nsettings.configure(\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:'\n}\n},\nINSTALLED_APPS=[],\nSECRET_KEY='test_secret_key'\n)\ndjango.setup()\n\nclass MyTestModel(models.Model):\nname = models.CharField(max_length=100)\n\nclass Meta:\napp_label = '__main__'  # no dependencies\n\n# Create table.\nwith connection.schema_editor() as editor:\neditor.create_model(MyTestModel)\n\n# Create a model instance and delete it.\nobj = MyTestModel.objects.create(name='TestObj')\nprint(f\"Created object with PK={obj.pk}\")\n\nobj.delete()\nprint(f\"Object PK after delete: {obj.pk}\")\nif obj.pk is not None:\nprint(\"FAIL: PK is not cleared after .delete()\")\nsys.exit(1)\nelse:\nprint(\"PASS: PK is None after .delete()\")\nsys.exit(0)\n\nexcept Exception as e:\nprint(\"ERROR during test execution!\")\ntraceback.print_exc()\nsys.exit(2)\n"
    },
    "ground_truth_patch": {
        "django/db/models/deletion.py": "             if self.can_fast_delete(instance):\n                 with transaction.mark_for_rollback_on_error():\n                     count = sql.DeleteQuery(model).delete_batch([instance.pk], self.using)\nsetattr(instance, model._meta.pk.attname, None)\n                 return count, {model._meta.label: count}\n \n         with transaction.atomic(using=self.using, savepoint=False):\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is part of a method that handles deleting a batch of instances from the database, including sorting instances, managing transactions, sending pre and post delete signals, and updating fields accordingly. It features detailed logic for handling fast deletion when possible and also updates collected instance records after deletion. Conversely, the code in code sample 2 extracts a specific section from that larger method, which checks if a single instance can be fast deleted, handles transaction rollback, performs the deletion, and updates the primary key of the instance to None if the deletion succeeds. Essentially, code sample 2 includes a subset of functionality from code sample 1, specifically pertaining to the deletion logic. \", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they are syntactically similar and the second sample is directly derived from a portion of the first sample, containing added or modified statements but retaining the core functionality.\"}"
}