{
    "instance_id": "matplotlib__matplotlib-20826",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index a334bf2874..b052ddac06 100644\n lib/matplotlib/backends/web_backend/package-lock.json\n \n LICENSE/LICENSE_QHULL\n.aider/\n",
        "lib/matplotlib/axes/_base.py": "index 802fd3c997..1755eed012 100644\n \n         xaxis_visible = self.xaxis.get_visible()\n         yaxis_visible = self.yaxis.get_visible()\n\n# Store label visibilities\nx_label_visible = self.xaxis.label.get_visible()\ny_label_visible = self.yaxis.label.get_visible()\nx_ticklabels_visible = self.xaxis.get_major_ticks()[0].label1.get_visible() if self.xaxis.get_major_ticks() else True\ny_ticklabels_visible = self.yaxis.get_major_ticks()[0].label1.get_visible() if self.yaxis.get_major_ticks() else True\n \n         self.xaxis.clear()\n         self.yaxis.clear()\n         if mpl.rcParams['ytick.minor.visible']:\n             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())\n \n# Restore visibility states\nself.xaxis.set_visible(xaxis_visible)\nself.yaxis.set_visible(yaxis_visible)\nself.xaxis.label.set_visible(x_label_visible)\nself.yaxis.label.set_visible(y_label_visible)\n\n# Restore tick label visibility\nif self.xaxis.get_major_ticks():\nfor tick in self.xaxis.get_major_ticks():\ntick.label1.set_visible(x_ticklabels_visible)\nif self.yaxis.get_major_ticks():\nfor tick in self.yaxis.get_major_ticks():\ntick.label1.set_visible(y_ticklabels_visible)\n\n         if self._sharex is None:\n             self._autoscaleXon = True\n         if self._sharey is None:\n",
        "reproduce_bug.png": "new file mode 100644\nindex 0000000000..920f320f4e\nBinary files /dev/null and b/reproduce_bug.png differ\n",
        "reproduce_bug.py": "new file mode 100644\nindex 0000000000..2639308649\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(2, 2, sharex=True, sharey=True)\n\nx = np.arange(0.0, 2*np.pi, 0.01)\ny = np.sin(x)\n\nfor ax in axes.flatten():\nax.clear()\nax.plot(x, y)\n\nplt.savefig('reproduce_bug.png')\n",
        "test1_shared_axes.png": "new file mode 100644\nindex 0000000000..920f320f4e\nBinary files /dev/null and b/test1_shared_axes.png differ\n",
        "test2_mixed_sharing.png": "new file mode 100644\nindex 0000000000..f6c990d501\nBinary files /dev/null and b/test2_mixed_sharing.png differ\n",
        "test3_no_sharing.png": "new file mode 100644\nindex 0000000000..df3d5ab8eb\nBinary files /dev/null and b/test3_no_sharing.png differ\n",
        "test4_multiple_clear.png": "new file mode 100644\nindex 0000000000..7d48b3f63b\nBinary files /dev/null and b/test4_multiple_clear.png differ\n",
        "test_cases.py": "new file mode 100644\nindex 0000000000..92e08fcd33\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Test Case 1: Basic shared axes\nfig1, axes1 = plt.subplots(2, 2, sharex=True, sharey=True)\nx = np.arange(0.0, 2*np.pi, 0.01)\ny = np.sin(x)\nfor ax in axes1.flatten():\nax.clear()\nax.plot(x, y)\nplt.savefig('test1_shared_axes.png')\n\n# Test Case 2: Mixed sharing (only x shared)\nfig2, axes2 = plt.subplots(2, 2, sharex=True, sharey=False)\nfor ax in axes2.flatten():\nax.clear()\nax.plot(x, y)\nplt.savefig('test2_mixed_sharing.png')\n\n# Test Case 3: No sharing\nfig3, axes3 = plt.subplots(2, 2, sharex=False, sharey=False)\nfor ax in axes3.flatten():\nax.clear()\nax.plot(x, y)\nplt.savefig('test3_no_sharing.png')\n",
        "test_multiple_clear.py": "new file mode 100644\nindex 0000000000..13350c4b7d\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Test Case 4: Multiple clear() calls\nfig4, axes4 = plt.subplots(2, 2, sharex=True, sharey=True)\nx = np.arange(0.0, 2*np.pi, 0.01)\ny = np.sin(x)\n\n# First clear and plot\nfor ax in axes4.flatten():\nax.clear()\nax.plot(x, y)\n\n# Second clear and plot\nfor ax in axes4.flatten():\nax.clear()\nax.plot(x, 2*y)\n\nplt.savefig('test4_multiple_clear.png')\n"
    },
    "ground_truth_patch": {
        "lib/matplotlib/axis.py": "         # Clear the callback registry for this axis, or it may \"leak\"\n         self.callbacks = cbook.CallbackRegistry()\n \n# whether the grids are on\nself._major_tick_kw['gridOn'] = (\nmpl.rcParams['axes.grid'] and\nmpl.rcParams['axes.grid.which'] in ('both', 'major'))\nself._minor_tick_kw['gridOn'] = (\nmpl.rcParams['axes.grid'] and\nmpl.rcParams['axes.grid.which'] in ('both', 'minor'))\n         self.reset_ticks()\n \n         self.converter = None\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 mainly handles the visibility and resetting of axes properties in a plotting context using Matplotlib. It gets the visibility states of the x and y axes, restores them, and manages the visibility of tick labels. The second code sample manages callback registrations and the states of grid-related configurations for axes in a plotting library. It clears the callback registry and checks whether grids are enabled for major and minor ticks, resetting ticks afterward.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they deal with different functionalities in the Matplotlib library, focusing on distinct aspects of axis handling and callback management, and they do not share similarities in structure or purpose.\"}"
}