{
    "instance_id": "matplotlib__matplotlib-25332",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index 3ba7f8a9eb..92d0cc6b46 100644\n lib/matplotlib/backends/web_backend/package-lock.json\n \n LICENSE/LICENSE_QHULL\n.aider/\n",
        "lib/matplotlib/cbook.py": "index c9699b2e21..7f4e2c5001 100644\n         siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n         return [x() for x in siblings]\n \ndef __getstate__(self):\n\"\"\"Convert weak references to strong references for pickling.\"\"\"\nclean_mapping = {}\nfor key, val in self._mapping.items():\nif key() is not None:\nclean_mapping[key()] = [x() for x in val if x() is not None]\nreturn {'mapping': clean_mapping}\n\ndef __setstate__(self, state):\n\"\"\"Restore weak references when unpickling.\"\"\"\nself._mapping = {weakref.ref(k): [weakref.ref(x) for x in v] \nfor k, v in state['mapping'].items()}\n\n \n class GrouperView:\n     \"\"\"Immutable view over a `.Grouper`.\"\"\"\n"
    },
    "ground_truth_patch": {
        "lib/matplotlib/cbook.py": "     def __init__(self, init=()):\n         self._mapping = {weakref.ref(x): [weakref.ref(x)] for x in init}\n \ndef __getstate__(self):\nreturn {\n**vars(self),\n# Convert weak refs to strong ones.\n\"_mapping\": {k(): [v() for v in vs] for k, vs in self._mapping.items()},\n}\n\ndef __setstate__(self, state):\nvars(self).update(state)\n# Convert strong refs to weak ones.\nself._mapping = {weakref.ref(k): [*map(weakref.ref, vs)]\nfor k, vs in self._mapping.items()}\n\n     def __contains__(self, item):\n         return weakref.ref(item) in self._mapping\n \n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines methods for pickling and unpickling a dictionary stored in `_mapping`, which uses weak references to avoid memory leaks. The `__getstate__` method converts any weak references to strong references for serialization, while `__setstate__` restores the weak references from a deserialized state. The class `GrouperView` encapsulates this behavior. In contrast, the code in code sample 2 also includes methods for pickling and unpickling, but it uses a different approach in handling the `_mapping`. It simplifies the conversion process and contains an additional `__contains__` method to check for item membership. As such, it modifies the original functionality significantly.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they have different implementations and add functionalities, particularly with the presence of the `__contains__` method and the way they handle weak references.\"}"
}