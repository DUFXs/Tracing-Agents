{
    "instance_id": "django__django-13128",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/expressions.py": "index d913658291..90d3f6b6b7 100644\n     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n         c = self.copy()\n         c.is_summary = summarize\n# Resolve subexpressions first.\n         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n# Only attempt to convert to TemporalSubtraction if we're really a CombinedExpression,\n# not a subclass like TemporalSubtraction, to avoid infinite recursion.\nif type(self) is CombinedExpression:\ntry:\nlhs_type = c.lhs.output_field.get_internal_type()\nrhs_type = c.rhs.output_field.get_internal_type()\nexcept (AttributeError, FieldError):\nreturn c\ndatetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\nif c.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\n# Return a TemporalSubtraction that also has its subexpressions resolved.\nreturn TemporalSubtraction(c.lhs, c.rhs).resolve_expression(query, allow_joins, reuse, summarize, for_save)\n         return c\n\n\n \n \n class DurationExpression(CombinedExpression):\n         rhs = compiler.compile(self.rhs)\n         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)\n \ndef get_source_expressions(self):\n# Don\u2019t expose datetime subexpressions so unification sees only DurationField.\nreturn []\n\ndef get_source_fields(self):\n# Temporally subtracting two datetime fields yields a duration.\nreturn [self.output_field]\n\n\n\n \n @deconstructible\n class F(Combinable):\n",
        "migrations/0001_initial.py": "new file mode 100644\nindex 0000000000..c92ae068c6\n# Generated by Django 3.2 on 2025-01-13 04:36\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\ninitial = True\n\ndependencies = [\n]\n\noperations = [\nmigrations.CreateModel(\nname='Experiment',\nfields=[\n('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n('start', models.DateTimeField()),\n('end', models.DateTimeField()),\n],\n),\n]\n",
        "migrations/__init__.py": "new file mode 100644\nindex 0000000000..e69de29bb2\n",
        "test_temporal_subtraction_bug.py": "new file mode 100644\nindex 0000000000..8cd35cf8b3\nimport sys\nimport datetime\nfrom django.conf import settings\nfrom django.db import models, connection\nfrom django import setup\n\ndef main():\nprint(\"Setting up Django in-memory test for temporal subtraction bug.\")\nsettings.configure(\nINSTALLED_APPS=[\"__main__\"],\nDATABASES={\"default\": {\"ENGINE\": \"django.db.backends.sqlite3\", \"NAME\": \":memory:\"}},\nSECRET_KEY=\"abc123\",\n)\nsetup()\n\nclass Experiment(models.Model):\nstart = models.DateTimeField()\nend = models.DateTimeField()\nclass Meta:\napp_label = \"__main__\"\n\nprint(\"Creating table for Experiment model via schema_editor...\")\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(Experiment)\n\ntry:\nprint(\"Creating data and running problematic query...\")\ne = Experiment.objects.create(\nstart=datetime.datetime(2023, 1, 1, 12, 0, 0),\nend=datetime.datetime(2023, 1, 1, 14, 30, 0),\n)\nfrom django.db.models import F, Value, DurationField\nqs = Experiment.objects.annotate(\ndelta=F(\"end\") - F(\"start\") + Value(datetime.timedelta(), output_field=DurationField())\n)\nresults = list(qs)\nfor obj in results:\nprint(f\"experiment ID={obj.id}, delta={obj.delta}\")\nprint(\"No FieldError encountered. Test passes => bug is fixed.\")\nsys.exit(0)\nexcept Exception as ex:\nprint(f\"Error encountered: {ex}\")\nprint(\"Bug present => test fails.\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/models/expressions.py": "         self.lhs, self.rhs = exprs\n \n     def as_sql(self, compiler, connection):\n         expressions = []\n         expression_params = []\n         sql, params = compiler.compile(self.lhs)\n         return expression_wrapper % sql, expression_params\n \n     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\nlhs = self.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\nrhs = self.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\nif not isinstance(self, (DurationExpression, TemporalSubtraction)):\ntry:\nlhs_type = lhs.output_field.get_internal_type()\nexcept (AttributeError, FieldError):\nlhs_type = None\ntry:\nrhs_type = rhs.output_field.get_internal_type()\nexcept (AttributeError, FieldError):\nrhs_type = None\nif 'DurationField' in {lhs_type, rhs_type} and lhs_type != rhs_type:\nreturn DurationExpression(self.lhs, self.connector, self.rhs).resolve_expression(\nquery, allow_joins, reuse, summarize, for_save,\n)\ndatetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\nif self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\nreturn TemporalSubtraction(self.lhs, self.rhs).resolve_expression(\nquery, allow_joins, reuse, summarize, for_save,\n)\n         c = self.copy()\n         c.is_summary = summarize\nc.lhs = lhs\nc.rhs = rhs\n         return c\n \n \n         return compiler.compile(side)\n \n     def as_sql(self, compiler, connection):\nif connection.features.has_native_duration_field:\nreturn super().as_sql(compiler, connection)\n         connection.ops.check_expression_support(self)\n         expressions = []\n         expression_params = []\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a method `resolve_expression` that handles the resolution of expressions in a Django ORM context, specifically focusing on `CombinedExpression` and how to manage its left-hand side (lhs) and right-hand side (rhs) expressions by resolving them recursively and handling specific cases for `DurationField`. It also includes a class `DurationExpression` that deals with the database operations and model fields. On the other hand, code sample 2 contains a similar method `resolve_expression`, but with a different structure and flow, and it checks fields for duration, and also handles the compilation of SQL expressions differently, focusing on lhs and rhs resolution too. Although both samples are working in the context of expressions, code sample 2 has a more complex structure and additional checks for expression support, which shows substantial differences in implementation. Thus, they share some similar functionalities but differ significantly in structure and logic.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they exhibit substantial differences in structure, flow, and additional logic applied despite a similar overall functional goal.\"}"
}