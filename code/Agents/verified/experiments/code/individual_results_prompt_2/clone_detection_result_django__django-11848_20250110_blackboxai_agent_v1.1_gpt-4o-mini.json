{
    "instance_id": "django__django-11848",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index 238fb3a200..521baaa795 100644\n tests/.coverage\n build/\n tests/report/\n.aider/\n",
        "django/utils/http.py": "index 572cfb4347..a59bf3b981 100644\n     try:\n         year = int(m.group('year'))\n         if year < 100:\n# RFC 7231: Recipients of a timestamp value in rfc850-date format, which uses a\n# two-digit year, MUST interpret a timestamp that appears to be more than 50 years\n# in the future as representing the most recent year in the past that had the\n# same last two digits.\ncurrent_year = datetime.datetime.utcnow().year\ncurrent_century = (current_year // 100) * 100\ncandidate_year = current_century + year\n\n# According to RFC 7231, if the year would be more than 50 years in the future,\n# we should interpret it as being in the past century instead.\n# For example, if current year is 2023:\n# - '24' becomes 2024 (less than 50 years in future)\n# - '73' becomes 1973 (2073 would be 50 years in future)\n# - '99' becomes 1999 (2099 would be 76 years in future)\n\n# First try interpreting it in current century\nthis_century = current_century + year\n\n# Check if using current century would make it appear to be\n# more than 50 years in the future from the current year.\n# Note: RFC says \"more than 50 years in the future\", so we\n# strictly check for more than 50 years ahead.\nif this_century > current_year + 50:\nyear = this_century - 100\n             else:\nyear = this_century\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n"
    },
    "ground_truth_patch": {
        "django/utils/http.py": "     try:\n         year = int(m.group('year'))\n         if year < 100:\ncurrent_year = datetime.datetime.utcnow().year\ncurrent_century = current_year - (current_year % 100)\nif year - (current_year % 100) > 50:\n# year that appears to be more than 50 years in the future are\n# interpreted as representing the past.\nyear += current_century - 100\n             else:\nyear += current_century\n         month = MONTHS.index(m.group('mon').lower()) + 1\n         day = int(m.group('day'))\n         hour = int(m.group('hour'))\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 identifies a year from a given input, checks if it is a two-digit year, and if so, it calculates the candidate year based on the current year, evaluating if the year is more than 50 years in the future to adjust accordingly. It uses constants and logic adhering to the RFC guidelines for interpreting the year correctly. On the other hand, code sample 2 performs similar operations but utilizes slightly altered calculations for the current century and adjusts the year using different arithmetic. The logic is fundamentally similar but has changes in details and values.\", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they are syntactically similar and share similar functionality, but there are modifications in statements and calculations that distinguish them.\"}"
}