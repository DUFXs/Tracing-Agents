{
    "instance_id": "psf__requests-5414",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "requests/models.py": "index e7d292d5..4df8e033 100644\n             url = url.decode('utf8')\n         else:\n             url = unicode(url) if is_py2 else str(url)\n\n         # Remove leading whitespaces from url\n         url = url.lstrip()\n\n         # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n         # `data` etc to work around exceptions from `url_parse`, which\n         # handles RFC 3986 only.\n         if ':' in url and not url.lower().startswith('http'):\n             self.url = url\n             return\n\n         # Support for unicode domain names and paths.\n         try:\n             scheme, auth, host, port, path, query, fragment = parse_url(url)\n         except LocationParseError as e:\n             raise InvalidURL(*e.args)\n\n         if not scheme:\n             error = (\"Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?\")\n             error = error.format(to_native_string(url, 'utf8'))\n             raise MissingSchema(error)\n\n         if not host:\n             raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n\n         # In general, we want to try IDNA encoding the hostname if the string contains\n         # non-ASCII characters. This allows users to automatically get the correct IDNA\n         # behaviour. For strings containing only ASCII characters, we need to also verify\n                 raise InvalidURL('URL has an invalid label.')\n         elif host.startswith(u'*'):\n             raise InvalidURL('URL has an invalid label.')\n\n# Ensure we don't have an empty label (leading dot, double dot, etc.)\nif any(len(label) == 0 for label in host.split('.')):\nraise InvalidURL('URL has an invalid label.')\n\n         # Carefully reconstruct the network location\n         netloc = auth or ''\n         if netloc:\n         netloc += host\n         if port:\n             netloc += ':' + str(port)\n\n         # Bare domains aren't valid URLs.\n         if not path:\n             path = '/'\n\n         if is_py2:\n             if isinstance(scheme, str):\n                 scheme = scheme.encode('utf-8')\n                 query = query.encode('utf-8')\n             if isinstance(fragment, str):\n                 fragment = fragment.encode('utf-8')\n\n         if isinstance(params, (str, bytes)):\n             params = to_native_string(params)\n\n         enc_params = self._encode_params(params)\n         if enc_params:\n             if query:\n                 query = '%s&%s' % (query, enc_params)\n             else:\n                 query = enc_params\n\n         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))\n         self.url = url\n\n \n     def prepare_headers(self, headers):\n         \"\"\"Prepares the given HTTP headers.\"\"\"\n",
        "test_leading_dot_domain.py": "new file mode 100644\nindex 00000000..c1433211\n#!/usr/bin/env python\nimport sys\nimport traceback\nimport requests\n\ndef main():\nprint(\"Testing leading dot domain scenario: 'http://.example.com'\")\ntry:\nrequests.get(\"http://.example.com\")\nprint(\"FAIL: Did not raise an exception\")\nsys.exit(1)\nexcept requests.exceptions.InvalidURL:\nprint(\"PASS: Got InvalidURL as expected\")\nsys.exit(0)\nexcept Exception as e:\nprint(\"FAIL: Got exception other than InvalidURL:\", e)\ntraceback.print_exc()\nsys.exit(1)\n\nif __name__ == '__main__':\nmain()\n"
    },
    "ground_truth_patch": {
        "requests/models.py": "                 host = self._get_idna_encoded_host(host)\n             except UnicodeError:\n                 raise InvalidURL('URL has an invalid label.')\nelif host.startswith((u'*', u'.')):\n             raise InvalidURL('URL has an invalid label.')\n \n         # Carefully reconstruct the network location\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is part of the URL handling in a requests library where it decodes URLs and handles validation, particularly for invalid or poorly formatted URLs. The code ensures that the hostname is correctly formatted and contains checks for empty labels, leading dots, and proper encoding for different Python versions. The code sample then reconstructs the network location appropriately. In contrast, code sample 2 focuses on error handling for invalid URLs, specifically with leading dot domains like 'http://.example.com'. It tests this scenario using a main function that attempts to make a request to this URL and expects to catch the InvalidURL exception raised by the library.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because code sample 1 is implementing URL validation logic while code sample 2 is a test case scenario that checks for the behavior of the library when invalid URLs are encountered. They serve different purposes and functionalities.\"}"
}