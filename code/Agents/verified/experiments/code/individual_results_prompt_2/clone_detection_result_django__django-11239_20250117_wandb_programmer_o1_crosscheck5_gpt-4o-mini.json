{
    "instance_id": "django__django-11239",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/backends/postgresql/client.py": "index cf4df76882..4f036cc8d1 100644\n \n     @classmethod\n     def runshell_db(cls, conn_params):\nimport os\nimport signal\nimport subprocess\n\n         args = [cls.executable_name]\n\n         host = conn_params.get('host', '')\n         port = conn_params.get('port', '')\n         dbname = conn_params.get('database', '')\n         user = conn_params.get('user', '')\n         passwd = conn_params.get('password', '')\n\n# The ssl keys in get_connection_params() are merged into the top-level dict.\nsslrootcert = conn_params.get('sslrootcert')\nsslcert = conn_params.get('sslcert')\nsslkey = conn_params.get('sslkey')\nsslmode = conn_params.get('sslmode')\n\n         if user:\n             args += ['-U', user]\n         if host:\n         if port:\n             args += ['-p', str(port)]\n         args += [dbname]\n\n         sigint_handler = signal.getsignal(signal.SIGINT)\n         subprocess_env = os.environ.copy()\n         if passwd:\n             subprocess_env['PGPASSWORD'] = str(passwd)\n\n# TLS environment variables\nif sslrootcert:\nsubprocess_env['PGSSLROOTCERT'] = sslrootcert\nif sslcert:\nsubprocess_env['PGSSLCERT'] = sslcert\nif sslkey:\nsubprocess_env['PGSSLKEY'] = sslkey\nif sslmode:\nsubprocess_env['PGSSLMODE'] = sslmode\n\n         try:\n             # Allow SIGINT to pass to psql to abort queries.\n             signal.signal(signal.SIGINT, signal.SIG_IGN)\n         finally:\n             # Restore the original SIGINT handler.\n             signal.signal(signal.SIGINT, sigint_handler)\n\n\n \n     def runshell(self):\n         DatabaseClient.runshell_db(self.connection.get_connection_params())\n",
        "test_postgres_tls.py": "new file mode 100644\nindex 0000000000..67ff7febc5\nprint(\"Starting test_postgres_tls.py\")\n\nimport sys\nimport os\nimport django\nfrom django.conf import settings\nfrom django.db import connections\nimport subprocess\n\nprint(\"Configuring Django settings with SSL param in OPTIONS...\")\n\ntest_db_config = {\n'ENGINE': 'django.db.backends.postgresql',\n'NAME': 'some_db',\n'USER': 'some_user',\n'HOST': 'localhost',\n'OPTIONS': {\n'sslrootcert': 'test_ca.crt',\n'sslcert': 'test_client.crt',\n'sslkey': 'test_client.key',\n'sslmode': 'require'\n}\n}\n\nprint(\"Applying settings.configure...\")\n\nsettings.configure(\nDATABASES={\n'default': test_db_config\n},\nSECRET_KEY='dummy-key',\nINSTALLED_APPS=[]\n)\ndjango.setup()\n\nprint(\"Patching subprocess.run to capture environment...\")\n\nold_run = subprocess.run\n\ndef patched_run(args, check, env=None):\nprint(\"Inside patched_run. Checking environment variables for TLS support...\")\nsslrootcert = env.get('PGSSLROOTCERT', None)\nsslcert = env.get('PGSSLCERT', None)\nsslkey = env.get('PGSSLKEY', None)\nsslmode = env.get('PGSSLMODE', None)\nprint(\"PGSSLROOTCERT =\", sslrootcert)\nprint(\"PGSSLCERT     =\", sslcert)\nprint(\"PGSSLKEY      =\", sslkey)\nprint(\"PGSSLMODE     =\", sslmode)\n\nif None in [sslrootcert, sslcert, sslkey, sslmode]:\nprint(\"ERROR: Not all TLS environment variables found, test fails.\")\nsys.exit(1)\nprint(\"All TLS environment variables found, test passes.\")\nsys.exit(0)\n\nsubprocess.run = patched_run\n\nprint(\"Invoking dbshell...\")\n\ntry:\nconnections['default'].client.runshell()\nexcept SystemExit as e:\nprint(\"SystemExit with code\", e.code)\nsys.exit(e.code)\nfinally:\nsubprocess.run = old_run\n\nprint(\"Somehow we didn't exit in patched_run. This is unexpected.\")\nsys.exit(1)\n"
    },
    "ground_truth_patch": {
        "django/db/backends/postgresql/client.py": "         dbname = conn_params.get('database', '')\n         user = conn_params.get('user', '')\n         passwd = conn_params.get('password', '')\nsslmode = conn_params.get('sslmode', '')\nsslrootcert = conn_params.get('sslrootcert', '')\nsslcert = conn_params.get('sslcert', '')\nsslkey = conn_params.get('sslkey', '')\n \n         if user:\n             args += ['-U', user]\n         subprocess_env = os.environ.copy()\n         if passwd:\n             subprocess_env['PGPASSWORD'] = str(passwd)\nif sslmode:\nsubprocess_env['PGSSLMODE'] = str(sslmode)\nif sslrootcert:\nsubprocess_env['PGSSLROOTCERT'] = str(sslrootcert)\nif sslcert:\nsubprocess_env['PGSSLCERT'] = str(sslcert)\nif sslkey:\nsubprocess_env['PGSSLKEY'] = str(sslkey)\n         try:\n             # Allow SIGINT to pass to psql to abort queries.\n             signal.signal(signal.SIGINT, signal.SIG_IGN)\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a class method 'runshell_db' that constructs a command-line instruction to run a PostgreSQL shell using parameters from a provided connection dictionary. It gathers various SQL connection parameters, sets environment variables including password and SSL certificates, and handles signal interruptions. Additionally, it contains a method 'runshell' that calls 'runshell_db' using the connection parameters. In contrast, the code in code sample 2 appears to involve snippet changes within the same method or function context, dealing with similar SQL connection parameters and environment variable handling, but it starts from different lines and organizes some statements differently without wrapping the entire logic in a method like 'runshell_db'.\", \"is_clone\": true, \"classification\": \"type-2\", \"reasoning\": \"These code samples are type-2 clones because they perform the same operational logic using similar constructs, differing mainly in the whitespace as well as slight changes in how the parameters and environment variables are organized.\"}"
}