{
    "instance_id": "django__django-11999",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/fields/__init__.py": "index ee45bb941e..e17f1d7bdc 100644\n     def contribute_to_class(self, cls, name, private_only=False):\n         \"\"\"\n         Register the field with the model class it belongs to.\n\n         If private_only is True, create a separate instance of this field\n         for every subclass of cls, even if cls is not an abstract model.\n         \"\"\"\n             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\nmethod_name = 'get_%s_display' % self.name\n# Only create the auto method if it doesn't already exist.\nif not hasattr(cls, method_name):\nfrom functools import partialmethod\nsetattr(cls, method_name, partialmethod(cls._get_FIELD_display, field=self))\n\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n",
        "test_get_field_display_override.py": "new file mode 100644\nindex 0000000000..59c70c95e5\nimport sys\nimport django\nfrom django.conf import settings\nfrom django.db import models\n\ndef main():\n# Provide minimal settings:\nif not settings.configured:\nsettings.configure(\nINSTALLED_APPS=[],\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\n)\ndjango.setup()\n\nclass FooBarOverride(models.Model):\nfoo_bar = models.CharField(\nmax_length=2,\nchoices=(('1', 'foo'), ('2', 'bar')),\n)\ndef get_foo_bar_display(self):\nreturn \"something\"\n\nclass Meta:\napp_label = \"my_fake_app\"\n\nprint(\"Begin test: get_FIELD_display override check.\")\ninst = FooBarOverride()\ninst.foo_bar = '1'\nval = inst.get_foo_bar_display()\nprint(f\"Value returned from inst.get_foo_bar_display(): {val!r}\")\nif val == \"something\":\nprint(\"Test passes: The override is respected.\")\nsys.exit(0)\nelse:\nprint(\"Test fails: The override is NOT respected.\")\nsys.exit(1)\n\nif __name__ == '__main__':\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/models/fields/__init__.py": "             if not getattr(cls, self.attname, None):\n                 setattr(cls, self.attname, self.descriptor_class(self))\n         if self.choices is not None:\nif not hasattr(cls, 'get_%s_display' % self.name):\nsetattr(\ncls,\n'get_%s_display' % self.name,\npartialmethod(cls._get_FIELD_display, field=self),\n)\n \n     def get_filter_kwargs_for_object(self, obj):\n         \"\"\"\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 provides a method `contribute_to_class` that registers a field with a model class in Django and a method `get_filter_kwargs_for_object`. Code sample 2 focuses on the check for an instance variable and uses similar logic with fewer lines, but both snippets include parts of the `contribute_to_class` method. However, code sample 2 is just a fragment showing part of the same method that is in code sample 1.\", \"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical except for whitespace and minor formatting differences.\"}"
}