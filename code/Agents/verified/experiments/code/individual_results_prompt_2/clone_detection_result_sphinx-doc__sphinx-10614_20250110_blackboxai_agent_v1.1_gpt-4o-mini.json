{
    "instance_id": "sphinx-doc__sphinx-10614",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index a2f7d63b3..7d051e7b3 100644\n utils/regression_test.js\n \n node_modules/\n.aider/\n",
        "sphinx/ext/graphviz.py": "index 8b21d9e3b..ff265c66b 100644\n \n def fix_svg_relative_paths(self: SphinxTranslator, filepath: str) -> None:\n     \"\"\"Change relative links in generated svg files to be relative to imgpath.\"\"\"\ntree = ET.parse(filepath)\n     root = tree.getroot()\n \n# Add xlink namespace if not present\nif 'xmlns:xlink' not in root.attrib:\nroot.set('xmlns:xlink', 'http://www.w3.org/1999/xlink')\n\n# Process all nodes with URL attributes\nfor elem in root.findall('.//*[@URL]'):\nurl = elem.attrib['URL']\nif '://' not in url:  # Only fix relative URLs\nold_path = path.join(self.builder.outdir, url)\nnew_path = path.relpath(\nold_path,\nstart=path.join(self.builder.outdir, self.builder.imgpath),\n)\n# Create an anchor element\na = ET.Element('a')\na.set('xlink:href', new_path)\na.set('target', '_top')\n\n# Move all children to anchor\nfor child in list(elem):\nelem.remove(child)\na.append(child)\n\n# Add anchor to parent\nelem.append(a)\n\n# Remove URL attribute\ndel elem.attrib['URL']\n\ntree.write(filepath, encoding='utf-8', xml_declaration=True)\n \n \n def render_dot(self: SphinxTranslator, code: str, options: dict, format: str,\n \n     dot_args = [graphviz_dot]\n     dot_args.extend(self.builder.config.graphviz_dot_args)\nif format == 'svg':\n# Use native SVG output with clickable links\ndot_args.extend(['-Tsvg:cairo', '-o' + outfn])\nelse:\ndot_args.extend(['-T' + format, '-o' + outfn])\n \n     docname = options.get('docname', 'index')\n     if filename:\n                                '[stdout]\\n%r') % (ret.stderr, ret.stdout))\n \n     if format == 'svg':\n# Fix SVG paths and add clickable links\n         fix_svg_relative_paths(self, outfn)\n\n# Parse and modify SVG to add links\ntree = ET.parse(outfn)  # NoQA: S314\nroot = tree.getroot()\n\n# Add xlink namespace if not present\nif 'xmlns:xlink' not in root.attrib:\nroot.set('xmlns:xlink', 'http://www.w3.org/1999/xlink')\n\n# Find all nodes with URL attributes and wrap them with anchor tags\nfor node in root.findall('.//g[@class=\"node\"]'):\nnode_attrs = {}\nfor attr in node.attrib:\nif attr.startswith('URL=') or attr.startswith('href='):\nvalue = node.attrib[attr].strip('\"')\nnode_attrs[attr.split('=')[0]] = value\ndel node.attrib[attr]\n\nif node_attrs:\n# Create an anchor element and wrap the node content\na = ET.Element('a')\na.set('xlink:href', node_attrs.get('URL', node_attrs.get('href', '')))\na.set('target', '_top')\n\n# Move node's children to anchor\nfor child in list(node):\nnode.remove(child)\na.append(child)\n\n# Add anchor to node\nnode.append(a)\n\n# Write back the modified SVG\ntree.write(outfn, encoding='utf-8', xml_declaration=True)\n \n     return relfn, outfn\n \n         if 'align' in node:\n             self.body.append('<div align=\"%s\" class=\"align-%s\">' %\n                              (node['align'], node['align']))\nif format.upper() == 'SVG':\n# For SVG, use object tag to maintain SVG interactivity\n             self.body.append('<div class=\"graphviz\">')\n             self.body.append('<object data=\"%s\" type=\"image/svg+xml\" class=\"%s\">\\n' %\n(fname, imgcls))\n             self.body.append('<p class=\"warning\">%s</p>' % alt)\n             self.body.append('</object></div>\\n')\n         else:\n                     # has a map\n                     self.body.append('<div class=\"graphviz\">')\n                     self.body.append('<img src=\"%s\" alt=\"%s\" usemap=\"#%s\" class=\"%s\" />' %\n(fname, alt, imgmap.id, imgcls))\n                     self.body.append('</div>\\n')\n                     self.body.append(imgmap.generate_clickable_map())\n                 else:\n                     # nothing in image map\n                     self.body.append('<div class=\"graphviz\">')\n                     self.body.append('<img src=\"%s\" alt=\"%s\" class=\"%s\" />' %\n(fname, alt, imgcls))\n                     self.body.append('</div>\\n')\n         if 'align' in node:\n             self.body.append('</div>\\n')\n",
        "sphinx/ext/inheritance_diagram.py": "index 6e3985512..cb0ea2fd9 100644\n     from all the way to the root \"object\", and then is able to generate a\n     graphviz dot graph from them.\n     \"\"\"\n_node_attrs = {\n'shape': 'box',\n'fontsize': 10,\n'height': 0.25,\n'fontname': 'Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans',\n'style': '\"setlinewidth(0.5)\"',\n'color': 'black',\n'fillcolor': 'white',\n}\n     def __init__(self, class_names: list[str], currmodule: str, show_builtins: bool = False,\n                  private_bases: bool = False, parts: int = 0,\n                  aliases: dict[str, str] | None = None, top_classes: list[Any] = [],\n         for name, fullname, bases, tooltip in sorted(self.class_info):\n             # Write the node\n             this_node_attrs = n_attrs.copy()\nnode_id = name.replace('.', '_')\n             if tooltip:\n                 this_node_attrs['tooltip'] = tooltip\n\n# Write the node definition with URL if exists\nif fullname in urls:\nurl = urls[fullname]\n# Create a node wrapped in an HTML-like table with a link\nres.append('  \"%s\" [label=<<TABLE BORDER=\"0\" CELLBORDER=\"0\" CELLSPACING=\"0\"><TR><TD><A HREF=\"%s\">%s</A></TD></TR></TABLE>>,\\n' % (name, url, name))\nres.append('          shape=none, margin=0];\\n')\nelse:\nres.append('  \"%s\" [%s];\\n' % (name, self._format_node_attrs(this_node_attrs)))\n \n             # Write the edges\n             for base_name in bases:\n     current_filename = self.builder.current_docname + self.builder.out_suffix\n     urls = {}\n     pending_xrefs = cast(Iterable[addnodes.pending_xref], node)\n\n# Calculate relative path prefix based on nesting level\ncurrent_depth = len(self.builder.current_docname.split('/')) - 1\nrelative_path_prefix = '../' * current_depth if current_depth > 0 else ''\n\n# Add one more level for _images directory\nif graphviz_output_format == 'SVG':\nrelative_path_prefix = '../' + relative_path_prefix\n\n     for child in pending_xrefs:\n         if child.get('refuri') is not None:\nurls[child['reftitle']] = relative_path_prefix + child.get('refuri')\n         elif child.get('refid') is not None:\nurls[child['reftitle']] = relative_path_prefix + current_filename + '#' + child.get('refid')\n \n     dotcode = graph.generate_dot(name, urls, env=self.builder.env)\n     render_dot_html(self, node, dotcode, {}, 'inheritance', 'inheritance',\n                     alt='Inheritance diagram of ' + node['content'])\n\n# Add JavaScript to handle SVG links\nif graphviz_output_format == 'SVG':\njs_code = '<script>\\n'\njs_code += '(function() {\\n'\njs_code += '    var urls = %s;\\n' % str(urls)\njs_code += '    var svg = document.currentScript.previousElementSibling.querySelector(\"object\");\\n'\njs_code += '    if (svg) {\\n'\njs_code += '        svg.addEventListener(\"load\", function() {\\n'\njs_code += '            var doc = svg.contentDocument;\\n'\njs_code += '            var nodes = doc.querySelectorAll(\".node\");\\n'\njs_code += '            nodes.forEach(function(node) {\\n'\njs_code += '                var title = node.querySelector(\"title\");\\n'\njs_code += '                if (title && urls[title.textContent]) {\\n'\njs_code += '                    var a = doc.createElementNS(\"http://www.w3.org/2000/svg\", \"a\");\\n'\njs_code += '                    a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", urls[title.textContent]);\\n'\njs_code += '                    a.setAttribute(\"target\", \"_top\");\\n'\njs_code += '                    while (node.firstChild) {\\n'\njs_code += '                        a.appendChild(node.firstChild);\\n'\njs_code += '                    }\\n'\njs_code += '                    node.appendChild(a);\\n'\njs_code += '                    node.style.cursor = \"pointer\";\\n'\njs_code += '                }\\n'\njs_code += '            });\\n'\njs_code += '        });\\n'\njs_code += '    }\\n'\njs_code += '})();\\n'\njs_code += '</script>\\n'\nself.body.append(js_code)\n\n     raise nodes.SkipNode\n"
    },
    "ground_truth_patch": {
        "sphinx/ext/inheritance_diagram.py": "     pending_xrefs = cast(Iterable[addnodes.pending_xref], node)\n     for child in pending_xrefs:\n         if child.get('refuri') is not None:\n# Construct the name from the URI if the reference is external via intersphinx\nif not child.get('internal', True):\nrefname = child['refuri'].rsplit('#', 1)[-1]\n             else:\nrefname = child['reftitle']\n\nurls[refname] = child.get('refuri')\n         elif child.get('refid') is not None:\n             if graphviz_output_format == 'SVG':\nurls[child['reftitle']] = current_filename + '#' + child.get('refid')\n             else:\n                 urls[child['reftitle']] = '#' + child.get('refid')\n \n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 processes XML data in SVG files by modifying URL attributes and wrapping them in anchor elements to make them clickable. It checks for the presence of a specific XML namespace and then goes through the XML structure to replace URL attributes with new anchor tags. The code in code sample 2 handles pending cross-references in a graph generation context, adding links to URLs based on the attributes of children nodes if certain conditions about the references are met. Both samples work with the same data structure and have a similar goal, but they contain distinct logic and structure. \", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they serve different functions related to manipulating XML and handling references, and have different control flows and logic, making them functionally dissimilar despite dealing with related contexts.\"}"
}