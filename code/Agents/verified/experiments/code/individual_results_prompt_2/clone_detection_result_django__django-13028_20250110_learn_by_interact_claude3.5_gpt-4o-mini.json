{
    "instance_id": "django__django-13028",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "django/db/models/sql/query.py": "index ce18098fd2..e81fe2e571 100644\n \n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\nif not getattr(expression, '_filterable', True):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n                 'clause.'\n             )\n\n         if hasattr(expression, 'get_source_expressions'):\n             for expr in expression.get_source_expressions():\n                 self.check_filterable(expr)\n         query.promote_joins(to_promote)\n         query.demote_joins(to_demote)\n         return to_demote\n\n",
        "reproduce.py": "new file mode 100644\nindex 0000000000..4e12ee8a3b\n# Setup minimal Django environment first\nfrom django.conf import settings\nsettings.configure(\nDATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\nINSTALLED_APPS=['__main__'],\nMIDDLEWARE=[],\n)\nimport django\ndjango.setup()\n\nfrom django.db import models\nfrom django.utils import timezone\n\nclass ProductMetaDataType(models.Model):\nlabel = models.CharField(max_length=255, unique=True, blank=False, null=False)\nfilterable = models.BooleanField(default=False)\n\ndef __str__(self):\nreturn self.label\n\nclass ProductMetaData(models.Model):\nid = models.BigAutoField(primary_key=True)\nvalue = models.TextField(null=False, blank=False)\nmetadata_type = models.ForeignKey(ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE)\n\n# Create database tables\nfrom django.db import connection\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(ProductMetaDataType)\nschema_editor.create_model(ProductMetaData)\n\n# Create test data\nmetadata_type = ProductMetaDataType.objects.create(label=\"test\", filterable=False)\nProductMetaData.objects.create(value=\"test value\", metadata_type=metadata_type)\n\n# Try the filter that causes the error\nprint(\"Testing filter...\")\nProductMetaData.objects.filter(metadata_type=metadata_type)\nprint(\"Filter successful!\")\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/query.py": " \n     def check_filterable(self, expression):\n         \"\"\"Raise an error if expression cannot be used in a WHERE clause.\"\"\"\nif (\nhasattr(expression, 'resolve_expression') and\nnot getattr(expression, 'filterable', True)\n):\n             raise NotSupportedError(\n                 expression.__class__.__name__ + ' is disallowed in the filter '\n                 'clause.'\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a method called check_filterable that checks whether an expression can be filtered in a WHERE clause in Django's ORM. It raises a NotSupportedError if the expression is not filterable and recursively checks any source expressions if applicable. Code sample 2 is a modified version of this function. It also checks the filterability of an expression but looks for a property called resolve_expression and uses filterable instead of _filterable. The structure and purpose of both snippets are similar as they both involve the same type of expression validity checking in Django's ORM, but with some discrepancies in the expressions checked and slight formatting differences. However, they cannot be considered clones due to these differences in logic.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because sample 1 and sample 2 have logic differences regarding the attributes being checked (_filterable vs filterable) and also the presence of a condition involving resolve_expression in sample 2 that is not present in sample 1.\"}"
}