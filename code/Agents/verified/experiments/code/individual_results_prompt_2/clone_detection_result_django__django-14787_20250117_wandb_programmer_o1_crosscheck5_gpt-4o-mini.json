{
    "instance_id": "django__django-14787",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/utils/decorators.py": "index 5c9a5d01c7..0704ab2a96 100644\n         decorators = [decorators]\n \n     def _wrapper(self, *args, **kwargs):\n@wraps(method)\ndef bound_method(*a, **k):\nreturn method.__get__(self, type(self))(*a, **k)\n\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n     return _wrapper\n \n \n\n def method_decorator(decorator, name=''):\n     \"\"\"\n     Convert a function decorator into a method decorator\n",
        "test_method_decorator_preserve_wrapper_assignments.py": "new file mode 100644\nindex 0000000000..2e60339a99\n#!/usr/bin/env python3\nimport sys\nimport logging\nfrom functools import wraps\nfrom django.utils.decorators import method_decorator\n\nlogger = logging.getLogger(__name__)\n\ndef logger_decorator(func):\n@wraps(func)\ndef inner(*args, **kwargs):\ntry:\nresult = func(*args, **kwargs)\nexcept Exception as e:\nresult = str(e)\nfinally:\nlogging.debug(f\"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}\")\nreturn result\nreturn inner\n\nclass Test:\n@method_decorator(logger_decorator)\ndef hello_world(self):\nreturn \"hello\"\n\ndef main():\ntry:\n# This should fail on HEAD if method_decorator incorrectly uses partial without preserving __name__.\nresult = Test().hello_world()\n# If no AttributeError was raised, let's check if the name was preserved\nactual_name = Test().hello_world.__name__\nif actual_name != \"hello_world\":\nprint(f\"ERROR: The name is not 'hello_world'. Found '{actual_name}'\")\nsys.exit(1)\nprint(\"SUCCESS: method_decorator preserved the wrapper assignments.\")\nsys.exit(0)\nexcept AttributeError as e:\nprint(f\"ERROR: {e}\")\nsys.exit(1)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/utils/decorators.py": "         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\nbound_method = wraps(method)(partial(method.__get__(self, type(self))))\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 contains a decorator function 'method_decorator' which converts a function decorator into a method decorator, applying a series of decorators to a bound method. It also includes a test class 'Test' with a method 'hello_world' decorated with 'method_decorator'. In contrast, the code in code sample 2 is part of the implementation of a decorator where it wraps a method using 'wraps' and 'partial', making changes to how a method can be called in relation to its 'self' context. Sample 1 illustrates the usage of method decorators while sample 2 shows part of the implementation logic for binding and wrapping methods in a class structure.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they serve different functions: sample 1 demonstrates a usage pattern while sample 2 presents an implementation detail.\"}"
}