{
    "instance_id": "django__django-16662",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/migrations/writer.py": "index a59f0c8dcb..4066e87bf6 100644\n             \"replaces_str\": \"\",\n             \"initial_str\": \"\",\n         }\n\n         imports = set()\n\n         # Deconstruct operations\n         operations = []\n         for operation in self.migration.operations:\n             imports.update(operation_imports)\n             operations.append(operation_string)\n         items[\"operations\"] = \"\\n\".join(operations) + \"\\n\" if operations else \"\"\n\n         # Format dependencies and write out swappable dependencies right\n         dependencies = []\n         for dependency in self.migration.dependencies:\n             if dependency[0] == \"__setting__\":\n                 dependencies.append(\n\"        migrations.swappable_dependency(settings.%s),\" % dependency[1]\n                 )\n                 imports.add(\"from django.conf import settings\")\n             else:\n                 dependencies.append(\"        %s,\" % self.serialize(dependency)[0])\n         items[\"dependencies\"] = \"\\n\".join(dependencies) + \"\\n\" if dependencies else \"\"\n\n         # Format imports nicely, swapping imports of functions from migration files\n         # for comments\n         migration_imports = set()\n                 migration_imports.add(line.split(\"import\")[1].strip())\n                 imports.remove(line)\n                 self.needs_manual_porting = True\n\n         # django.db.migrations is always used, but models import may not be.\n         # If models import exists, merge it with migrations import.\n         if \"from django.db import models\" in imports:\n             imports.add(\"from django.db import migrations, models\")\n         else:\n             imports.add(\"from django.db import migrations\")\n\n# Sort imports so that all \"import x\" lines appear before \"from x\"\n# lines. Within each block, sort by module name.\nsorted_imports = sorted(\nimports,\nkey=lambda i: (0 if i.startswith(\"import \") else 1, i.split()[1])\n)\n         items[\"imports\"] = \"\\n\".join(sorted_imports) + \"\\n\" if imports else \"\"\n         if migration_imports:\n             items[\"imports\"] += (\n\"\\n\\n# Functions from the following migrations need manual copying.\\n\"\n\"# Move them and any dependencies into this file, then update the\\n\"\n\"# RunPython operations to refer to the local versions:\\n# %s\"\n             ) % \"\\n# \".join(sorted(migration_imports))\n\n         # If there's a replaces, make a string for it\n         if self.migration.replaces:\n             items[\"replaces_str\"] = (\n                 \"\\n    replaces = %s\\n\" % self.serialize(self.migration.replaces)[0]\n             )\n\n# If there's an initial, make a string for it\n         if self.include_header:\n             items[\"migration_header\"] = MIGRATION_HEADER_TEMPLATE % {\n                 \"version\": get_version(),\n             }\n         else:\n             items[\"migration_header\"] = \"\"\n\n         if self.migration.initial:\n             items[\"initial_str\"] = \"\\n    initial = True\\n\"\n\n         return MIGRATION_TEMPLATE % items\n\n \n     @property\n     def basedir(self):\n",
        "test_import_ordering.py": "new file mode 100644\nindex 0000000000..67cb84f70b\n#!/usr/bin/env python3\n\nimport sys\nimport re\nimport datetime\nimport time\n\nfrom django.conf import settings\nimport django\nfrom django.db import migrations, models\nfrom django.db.migrations.migration import Migration\nfrom django.db.migrations.writer import MigrationWriter\n\n\"\"\"\nThis script checks whether imports in newly generated migrations\nend up in the correct order (all 'import' lines come before any\n'from x import' lines).\nIf any 'import' line occurs after 'from x import' lines, it exits non-zero.\nOtherwise, it exits zero.\n\"\"\"\n\nif not settings.configured:\n# Minimal Django config\nsettings.configure(\nSECRET_KEY='test',\nUSE_TZ=False,\nINSTALLED_APPS=[],\n)\ndjango.setup()\n\ndef main():\nprint(\"Starting test_import_ordering.py ...\")\n\n# Create a migration that references datetime and time in a model field default.\n# This forces the MigrationWriter to insert \"import datetime\" and \"import time\" lines.\noperation = migrations.CreateModel(\nname='MyModel',\nfields=[\n('id', models.AutoField(primary_key=True)),\n('my_datetime', models.DateTimeField(default=datetime.datetime.now)),\n('my_timestr', models.CharField(default=time.ctime, max_length=200)),\n],\n)\n\nmigration = Migration(\"auto_import_ordering_test\", \"test_app\")\nmigration.operations = [operation]\n\n# Write the migration to a string\nwriter = MigrationWriter(migration)\nmigration_str = writer.as_string()\n\n# Print for debugging\nprint(\"Generated migration:\")\nprint(\"=====================\")\nprint(migration_str)\nprint(\"=====================\")\n\n# Extract imports\nimport_lines = []\nfor line in migration_str.splitlines():\nline_stripped = line.strip()\nif line_stripped.startswith(\"import \") or line_stripped.startswith(\"from \"):\nimport_lines.append(line_stripped)\n\n# If there's any \"import \" that appears after \"from \", it's an error.\nfound_from = False\nretcode = 0\nfor line in import_lines:\nif line.startswith(\"from \"):\nfound_from = True\nelif line.startswith(\"import \"):\nif found_from:\nprint(\"ERROR: Found an 'import' line after a 'from' line!\")\nretcode = 1\n\nif retcode == 0:\nprint(\"Success: No 'import' lines found after 'from' lines.\")\n\nsys.exit(retcode)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/migrations/writer.py": " \n         # Sort imports by the package / module to be imported (the part after\n         # \"from\" in \"from ... import ...\" or after \"import\" in \"import ...\").\n# First group the \"import\" statements, then \"from ... import ...\".\nsorted_imports = sorted(\nimports, key=lambda i: (i.split()[0] == \"from\", i.split()[1])\n)\n         items[\"imports\"] = \"\\n\".join(sorted_imports) + \"\\n\" if imports else \"\"\n         if migration_imports:\n             items[\"imports\"] += (\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is primarily concerned with formatting and organizing imports in a migration writer for Django, specifically ensuring that imports are sorted properly before they are written out. It prepares a set of imports, deconstructs migration operations, and handles formatting for various migration properties, including the handling of dependencies. Code sample 2 focuses on a specific aspect of sorting the import statements, where it sorts the imports by their type (either 'import ...' or 'from ...') based on the lexical content after those keywords. It specifically works on gathering imports and presenting them in a structured manner. \", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share similar structures and functionalities regarding import management, but code sample 2 shows a modification to the sorting logic by comparing the first element of the split statement rather than checking for equality with the string 'from'. Thus, while the samples are sytematically similar, there are minor changes in logic that classify them as type-3 clones.\"}"
}