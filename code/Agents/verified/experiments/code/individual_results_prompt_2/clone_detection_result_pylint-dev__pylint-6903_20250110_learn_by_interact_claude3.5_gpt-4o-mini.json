{
    "instance_id": "pylint-dev__pylint-6903",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "my_package/__init__.py": "new file mode 100644\nindex 000000000..005d55086\n# Empty init\n",
        "my_package/test.py": "new file mode 100644\nindex 000000000..7d4290a11\nx = 1\n",
        "pylint/lint/run.py": "index a7e5d5574..352510739 100644\n         with open(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\", encoding=\"utf-8\") as file:\n             cpu_period = int(file.read().rstrip())\n         # Divide quota by period and you should get num of allotted CPU to the container, rounded down if fractional.\navail_cpu = max(1, int(cpu_quota / cpu_period))\n\n     elif Path(\"/sys/fs/cgroup/cpu/cpu.shares\").is_file():\n         with open(\"/sys/fs/cgroup/cpu/cpu.shares\", encoding=\"utf-8\") as file:\n             cpu_shares = int(file.read().rstrip())\n         # For AWS, gives correct value * 1024.\navail_cpu = max(1, int(cpu_shares / 1024))\n\n     return avail_cpu\n \n \n \n     Used by _PylintConfigRun to make the 'pylint-config' command work.\n     \"\"\"\n\n\ndiff --git \"a/pylint/lint/run.py\\\"\" \"b/pylint/lint/run.py\\\"\"\nnew file mode 100644\nindex 000000000..d4379de2e\navail_cpu = max(1, int(cpu_quota / cpu_period))  # Ensure at least 1 CPU\n",
        "reproduce_error.py": "new file mode 100644\nindex 000000000..f99993a16\nimport os\nimport sys\nfrom unittest.mock import patch\n\n# Add the local pylint to the path\nsys.path.insert(0, os.path.abspath('.'))\n\nfrom pylint.lint import Run\n\ndef mock_query_cpu():\n\"\"\"Mock the _query_cpu function to simulate a Kubernetes environment with limited CPU shares\"\"\"\nreturn 0  # This will simulate the bug where cpu_shares/1024 = 0\n\n# Create a simple package to lint\nos.makedirs(\"my_package\", exist_ok=True)\nwith open(\"my_package/__init__.py\", \"w\") as f:\nf.write(\"# Empty init\\n\")\nwith open(\"my_package/test.py\", \"w\") as f:\nf.write(\"x = 1\\n\")\n\n# Run pylint with jobs=0\nwith patch('pylint.lint.run._query_cpu', mock_query_cpu):\ntry:\nRun(['--jobs', '0', '--exit-zero', 'my_package'])\nprint(\"Success: Pylint completed without crashing\")\nexcept ValueError as e:\nprint(f\"Error: {e}\")\n\n"
    },
    "ground_truth_patch": {
        "pylint/lint/run.py": "             cpu_shares = int(file.read().rstrip())\n         # For AWS, gives correct value * 1024.\n         avail_cpu = int(cpu_shares / 1024)\n\n# In K8s Pods also a fraction of a single core could be available\n# As multiprocessing is not able to run only a \"fraction\" of process\n# assume we have 1 CPU available\nif avail_cpu == 0:\navail_cpu = 1\n\n     return avail_cpu\n \n \n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 shows a section of a function that reads CPU-related values from files in the system's cgroup directory. Specifically, it reads 'cpu.cfs_period_us' to get the CPU quota period and calculates the available CPU by dividing the cpu_quota by cpu_period. Additionally, it handles 'cpu.shares' to calculate available CPU shares and ensures that at least one CPU is allocated. The code also contains a description comment indicating that it is used by a configuration command. Code sample 2 continues from the previous code and includes a conditional to set avail_cpu to 1 if it equals 0, thereby ensuring that there\u2019s at least one CPU available. The comments provide context about running in a Kubernetes pod environment.\", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share significant syntactical similarity, but code sample 2 includes additional logic (setting avail_cpu to 1), which modifies the functionality.\"}"
}