{
    "instance_id": "django__django-14787",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index 238fb3a200..521baaa795 100644\n tests/.coverage\n build/\n tests/report/\n.aider/\n",
        "django/utils/decorators.py": "index 5c9a5d01c7..1d8c8275f7 100644\n     else:\n         decorators = [decorators]\n \n# Get the original function from static/class method if present\noriginal_method = method\nif isinstance(method, (staticmethod, classmethod)):\noriginal_method = method.__get__(None, type)\n\ndef _wrapper(*args, **kwargs):\nif isinstance(method, classmethod):\n# For classmethods, first arg is cls\ncls = args[0]\nbound_method = original_method.__get__(None, cls)\n# Don't include cls in args as it's already bound\nargs = args[1:]\nelif isinstance(method, staticmethod):\n# For staticmethods\nbound_method = original_method\nelse:\n# For instance methods, first arg is self\nself, *args = args\nbound_method = method.__get__(self, type(self))\n\n# Create partial and preserve attributes\npartial_bound = partial(bound_method)\nupdate_wrapper(partial_bound, bound_method)\nbound_method = partial_bound\n\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n         _update_method_wrapper(_wrapper, dec)\n     # Preserve any existing attributes of 'method', including the name.\n     update_wrapper(_wrapper, method)\n\n# Re-wrap as static/class method if needed\nif isinstance(method, staticmethod):\nreturn staticmethod(_wrapper)\nelif isinstance(method, classmethod):\nreturn classmethod(_wrapper)\n     return _wrapper\n"
    },
    "ground_truth_patch": {
        "django/utils/decorators.py": "         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\nbound_method = wraps(method)(partial(method.__get__(self, type(self))))\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a wrapper function that modifies another function ('method') to handle decorators. It deals with instance methods, class methods, and static methods, creating a partial bound method to preserve attributes and returning the wrapped function. The second code sample appears to be focused specifically on treating 'method' as a bound method, utilizing 'wraps' to maintain the function's attributes while applying decorators. Both snippets deal with function wrapping and decoration, but the first is a more complete implementation while the second is a specialized part of that process.\",\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they serve different purposes in the method wrapping process. The first sample includes significant functionality for handling different types of methods, while the second is more concise and focused on a specific aspect of the wrapping process.\"}"
}