{
    "instance_id": "django__django-12713",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/contrib/admin/options.py": "index 69a5fbf389..db7df891e3 100644\n             return None\n         db = kwargs.get('using')\n \nif 'widget' not in kwargs:\nautocomplete_fields = self.get_autocomplete_fields(request)\nif db_field.name in autocomplete_fields:\nkwargs['widget'] = AutocompleteSelectMultiple(db_field.remote_field, self.admin_site, using=db)\nelif db_field.name in self.raw_id_fields:\nkwargs['widget'] = widgets.ManyToManyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\nelif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\nkwargs['widget'] = widgets.FilteredSelectMultiple(\ndb_field.verbose_name,\ndb_field.name in self.filter_vertical\n)\n \n         if 'queryset' not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..2be3710c76\nimport os\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\nimport django\nfrom django.conf import settings\nif not settings.configured:\nsettings.configure(\nINSTALLED_APPS=['django.contrib.admin', 'django.contrib.contenttypes', 'django.contrib.auth'],\nDATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\n)\ndjango.setup()\n\nfrom django.contrib import admin\nfrom django.db import models\nfrom django.forms import widgets\n\n# Create custom widget\nclass CustomSelectMultiple(widgets.SelectMultiple):\npass\n\n# Create models\nclass Author(models.Model):\nclass Meta:\napp_label = 'admin'\nname = models.CharField(max_length=100)\n\nclass Book(models.Model):\nclass Meta:\napp_label = 'admin'\ntitle = models.CharField(max_length=100)\nauthors = models.ManyToManyField(Author)\n\n# Create admin class\nclass BookAdmin(admin.ModelAdmin):\ndef formfield_for_manytomany(self, db_field, request, **kwargs):\nif db_field.name == 'authors':\nkwargs['widget'] = CustomSelectMultiple()\nreturn super().formfield_for_manytomany(db_field, request, **kwargs)\n\n# Test the widget handling\nadmin_site = admin.AdminSite()\nbook_admin = BookAdmin(Book, admin_site)\nformfield = book_admin.formfield_for_manytomany(Book._meta.get_field('authors'), None, widget=CustomSelectMultiple())\nprint(f\"Widget class being used: {formfield.widget.__class__.__name__}\")\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/contrib/admin/options.py": "             return None\n         db = kwargs.get('using')\n \nif 'widget' not in kwargs:\nautocomplete_fields = self.get_autocomplete_fields(request)\nif db_field.name in autocomplete_fields:\nkwargs['widget'] = AutocompleteSelectMultiple(\ndb_field.remote_field,\nself.admin_site,\nusing=db,\n)\nelif db_field.name in self.raw_id_fields:\nkwargs['widget'] = widgets.ManyToManyRawIdWidget(\ndb_field.remote_field,\nself.admin_site,\nusing=db,\n)\nelif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\nkwargs['widget'] = widgets.FilteredSelectMultiple(\ndb_field.verbose_name,\ndb_field.name in self.filter_vertical\n)\n         if 'queryset' not in kwargs:\n             queryset = self.get_field_queryset(db, db_field, request)\n             if queryset is not None:\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is part of a Django application, and it implements functionality in a model admin that conditionally assigns a widget based on certain attributes of the fields in the model, specifically checking if 'widget' is a key in kwargs and configuring the widget type based on the field name. The code also includes setup for a Django application with models for Author and Book, alongside a custom SelectMultiple widget, and it sets up an admin class for handling ManyToMany relationships. Code sample 2 contains similar code that appears to be focused on assigning widget types in the formfield_for_manytomany method for a Django ModelAdmin, checking similar conditions to configure the widget based on the db_field.name but lacks the broader context of the complete Django setup with models and the admin class. The differences mainly lie in some whitespace and layout changes in the widget definitions.\", \"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical in logic and structure, apart from minor whitespace and layout differences.\"}"
}