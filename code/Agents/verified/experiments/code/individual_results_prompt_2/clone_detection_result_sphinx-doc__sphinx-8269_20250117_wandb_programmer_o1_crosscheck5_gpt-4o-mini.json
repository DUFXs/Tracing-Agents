{
    "instance_id": "sphinx-doc__sphinx-8269",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "scripts/test_linkcheck_anchor_http_error.py": "new file mode 100644\nindex 000000000..3791123d4\n#!/usr/bin/env python3\n\nimport os\nimport subprocess\nimport sys\n\ndef main():\nprint(\"Creating a minimal Sphinx project to test anchor HTTP error with linkcheck_anchors=True...\")\nsandbox = \"tmp_linkcheck_anchor_http_error\"\nif not os.path.exists(sandbox):\nos.makedirs(sandbox)\n\nconf_content = \"\"\"\nproject = \"testProject\"\nauthor = \"testAuthor\"\nrelease = \"1.0\"\nextensions = []\nmaster_doc = \"index\"\nlinkcheck_anchors = True\n\"\"\"\nwith open(os.path.join(sandbox, \"conf.py\"), \"w\") as f:\nf.write(conf_content)\n\nindex_content = \"\"\"\nWelcome to the test project\n===========================\n\nHere is a link with an anchor to a known 404 page:\n\n`test link <https://google.com/this-text-should-definitely-not-exist.txt#someanchor>`_\n\"\"\"\nwith open(os.path.join(sandbox, \"index.rst\"), \"w\") as f:\nf.write(index_content)\n\nprint(\"Running linkcheck with anchor checking turned on...\")\ncmd = [\n\"sphinx-build\",\n\"-b\",\n\"linkcheck\",\nsandbox,\nos.path.join(sandbox, \"_build\"),\n]\nprocess = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)\nstdout, _ = process.communicate()\nretcode = process.returncode\n\nprint(\"Return code from linkcheck:\", retcode)\nprint(\"Output from linkcheck:\\n\", stdout)\n\n# If not fixed, we see \"Anchor 'someanchor' not found\" apparently\nif \"Anchor 'someanchor' not found\" in stdout:\nprint(\"It looks like the bug is still present. :(\")\nsys.exit(1)\nelif \"404 Client Error\" in stdout:\nprint(\"It looks like the bug is fixed! We see a 404 Client Error message for the broken link.\")\nsys.exit(0)\nelse:\nprint(\"We didn't find either expected message. Possibly some other issue or an unexpected response, so let's fail.\")\nsys.exit(2)\n\nif __name__ == \"__main__\":\nmain()\n",
        "sphinx/builders/linkcheck.py": "index 9b54afc7c..0286e27ff 100644\n         }  # type: Dict\n         if self.app.config.linkcheck_timeout:\n             kwargs['timeout'] = self.app.config.linkcheck_timeout\n\n         def get_request_headers() -> Dict:\n             url = urlparse(uri)\n             candidates = [\"%s://%s\" % (url.scheme, url.netloc),\n                           \"%s://%s/\" % (url.scheme, url.netloc),\n                           uri,\n                           \"*\"]\n\n             for u in candidates:\n                 if u in self.config.linkcheck_request_headers:\n                     headers = dict(DEFAULT_REQUEST_HEADERS)\n                     headers.update(self.config.linkcheck_request_headers[u])\n                     return headers\n\n             return {}\n\n         def check_uri() -> Tuple[str, str, int]:\n             # split off anchor\n             if '#' in uri:\n             else:\n                 req_url = uri\n                 anchor = None\n\n             # handle non-ASCII URIs\n             try:\n                 req_url.encode('ascii')\n             except UnicodeError:\n                 req_url = encode_uri(req_url)\n\n             # Get auth info, if any\n             for pattern, auth_info in self.auth:\n                 if pattern.match(uri):\n                     break\n             else:\n                 auth_info = None\n\n             # update request headers for the URL\n             kwargs['headers'] = get_request_headers()\n\n             try:\n                 if anchor and self.app.config.linkcheck_anchors:\n                     # Read the whole document and see if #anchor exists\n                     response = requests.get(req_url, stream=True, config=self.app.config,\n                                             auth=auth_info, **kwargs)\n# NEW LINE:\nresponse.raise_for_status()\n                     found = check_anchor(response, unquote(anchor))\n\n                     if not found:\n                         raise Exception(__(\"Anchor '%s' not found\") % anchor)\n                 else:\n                     try:\n# try a HEAD request first\n                         response = requests.head(req_url, config=self.app.config,\n                                                  auth=auth_info, **kwargs)\n                         response.raise_for_status()\n                     except HTTPError:\n# retry with GET\n                         response = requests.get(req_url, stream=True, config=self.app.config,\n                                                 auth=auth_info, **kwargs)\n                         response.raise_for_status()\n                 new_url = response.url\n                 if anchor:\n                     new_url += '#' + anchor\n                 if response.history:\n                     code = response.history[-1].status_code\n                     return 'redirected', new_url, code\n                 else:\n                     return 'redirected', new_url, 0\n\n         def check() -> Tuple[str, str, int]:\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:')):\n             for rex in self.to_ignore:\n                 if rex.match(uri):\n                     return 'ignored', '', 0\n\n             # need to actually check the URI\n             for _ in range(self.app.config.linkcheck_retries):\n                 status, info, code = check_uri()\n                 if status != \"broken\":\n                     break\n\n             if status == \"working\":\n                 self.good.add(uri)\n             elif status == \"broken\":\n                 self.broken[uri] = info\n             elif status == \"redirected\":\n                 self.redirected[uri] = (info, code)\n\n             return (status, info, code)\n\n         while True:\n             uri, docname, lineno = self.wqueue.get()\n             if uri is None:\n                 break\n             status, info, code = check()\n             self.rqueue.put((uri, docname, lineno, status, info, code))\n\n \n     def process_result(self, result: Tuple[str, str, int, str, str, int]) -> None:\n         uri, docname, lineno, status, info, code = result\n",
        "tmp_linkcheck_anchor_http_error/_build/.doctrees/environment.pickle": "new file mode 100644\nindex 000000000..5606dd69a\nBinary files /dev/null and b/tmp_linkcheck_anchor_http_error/_build/.doctrees/environment.pickle differ\n",
        "tmp_linkcheck_anchor_http_error/_build/.doctrees/index.doctree": "new file mode 100644\nindex 000000000..caa480a87\nBinary files /dev/null and b/tmp_linkcheck_anchor_http_error/_build/.doctrees/index.doctree differ\n",
        "tmp_linkcheck_anchor_http_error/_build/output.json": "new file mode 100644\nindex 000000000..35d197dad\n{\"filename\": \"index.rst\", \"lineno\": 7, \"status\": \"broken\", \"code\": 0, \"uri\": \"https://google.com/this-text-should-definitely-not-exist.txt#someanchor\", \"info\": \"404 Client Error: Not Found for url: https://google.com/this-text-should-definitely-not-exist.txt\"}\n",
        "tmp_linkcheck_anchor_http_error/_build/output.txt": "new file mode 100644\nindex 000000000..45338a9be\nindex.rst:7: [broken] https://google.com/this-text-should-definitely-not-exist.txt#someanchor: 404 Client Error: Not Found for url: https://google.com/this-text-should-definitely-not-exist.txt\n",
        "tmp_linkcheck_anchor_http_error/conf.py": "new file mode 100644\nindex 000000000..daaef2379\n\nproject = \"testProject\"\nauthor = \"testAuthor\"\nrelease = \"1.0\"\nextensions = []\nmaster_doc = \"index\"\nlinkcheck_anchors = True\n",
        "tmp_linkcheck_anchor_http_error/index.rst": "new file mode 100644\nindex 000000000..e7a701b04\n\nWelcome to the test project\n===========================\n\nHere is a link with an anchor to a known 404 page:\n\n`test link <https://google.com/this-text-should-definitely-not-exist.txt#someanchor>`_\n"
    },
    "ground_truth_patch": {
        "sphinx/builders/linkcheck.py": "                     # Read the whole document and see if #anchor exists\n                     response = requests.get(req_url, stream=True, config=self.app.config,\n                                             auth=auth_info, **kwargs)\nresponse.raise_for_status()\n                     found = check_anchor(response, unquote(anchor))\n \n                     if not found:\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is part of a script that creates a minimal Sphinx project to test anchor HTTP error handling with the linkcheck_anchors option set to True. It sets up a project directory, writes configuration and index files, and then executes a command that runs Sphinx's linkchecker to verify URLs in the project. It checks the output of the link checker for specific messages indicating whether the expected anchor was found. Conversely, the code in code sample 2 is a snippet from a method in the linkcheck.py file that deals specifically with checking URIs for anchors. It fetches the response of a request to a URL and raises an exception if the specified anchor is not found. Both samples involve checking links, but they are part of different functions within the broader context of link checking in Sphinx.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they are not structurally or functionally identical; code sample 1 is a complete script while sample 2 is a specific function for handling HTTP requests. Additionally, they serve different purposes within the overall framework.\"}"
}