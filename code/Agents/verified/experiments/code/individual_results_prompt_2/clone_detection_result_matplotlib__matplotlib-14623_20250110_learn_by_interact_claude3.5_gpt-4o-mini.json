{
    "instance_id": "matplotlib__matplotlib-14623",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "lib/matplotlib/axes/_base.py": "index da2dea6f57..0d5866886e 100644\n             top = old_top\n \n         if self.get_yscale() == 'log':\n# Store the intended direction before validation\nis_inverted = bottom > top\n# Validate values but preserve inversion intent\n             if bottom <= 0:\n                 cbook._warn_external(\n                     'Attempted to set non-positive bottom ylim on a '\n                 f\"expanding.\")\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n# Restore the intended direction if it was changed\nif self.get_yscale() == 'log' and is_inverted and bottom < top:\nbottom, top = top, bottom\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\n     def get_shared_y_axes(self):\n         \"\"\"Return a reference to the shared axes Grouper object for y axes.\"\"\"\n         return self._shared_y_axes\n\n"
    },
    "ground_truth_patch": {
        "lib/matplotlib/axes/_base.py": "             cbook._warn_external(\n                 f\"Attempting to set identical left == right == {left} results \"\n                 f\"in singular transformations; automatically expanding.\")\nswapped = left > right\n         left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n         left, right = self.xaxis.limit_range_for_scale(left, right)\nif swapped:\nleft, right = right, left\n \n         self.viewLim.intervalx = (left, right)\n         if auto is not None:\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\nswapped = bottom > top\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\nif swapped:\nbottom, top = top, bottom\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\n",
        "lib/matplotlib/ticker.py": "         return locs\n \n     def nonsingular(self, v0, v1):\n\"\"\"Expand a range as needed to avoid singularities.\"\"\"\nreturn mtransforms.nonsingular(v0, v1, expander=.05)\n \n     def view_limits(self, vmin, vmax):\n         \"\"\"\n",
        "lib/mpl_toolkits/mplot3d/axes3d.py": "             cbook._warn_external(\n                 f\"Attempting to set identical left == right == {left} results \"\n                 f\"in singular transformations; automatically expanding.\")\nswapped = left > right\n         left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n         left, right = self.xaxis.limit_range_for_scale(left, right)\nif swapped:\nleft, right = right, left\n         self.xy_viewLim.intervalx = (left, right)\n \n         if auto is not None:\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\nswapped = bottom > top\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\nif swapped:\nbottom, top = top, bottom\n         self.xy_viewLim.intervaly = (bottom, top)\n \n         if auto is not None:\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\nswapped = bottom > top\n         bottom, top = self.zaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.zaxis.limit_range_for_scale(bottom, top)\nif swapped:\nbottom, top = top, bottom\n         self.zz_viewLim.intervalx = (bottom, top)\n \n         if auto is not None:\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 handles the validation of the y-axis limits in a matplotlib plot, particularly when the scale is logarithmic. It checks whether the bottom limit is less than or equal to zero and issues a warning if so, while also ensuring that the limits are appropriate for the chosen scale. The code sample then restores the intended direction if necessary. In contrast, code sample 2 focuses on the x-axis limits, implementing similar validations for the x-range while also ensuring the limits make sense given the context, including handling singular transformations when the limits are identical. Both samples are handling the axis limits but for different axes (y vs x), thus they contain analogous logic but distinct variable references. \", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they are syntactically similar and exhibit similar logic, but they contain added or modified statements specific to different axes (y-axis limits in sample 1 versus x-axis limits in sample 2).\"}"
}