{
    "instance_id": "django__django-12155",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/contrib/admindocs/utils.py": "index 4c0e7e2a56..121c48d649 100644\n         return ''\n     # Convert tabs to spaces and split into lines\n     lines = docstring.expandtabs().splitlines()\n# Skip the first line when calculating the indent\nnon_empty_lines = [line for line in lines[1:] if line.lstrip()]\nif non_empty_lines:\nindent = min(len(line) - len(line.lstrip()) for line in non_empty_lines)\nelse:\nindent = 0\ntrimmed = [lines[0].lstrip()] + [line[indent:].rstrip() if line.lstrip() else '' for line in lines[1:]]\n     return \"\\n\".join(trimmed).strip()\n \n \n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..5a1992c684\nimport os\nfrom django.conf import settings\n\nif not settings.configured:\nsettings.configure(\nDEBUG=True,\nSECRET_KEY='dummy-key',\nROOT_URLCONF='django.contrib.admindocs.urls',\nINSTALLED_APPS=[\n'django.contrib.admin',\n'django.contrib.admindocs',\n]\n)\n\nfrom django.contrib.admindocs.utils import trim_docstring, parse_rst\n\ndef test_empty():\n\"\"\"\n\"\"\"\npass\n\ndef test_single_line():\n\"\"\"Single line docstring.\"\"\"\npass\n\ndef test_varying_indent():\n\"\"\"First line.\nMore indented line.\nBack to normal indent.\nVery indented line.\n\"\"\"\npass\n\ndef test_blank_lines():\n\"\"\"First paragraph.\n\nSecond paragraph with indent.\n\nThird paragraph with more indent.\n\"\"\"\npass\n\n# Test all cases\ntest_cases = [test_empty, test_single_line, test_varying_indent, test_blank_lines]\n\nfor test_func in test_cases:\nprint(f\"\\nTesting {test_func.__name__}:\")\nprint(\"-\" * 40)\ndocstring = test_func.__doc__\ntrimmed = trim_docstring(docstring)\nprint(\"Trimmed docstring:\")\nprint(repr(trimmed))\nprint(\"\\nParsed HTML:\")\ntry:\nhtml = parse_rst(trimmed, \"view\", test_func.__name__)\nprint(html)\nexcept Exception as e:\nprint(f\"Error: {str(e)}\")\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/contrib/admindocs/utils.py": " import re\n from email.errors import HeaderParseError\n from email.parser import HeaderParser\nfrom inspect import cleandoc\n \n from django.urls import reverse\n from django.utils.regex_helper import _lazy_re_compile\n     return mod_name + '.' + view_name\n \n \n def parse_docstring(docstring):\n     \"\"\"\n     Parse out the parts of a docstring.  Return (title, body, metadata).\n     \"\"\"\nif not docstring:\nreturn '', '', {}\ndocstring = cleandoc(docstring)\n     parts = re.split(r'\\n{2,}', docstring)\n     title = parts[0]\n     if len(parts) == 1:\n",
        "django/contrib/admindocs/views.py": " import inspect\n from importlib import import_module\nfrom inspect import cleandoc\n from pathlib import Path\n \n from django.apps import apps\n                     continue\n                 verbose = func.__doc__\n                 verbose = verbose and (\nutils.parse_rst(cleandoc(verbose), 'model', _('model:') + opts.model_name)\n                 )\n                 # Show properties and methods without arguments as fields.\n                 # Otherwise, show as a 'method with arguments'.\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines functions to manipulate and process docstrings, specifically trimming them by removing indentations and blank lines, while the code in code sample 2 contains a function to parse a docstring into its components like title, body, and metadata. Both samples belong to Django's admindocs module but target different functionalities.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they serve different purposes and exhibit syntactical dissimilarity, thus falling under Type-4 clone classification as they are functionally different despite potentially being related through the Django framework.\"}"
}