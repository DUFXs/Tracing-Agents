{
    "instance_id": "django__django-11299",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "django/db/models/sql/query.py": "index b99f03cd88..de198fb610 100644\n             if isinstance(child, Node):\n                 child_clause, needed_inner = self._add_q(\n                     child, used_aliases, branch_negated,\ncurrent_negated, allow_joins, split_subq, simple_col=simple_col)\n                 joinpromoter.add_votes(needed_inner)\n\n             else:\n                 child_clause, needed_inner = self.build_filter(\n                     child, can_reuse=used_aliases, branch_negated=branch_negated,\n         query.promote_joins(to_promote)\n         query.demote_joins(to_demote)\n         return to_demote\n\ndiff --git \"a/django/db/models/sql/query.py\\\"\" \"b/django/db/models/sql/query.py\\\"\"\nnew file mode 100644\nindex 0000000000..65fa1e7764\nchild_clause, needed_inner = self._add_q(\nchild, used_aliases, branch_negated,\ncurrent_negated, allow_joins, split_subq, simple_col=simple_col)\njoinpromoter.add_votes(needed_inner)\n",
        "test_constraint.py": "new file mode 100644\nindex 0000000000..6fb57e1a7f\nfrom django.conf import settings\nfrom django.db import models\nfrom django.db.migrations.operations.models import CreateModel, AddConstraint\nfrom django.db.migrations.state import ProjectState\nfrom django.db.migrations.migration import Migration\nfrom django.db.backends.sqlite3.schema import DatabaseSchemaEditor\nfrom django.db.backends.sqlite3.base import DatabaseWrapper\n\n# Configure Django settings before importing models\nif not settings.configured:\nsettings.configure(\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n'TIME_ZONE': None,\n'CONN_MAX_AGE': 0,\n'OPTIONS': {},\n'AUTOCOMMIT': True,\n}\n},\nINSTALLED_APPS=['django.contrib.contenttypes'],\nMIDDLEWARE=[],\nTIME_ZONE=None,\nUSE_TZ=False,\n)\nimport django\ndjango.setup()\n\nclass TestConstraint(models.Model):\nfield_1 = models.IntegerField(blank=True, null=True)\nflag = models.BooleanField(blank=False, null=False)\n\nclass Meta:\napp_label = 'testapp'\nconstraints = [\nmodels.CheckConstraint(\ncheck=models.Q(flag__exact=True, field_1__isnull=False) | models.Q(flag__exact=False),\nname='field_1_has_value_if_flag_set'\n),\n]\n\n# Set up migration\nmigration = Migration('testapp', '0002_test')\nmigration.operations = [\nCreateModel(\nname='TestConstraint',\nfields=[\n('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n('field_1', models.IntegerField(blank=True, null=True)),\n('flag', models.BooleanField()),\n],\n),\nAddConstraint(\nmodel_name='testconstraint',\nconstraint=models.CheckConstraint(\ncheck=models.Q(models.Q(('field_1__isnull', False), ('flag__exact', True)), ('flag__exact', False), _connector='OR'),\nname='field_1_has_value_if_flag_set'\n),\n),\n]\n\n# Create database connection\nconnection = DatabaseWrapper({\n'NAME': ':memory:',\n'TIME_ZONE': None,\n'CONN_MAX_AGE': 0,\n'OPTIONS': {},\n'AUTOCOMMIT': True,\n'ENGINE': 'django.db.backends.sqlite3',\n})\n\n# Apply migration\nproject_state = ProjectState()\nwith connection.schema_editor() as schema_editor:\ntry:\nmigration.apply(project_state, schema_editor)\nprint(\"Migration successful!\")\nexcept Exception as e:\nprint(f\"Migration failed: {str(e)}\")\n\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/query.py": "             if isinstance(child, Node):\n                 child_clause, needed_inner = self._add_q(\n                     child, used_aliases, branch_negated,\ncurrent_negated, allow_joins, split_subq, simple_col)\n                 joinpromoter.add_votes(needed_inner)\n             else:\n                 child_clause, needed_inner = self.build_filter(\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is a part of a Django backend handling SQL queries, specifically involving the addition of a filter condition to a query using the `_add_q` method and handling child clauses for the query conditions. The methods such as `joinpromoter.add_votes` suggest it is also managing join operations depending on the query structure. In contrast, code sample 2 appears to be a fragment with the same initial logic, specifically checking if a 'child' is an instance of `Node` and performing similar operations to add a filter condition and update inner joins, but it is not complete and lacks context. Both code samples are working with query filtering in Django but are not identical, partially due to missing the full functionality in sample 2.\",\"is_clone\": true, \"classification\": \"type-1\", \"reasoning\": \"These code samples are type-1 clones because they are identical in their logical flow and structure, differing only in whitespace. The lack of the complete context or additional logic in sample 2 does not fundamentally change the nature of the presented logic.\"}"
}