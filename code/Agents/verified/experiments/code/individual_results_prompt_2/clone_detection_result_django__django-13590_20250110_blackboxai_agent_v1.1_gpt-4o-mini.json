{
    "instance_id": "django__django-13590",
    "agent": "20250110_blackboxai_agent_v1.1",
    "agent_patch": {
        ".gitignore": "index 238fb3a200..521baaa795 100644\n tests/.coverage\n build/\n tests/report/\n.aider/\n",
        "django/db/models/sql/query.py": "index 4648daf395..93e7c58585 100644\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n# Handle named tuples by converting generator to tuple before construction\nresolved_values = tuple(\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\nif hasattr(value, '_fields'):  # Named tuple check\nreturn type(value)(*resolved_values)\nreturn type(value)(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n"
    },
    "ground_truth_patch": {
        "django/db/models/sql/query.py": "         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\nvalues = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\ntype_ = type(value)\nif hasattr(type_, '_make'):  # namedtuple\nreturn type_(*values)\nreturn type_(values)\n         return value\n \n     def solve_lookup_type(self, lookup):\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is handling cases where a value is a list or tuple. It resolves each sub-value individually using a method and then creates a tuple of resolved values. It also checks if the value is a named tuple to return the appropriate type. The code in code sample 2 does a similar task but uses a different variable name to hold resolved values and checks for a named tuple in a slightly different way, focusing on the type of the value before checking its properties.\", \"is_clone\": true, \"classification\": \"type-2\", \"reasoning\": \"These code samples are type-2 clones because they are nearly identical in logic but differ in identifier names ('resolved_values' vs 'values') and slight differences in how they check for named tuples.\"}"
}