{
    "instance_id": "sphinx-doc__sphinx-8475",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "reproduce.py": "new file mode 100644\nindex 000000000..7d40cb815\nfrom sphinx.builders.linkcheck import CheckExternalLinksBuilder\nfrom sphinx.application import Sphinx\nimport requests\n\n# Mock Sphinx app config\nclass MockConfig:\ndef __init__(self):\nself.linkcheck_ignore = []\nself.linkcheck_auth = []\nself.linkcheck_request_headers = {}\nself.linkcheck_retries = 1\nself.linkcheck_timeout = None\nself.linkcheck_workers = 5\nself.linkcheck_anchors = True\nself.linkcheck_anchors_ignore = [\"^!\"]\n\nclass MockApp:\ndef __init__(self):\nself.config = MockConfig()\n\n# Create a simple test\nurl = \"https://idr.openmicroscopy.org/webclient/?show=well-119093\"\nkwargs = {}\nheaders = {'Accept': 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8'}\nkwargs['headers'] = headers\n\nprint(\"Testing HEAD request...\")\ntry:\nresponse = requests.head(url, allow_redirects=True, **kwargs)\nresponse.raise_for_status()\nprint(\"HEAD request succeeded\")\nexcept Exception as e:\nprint(f\"HEAD request failed with: {type(e).__name__}: {str(e)}\")\n\nprint(\"\\nTesting GET request...\")\ntry:\nresponse = requests.get(url, stream=True, **kwargs)\nresponse.raise_for_status()\nprint(\"GET request succeeded\")\nexcept Exception as e:\nprint(f\"GET request failed with: {type(e).__name__}: {str(e)}\")\n",
        "sphinx/builders/linkcheck.py": "index 1dc0337c3..d6c39719f 100644\n \n from docutils import nodes\n from docutils.nodes import Node\nfrom requests.exceptions import HTTPError, TooManyRedirects\n\n \n from sphinx.application import Sphinx\n from sphinx.builders import Builder\n                                                  config=self.app.config, auth=auth_info,\n                                                  **kwargs)\n                         response.raise_for_status()\nexcept (HTTPError, TooManyRedirects):\n                         # retry with GET request if that fails, some servers\n# don't like HEAD requests or have too many redirects.\n                         response = requests.get(req_url, stream=True, config=self.app.config,\n                                                 auth=auth_info, **kwargs)\n                         response.raise_for_status()\n\n             except HTTPError as err:\n                 if err.response.status_code == 401:\n                     # We'll take \"Unauthorized\" as working.\n                     return 'ignored', str(err), 0\n                 else:\n                     return 'broken', str(err), 0\nexcept TooManyRedirects as err:\n# Handle too many redirects as broken\nreturn 'broken', str(err), 0\n             except Exception as err:\n                 return 'broken', str(err), 0\n\n             if response.url.rstrip('/') == req_url.rstrip('/'):\n                 return 'working', '', 0\n             else:\n         'parallel_read_safe': True,\n         'parallel_write_safe': True,\n     }\n\n\n\n"
    },
    "ground_truth_patch": {
        "sphinx/builders/linkcheck.py": " \n from docutils import nodes\n from docutils.nodes import Node\nfrom requests.exceptions import HTTPError, TooManyRedirects\n \n from sphinx.application import Sphinx\n from sphinx.builders import Builder\n                                                  config=self.app.config, auth=auth_info,\n                                                  **kwargs)\n                         response.raise_for_status()\nexcept (HTTPError, TooManyRedirects):\n                         # retry with GET request if that fails, some servers\n                         # don't like HEAD requests.\n                         response = requests.get(req_url, stream=True, config=self.app.config,\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a mock Sphinx application for testing link checking by simulating requests to a specified URL using requests. It attempts both HEAD and GET requests and handles any exceptions that may occur. It includes structured classes for configuration and application mock-ups. In contrast, code sample 2 contains an incomplete snipped implementation relating to error handling during HTTP requests. It handles scenarios like HTTPError and TooManyRedirects, and includes some comments regarding GET requests but lacks the broader context and functionality present in code sample 1.\",\"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because code sample 1 contains a complete, functional test code with full context and mock definitions, while code sample 2 is an incomplete snippet primarily focused on error handling without the necessary constructs or broader context.\"}"
}