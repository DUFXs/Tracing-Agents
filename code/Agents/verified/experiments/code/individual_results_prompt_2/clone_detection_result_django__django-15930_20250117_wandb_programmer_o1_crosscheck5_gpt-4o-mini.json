{
    "instance_id": "django__django-15930",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/db/models/expressions.py": "index 822968ef56..45fe0f7520 100644\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\nif not condition_sql.strip():\ncondition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n         sql_params.extend(result_params)\n         template = template or self.template\n         return template % template_params, sql_params\n\n \n     def get_group_by_cols(self, alias=None):\n         # This is not a complete expression and cannot be used in GROUP BY.\n",
        "test_case_bug.py": "new file mode 100644\nindex 0000000000..6256ab012e\n#!/usr/bin/env python3\nimport sys\nimport traceback\nimport django\nfrom django.conf import settings\nfrom django.db import models\nfrom django.db.models import Q, Value, BooleanField\nfrom django.db.models.functions import Cast\nfrom django.db.models import Case, When\n\n\"\"\"\nThis script attempts to reproduce the bug where Case() with When(~Q(pk__in=[]))\ngenerates malformed SQL that triggers a syntax error:\n... WHEN THEN True ...\nrather than something valid.\n\nExit 0 = Bug is fixed, no syntax error\nExit 1 = Bug is still present (syntax error triggered)\n\"\"\"\n\ndef main():\n# Configure Django (sqlite memory, minimal setup)\nsettings.configure(\nINSTALLED_APPS=[\"__main__\"],\nDATABASES={\n\"default\": {\n\"ENGINE\": \"django.db.backends.sqlite3\",\n\"NAME\": \":memory:\",\n}\n},\nSECRET_KEY=\"test\",\n)\ndjango.setup()\n\nclass TestModel(models.Model):\nname = models.CharField(max_length=200)\n\nclass Meta:\napp_label = \"__main__\"\n\n# Create the tables\ntry:\nwith django.db.connection.schema_editor() as schema_editor:\nschema_editor.create_model(TestModel)\nexcept Exception as e:\nprint(\"Failed to create schema:\", e)\ntraceback.print_exc()\nsys.exit(1)\n\n# Insert a row for testing\nTestModel.objects.create(name=\"Row1\")\n\ntry:\n# Attempt the problematic query:\n# This will fail (bug) if we get syntax error from 'CASE WHEN THEN True ...',\n# instead of something more valid like 'CASE WHEN 1=1 THEN True'.\nqs = TestModel.objects.annotate(\nis_match=Case(\nWhen(~Q(pk__in=[]), then=Value(True)),\ndefault=Value(False),\noutput_field=BooleanField(),\n)\n).order_by(\"-is_match\")\n\n# Force execution\nresults = list(qs)\nprint(\"Query succeeded. Number of rows:\", len(results))\n# If we got here without an error, presumably the bug is fixed\nsys.exit(0)\n\nexcept Exception as e:\n# Syntax error indicates the bug\nprint(\"Caught exception, bug likely present:\")\ntraceback.print_exc()\nsys.exit(1)\n\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/db/models/expressions.py": "         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n# Filters that match everything are handled as empty strings in the\n# WHERE clause, but in a CASE WHEN expression they must use a predicate\n# that's always True.\nif condition_sql == \"\":\ncondition_sql, condition_params = compiler.compile(Value(True))\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 initializes SQL parameters and constructs a condition for a SQL query, ensuring that if the condition is empty, it defaults to \\\"1=1\\\". Then it compiles the result of a Claire's SQL expression and prepares the output. Code sample 2 is a similar segment of code that handles SQL condition constructions but checks for an empty string in the condition and replaces it with a compiled value of True if necessary.\", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are not identical due to different logic conditions and handling of SQL expressions, thus classifying them as type-3 clones, where they have syntactic similarities but different statements.\"}"
}