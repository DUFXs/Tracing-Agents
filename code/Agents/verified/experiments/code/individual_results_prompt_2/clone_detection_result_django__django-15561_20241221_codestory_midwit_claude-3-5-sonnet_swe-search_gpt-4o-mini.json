{
    "instance_id": "django__django-15561",
    "agent": "20241221_codestory_midwit_claude-3-5-sonnet_swe-search",
    "agent_patch": {
        "django/db/backends/base/schema.py": "index 9d6952df21..6c160cf19f 100644\n         # - changing only a field name\n         # - changing an attribute that doesn't affect the schema\n         # - adding only a db_column and the column name is not changed\n# - changing only the choices (which is just a validation constraint)\n         non_database_attrs = [\n             \"blank\",\n\"choices\",  # Added choices to non-database attributes\n             \"db_column\",\n             \"editable\",\n             \"error_messages\",\n",
        "reproduce_error.py": "new file mode 100644\nindex 0000000000..b4117bf19f\nimport django\nfrom django.conf import settings\nfrom django.db import migrations, models\nfrom django.db.migrations.state import ProjectState\nfrom django.db.migrations.executor import MigrationExecutor\nfrom django.db import connection\nfrom django.apps import apps\n\n# Configure Django settings\nsettings.configure(\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n}\n},\nINSTALLED_APPS=[\n'django.contrib.contenttypes',\n'django.contrib.auth',\n],\n)\n\n# Initialize Django\ndjango.setup()\n\ndef get_migration_sql(operations):\n\"\"\"Get the SQL that would be executed for the given operations.\"\"\"\n# Create initial project state with our test app\nproject_state = ProjectState()\nproject_state.add_model(migrations.state.ModelState(\n'test_app',\n'TestModel',\n[\n('id', models.AutoField(primary_key=True)),\n('status', models.CharField(max_length=10, choices=[('A', 'Active')])),\n],\n{},\nNone,\n))\n\n# Get the SQL statements\nwith connection.schema_editor(collect_sql=True) as schema_editor:\nsql_statements = []\nfor operation in operations:\nnew_state = project_state.clone()\noperation.state_forwards('test_app', new_state)\nif hasattr(operation, 'database_forwards'):\noperation.database_forwards('test_app', schema_editor, project_state, new_state)\nsql_statements.extend(schema_editor.collected_sql)\nschema_editor.collected_sql = []\nproject_state = new_state\nreturn sql_statements\n\ndef main():\n# Define a model field change that only modifies choices\noperations = [\nmigrations.CreateModel(\nname='TestModel',\nfields=[\n('id', models.AutoField(primary_key=True)),\n('status', models.CharField(max_length=10, choices=[('A', 'Active')])),\n],\n),\nmigrations.AlterField(\nmodel_name='TestModel',\nname='status',\nfield=models.CharField(max_length=10, choices=[('A', 'Active'), ('I', 'Inactive')]),\n),\n]\n\n# Get and print the SQL statements\nsql_statements = get_migration_sql(operations)\nprint(\"Generated SQL statements:\")\nfor sql in sql_statements:\nprint(sql)\nprint(\"---\")\n\nif __name__ == '__main__':\nmain()\n\\ No newline at end of file\n"
    },
    "ground_truth_patch": {
        "django/db/backends/base/schema.py": "         # - changing only a field name\n         # - changing an attribute that doesn't affect the schema\n         # - adding only a db_column and the column name is not changed\nfor attr in old_field.non_db_attrs:\n             old_kwargs.pop(attr, None)\nfor attr in new_field.non_db_attrs:\n             new_kwargs.pop(attr, None)\n         return self.quote_name(old_field.column) != self.quote_name(\n             new_field.column\n",
        "django/db/models/fields/__init__.py": "     system_check_deprecated_details = None\n     system_check_removed_details = None\n \n# Attributes that don't affect a column definition.\n# These attributes are ignored when altering the field.\nnon_db_attrs = (\n\"blank\",\n\"choices\",\n\"db_column\",\n\"editable\",\n\"error_messages\",\n\"help_text\",\n\"limit_choices_to\",\n# Database-level options are not supported, see #21961.\n\"on_delete\",\n\"related_name\",\n\"related_query_name\",\n\"validators\",\n\"verbose_name\",\n)\n\n     # Field flags\n     hidden = False\n \n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is primarily involved in configuring a Django application, setting up a temporary project state to track migrations, and generating SQL statements for database operations based on model changes. It defines a function to gather the SQL statements created from migration operations and prints them. The second code sample is primarily about handling attributes in field definition when modifying database schema, specifically filtering out non-database attributes that should not affect a column definition. It traverses two lists of attributes and modifies the arguments accordingly.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they serve different purposes and involve different logic. Sample 1 is focused on migration and SQL generation while Sample 2 is focused on schema modification with respect to model fields.\"}"
}