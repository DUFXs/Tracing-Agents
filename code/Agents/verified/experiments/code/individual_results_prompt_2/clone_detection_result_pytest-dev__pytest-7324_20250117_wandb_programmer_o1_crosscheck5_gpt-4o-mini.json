{
    "instance_id": "pytest-dev__pytest-7324",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "src/_pytest/mark/expression.py": "index 04c73411a..4cea2f468 100644\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\n# We'll rename special keywords here (False/True/None etc.),\n# so Python's debug builds do not see them as normal 'Name' nodes.\nnew_name = rename_ident(ident.value)\nreturn ast.Name(new_name, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \nRENAME_PREFIX = \"pytestIdent__\"\nRESERVED_KEYWORDS = {\"False\", \"True\", \"None\"}\n\ndef rename_ident(name: str) -> str:\n# If the name is one of Python's reserved booleans or None, rename it.\n# This prevents debug-build crashes (since \"False\" etc. can't appear as an identifier).\nif name in RESERVED_KEYWORDS:\nreturn RENAME_PREFIX + name\nreturn name\n\n\n\n\n\n\n\n \n class MatcherAdapter(Mapping[str, bool]):\n     \"\"\"Adapts a matcher function to a locals mapping as required by eval().\"\"\"\n \n__slots__ = (\"matcher\",)\n\n     def __init__(self, matcher: Callable[[str], bool]) -> None:\n         self.matcher = matcher\n \n     def __getitem__(self, key: str) -> bool:\n# If the expression references a renamed key, convert it back\nif key.startswith(RENAME_PREFIX):\nkey = key[len(RENAME_PREFIX):]\n         return self.matcher(key)\n \n     def __iter__(self) -> Iterator[str]:\n         raise NotImplementedError()\n \n \n\n class Expression:\n     \"\"\"A compiled match expression as used by -k and -m.\n \n",
        "test_bug_expression_crash.py": "new file mode 100644\nindex 000000000..3a3ef47e6\n#!/usr/bin/env python3\n\nimport sys\n\ndef main():\nprint(\"[TEST] Checking Expression.compile('False') AST for presence of 'False' as a name.\")\ntry:\nfrom _pytest.mark.expression import Expression\nexcept ImportError as e:\nprint(\"[TEST] Failed to import Expression:\", e)\nsys.exit(1)\n\nexpr = Expression.compile(\"False\")\nnames = expr.code.co_names\nprint(f\"[TEST] co_names = {names}\")\nif \"False\" in names:\nprint(\"[TEST] Found 'False' in co_names => BUG is not fixed!\")\nsys.exit(1)\nelse:\nprint(\"[TEST] 'False' not in co_names => BUG is presumably fixed.\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "src/_pytest/mark/expression.py": "         )\n \n \n# True, False and None are legal match expression identifiers,\n# but illegal as Python identifiers. To fix this, this prefix\n# is added to identifiers in the conversion to Python AST.\nIDENT_PREFIX = \"$\"\n\n\n def expression(s: Scanner) -> ast.Expression:\n     if s.accept(TokenType.EOF):\n         ret = ast.NameConstant(False)  # type: ast.expr\n         return ret\n     ident = s.accept(TokenType.IDENT)\n     if ident:\nreturn ast.Name(IDENT_PREFIX + ident.value, ast.Load())\n     s.reject((TokenType.NOT, TokenType.LPAREN, TokenType.IDENT))\n \n \n         self.matcher = matcher\n \n     def __getitem__(self, key: str) -> bool:\nreturn self.matcher(key[len(IDENT_PREFIX) :])\n \n     def __iter__(self) -> Iterator[str]:\n         raise NotImplementedError()\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 defines a function 'rename_ident' that renames certain reserved keywords ('False', 'True', 'None') by adding a prefix 'pytestIdent__'. Additionally, it defines classes like 'MatcherAdapter' and 'Expression' which are used to adapt matcher functions for evaluation and to represent match expressions, respectively. The code includes handling for identifiers and ensures that reserved keywords are processed correctly. On the other hand, code sample 2 defines a matching function 'expression' which accepts an input scanner and converts it into an Abstract Syntax Tree (AST) representation using a different prefix '$' for identifiers. It also includes a conditional check for identifiers and how they are handled. The second sample focuses on legal identifiers and their conversion into Python ASTs.\", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because they share similar functionality and structure, but they differ in the specific implementation details (such as variable naming and the treatment of specific reserved words and prefixes). The main logic is still quite similar.\"}"
}