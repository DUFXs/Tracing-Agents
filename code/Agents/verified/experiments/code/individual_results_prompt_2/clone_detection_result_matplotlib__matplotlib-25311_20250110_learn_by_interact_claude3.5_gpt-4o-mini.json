{
    "instance_id": "matplotlib__matplotlib-25311",
    "agent": "20250110_learn_by_interact_claude3.5",
    "agent_patch": {
        "lib/matplotlib/legend.py": "index ff6abdb958..835f5f01be 100644\n \n         super().__init__(legend, legend._legend_box, use_blit=use_blit)\n \ndef __getstate__(self):\n# Return a reduced state for pickling\nstate = self.__dict__.copy()\n# Remove unpicklable canvas reference\nstate.pop('canvas', None)\nstate.pop('background', None)\nstate.pop('_last_pos', None)\nreturn state\n\ndef __setstate__(self, state):\n# Restore instance attributes\nself.__dict__.update(state)\n# Initialize canvas-dependent attributes as None\nself.canvas = None\nself.background = None\nself._last_pos = None\n\n     def finalize_offset(self):\n         if self._update == \"loc\":\n             self._update_loc(self.get_loc_in_canvas())\n         raise TypeError('Invalid arguments to legend.')\n \n     return handles, labels, extra_args, kwargs\n\n",
        "reproduce_bug.py": "new file mode 100644\nindex 0000000000..92ff6b89d0\nimport matplotlib\nmatplotlib.use('Qt5Agg')  # Force Qt backend\nimport matplotlib.pyplot as plt\nimport pickle\n\nfig = plt.figure()\nax = fig.add_subplot(111)\n\ntime=[0,1,2,3,4]\nspeed=[40,43,45,47,48]\n\nax.plot(time,speed,label=\"speed\")\n\nleg=ax.legend()\nleg.set_draggable(True)  # This line causes the pickling error\n\ntry:\npickle.dumps(fig)\nprint(\"Successfully pickled figure!\")\nexcept Exception as e:\nprint(f\"Error pickling figure: {str(e)}\")\n\nplt.close()\n\n",
        "test_legend_pickle.py": "new file mode 100644\nindex 0000000000..19d1817039\nimport matplotlib.pyplot as plt\nimport pickle\n\n# Create a figure with draggable legend\nfig = plt.figure()\nax = fig.add_subplot(111)\n\ntime=[0,1,2,3,4]\nspeed=[40,43,45,47,48]\n\nax.plot(time,speed,label=\"speed\")\n\nleg=ax.legend()\nleg.set_draggable(True)\n\n# Test pickling\ntry:\n# Try to pickle the figure\npickled_data = pickle.dumps(fig)\nprint(\"Successfully pickled figure!\")\n\n# Try to unpickle and verify\nunpickled_fig = pickle.loads(pickled_data)\nprint(\"Successfully unpickled figure!\")\n\n# Verify the legend is still draggable\nunpickled_leg = unpickled_fig.axes[0].get_legend()\nif hasattr(unpickled_leg, '_draggable'):\nprint(\"Legend is still draggable!\")\nelse:\nprint(\"Error: Legend lost draggable state!\")\n\nexcept Exception as e:\nprint(f\"Error: {str(e)}\")\n"
    },
    "ground_truth_patch": {
        "lib/matplotlib/offsetbox.py": "         if not ref_artist.pickable():\n             ref_artist.set_picker(True)\n         self.got_artist = False\n         self._use_blit = use_blit and self.canvas.supports_blit\n         self.cids = [\n             self.canvas.callbacks._connect_picklable(\n                 'button_release_event', self.on_release),\n         ]\n \n# A property, not an attribute, to maintain picklability.\ncanvas = property(lambda self: self.ref_artist.figure.canvas)\n\n     def on_motion(self, evt):\n         if self._check_still_parented() and self.got_artist:\n             dx = evt.x - self.mouse_x\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is focused on setting up a legend in a Matplotlib plot, implementing methods for pickling and unpickling a figure, while ensuring that certain attributes are removed to maintain compatibility with pickling, specifically when dealing with draggable legends. The code includes methods to finalize offsets and handle state management for pickling. In contrast, code sample 2 contains logic specifically related to managing pickability of artists in a Matplotlib drawing context, dealing with events like motion and button releases, as well as defining a property for canvas access. These two code samples pertain to different functionalities within the Matplotlib library and do not share structural or functional similarities. Therefore, they are not clones.\", \"is_clone\": false, \"classification\": \"N/A\", \"reasoning\": \"These code samples are not clones because they serve different purposes within the Matplotlib library regarding plot legend management and event handling, and they do not share significant syntactic or functional similarities.\"}"
}