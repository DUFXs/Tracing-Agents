{
    "instance_id": "django__django-16100",
    "agent": "20250117_wandb_programmer_o1_crosscheck5",
    "agent_patch": {
        "django/contrib/admin/options.py": "index 5f07a4208a..6a63a368dd 100644\n             return queryset\n         return queryset.filter(pk__in=object_pks)\n \n     def changelist_view(self, request, extra_context=None):\n         \"\"\"\n         The 'change list' admin view for this model.\n         \"\"\"\n         from django.contrib.admin.views.main import ERROR_FLAG\n\n         app_label = self.opts.app_label\n         if not self.has_view_or_change_permission(request):\n             raise PermissionDenied\n\n         try:\n             cl = self.get_changelist_instance(request)\n         except IncorrectLookupParameters:\n                     },\n                 )\n             return HttpResponseRedirect(request.path + \"?\" + ERROR_FLAG + \"=1\")\n\n         # If the request was POSTed, this might be a bulk action or a bulk\n         # edit. Try to look up an action or confirmation first, but if this\n         # isn't an action the POST will fall through to the bulk edit check,\n         # below.\n         action_failed = False\n         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n\n         actions = self.get_actions(request)\n         # Actions with no confirmation\n         if (\n             and \"_save\" not in request.POST\n         ):\n             if selected:\nresponse = self.response_action(request, queryset=cl.get_queryset(request))\n                 if response:\n                     return response\n                 else:\n                 )\n                 self.message_user(request, msg, messages.WARNING)\n                 action_failed = True\n\n         # Actions with confirmation\n         if (\n             actions\n             and \"_save\" not in request.POST\n         ):\n             if selected:\nresponse = self.response_action(request, queryset=cl.get_queryset(request))\n                 if response:\n                     return response\n                 else:\n                     action_failed = True\n\n         if action_failed:\n             # Redirect back to the changelist page to avoid resubmitting the\n             # form if the user refreshes the browser or uses the \"No, take\n             # me back\" button on the action confirmation page.\n             return HttpResponseRedirect(request.get_full_path())\n\n         # If we're allowing changelist editing, we need to construct a formset\n         # for the changelist given all the fields to be edited. Then we'll\n         # use the formset to validate/process POSTed data.\n         formset = cl.formset = None\n\n         # Handle POSTed bulk-edit data.\n         if request.method == \"POST\" and cl.list_editable and \"_save\" in request.POST:\n             if not self.has_change_permission(request):\n                 request.POST, request.FILES, queryset=modified_objects\n             )\n             if formset.is_valid():\nfrom django.db import transaction, router\nwith transaction.atomic(using=router.db_for_write(self.model)):\nchangecount = 0\nfor form in formset.forms:\nif form.has_changed():\nobj = self.save_form(request, form, change=True)\nself.save_model(request, obj, form, change=True)\nself.save_related(request, form, formsets=[], change=True)\nchange_msg = self.construct_change_message(request, form, None)\nself.log_change(request, obj, change_msg)\nchangecount += 1\n\nif changecount:\nmsg = ngettext(\n\"%(count)s %(name)s was changed successfully.\",\n\"%(count)s %(name)s were changed successfully.\",\nchangecount,\n) % {\n\"count\": changecount,\n\"name\": model_ngettext(self.opts, changecount),\n}\nself.message_user(request, msg, messages.SUCCESS)\n\n                 return HttpResponseRedirect(request.get_full_path())\n\n         # Handle GET -- construct a formset for display.\n         elif cl.list_editable and self.has_change_permission(request):\n             FormSet = self.get_changelist_formset(request)\n             formset = cl.formset = FormSet(queryset=cl.result_list)\n\n         # Build the list of media to be used by the formset.\n         if formset:\n             media = self.media + formset.media\n         else:\n             media = self.media\n\n         # Build the action form and populate it with available actions.\n         if actions:\n             action_form = self.action_form(auto_id=None)\n             media += action_form.media\n         else:\n             action_form = None\n\n         selection_note_all = ngettext(\n             \"%(total_count)s selected\", \"All %(total_count)s selected\", cl.result_count\n         )\n\n         context = {\n             **self.admin_site.each_context(request),\n             \"module_name\": str(self.opts.verbose_name_plural),\n             \"preserved_filters\": self.get_preserved_filters(request),\n             **(extra_context or {}),\n         }\n\n         request.current_app = self.admin_site.name\n\n         return TemplateResponse(\n             request,\n             self.change_list_template\n             ],\n             context,\n         )\n\n \n     def get_deleted_objects(self, objs, request):\n         \"\"\"\n",
        "migrations/0001_initial.py": "new file mode 100644\nindex 0000000000..6cd94addd2\n# Generated by Django 4.2.dev20221006100400 on 2025-01-13 05:22\n\nfrom django.db import migrations, models\n\n\nclass Migration(migrations.Migration):\n\ninitial = True\n\ndependencies = []\n\noperations = [\nmigrations.CreateModel(\nname=\"AtomicTestModel\",\nfields=[\n(\n\"id\",\nmodels.AutoField(\nauto_created=True,\nprimary_key=True,\nserialize=False,\nverbose_name=\"ID\",\n),\n),\n(\"name\", models.CharField(max_length=100, unique=True)),\n(\"value\", models.IntegerField()),\n],\n),\n]\n",
        "migrations/__init__.py": "new file mode 100644\nindex 0000000000..e69de29bb2\n",
        "test_changelist_atomic.py": "new file mode 100644\nindex 0000000000..c94af924ff\nimport sys\n\nfrom django.conf import settings\n\nsettings.configure(\nSECRET_KEY='test',\nINSTALLED_APPS=[\n'django.contrib.contenttypes',\n'django.contrib.auth',\n'django.contrib.sessions',\n'django.contrib.admin',\n'django.contrib.messages',\n],\nMIDDLEWARE=[\n'django.contrib.sessions.middleware.SessionMiddleware',\n'django.contrib.auth.middleware.AuthenticationMiddleware',\n'django.contrib.messages.middleware.MessageMiddleware',\n],\nROOT_URLCONF=__name__,\nDATABASES={\n'default': {\n'ENGINE': 'django.db.backends.sqlite3',\n'NAME': ':memory:',\n},\n},\nTEMPLATES=[{\n'BACKEND': 'django.template.backends.django.DjangoTemplates',\n'APP_DIRS': True,\n'OPTIONS': {\n'context_processors': [\n'django.contrib.auth.context_processors.auth',\n'django.contrib.messages.context_processors.messages',\n],\n},\n}],\nPASSWORD_HASHERS=['django.contrib.auth.hashers.MD5PasswordHasher'],\nUSE_I18N=False,\nUSE_L10N=False,\nUSE_TZ=False,\n)\n\nimport django\ndjango.setup()\n\nfrom django.urls import path\nfrom django.db import models, connection\nfrom django.contrib import admin\nfrom django.contrib.admin import AdminSite\nfrom django.contrib.auth.models import User\nfrom django.test import Client\nfrom django.core.management import call_command\n\nclass AtomicTestModel(models.Model):\nname = models.CharField(max_length=100, unique=True)\nvalue = models.IntegerField()\nclass Meta:\napp_label = 'contenttypes'\ndef __str__(self):\nreturn f\"{self.name} [{self.value}]\"\n\nclass AtomicTestModelAdmin(admin.ModelAdmin):\nlist_display = (\"name\", \"value\")\nlist_editable = (\"value\",)\n\nclass MyTestAdminSite(AdminSite):\nsite_header = \"My Test Admin\"\n\nmy_admin_site = MyTestAdminSite(name=\"my_test_admin\")\nmy_admin_site.register(AtomicTestModel, AtomicTestModelAdmin)\n\nurlpatterns = [\npath(\"testadmin/\", my_admin_site.urls),\n]\n\ndef main():\nprint(\"Starting test_changelist_atomic.py...\")\n\ncall_command(\"migrate\", interactive=False, verbosity=0)\n\nwith connection.schema_editor() as schema_editor:\nschema_editor.create_model(AtomicTestModel)\n\nUser.objects.create_superuser(\"admin\", \"admin@example.com\", \"password\")\n\nAtomicTestModel.objects.create(id=1, name=\"original1\", value=0)\nAtomicTestModel.objects.create(id=2, name=\"original2\", value=0)\n\nclient = Client()\nif not client.login(username=\"admin\", password=\"password\"):\nprint(\"ERROR: Could not log in as admin.\")\nsys.exit(2)\n\nchangelist_url = \"/testadmin/contenttypes/atomictestmodel/\"\nprint(f\"Requesting GET {changelist_url}\")\nget_resp = client.get(changelist_url)\nif get_resp.status_code != 200:\nprint(f\"ERROR: Expected 200 from GET, got {get_resp.status_code}\")\nsys.exit(2)\n\nprint(\"Submitting POST that will cause a unique constraint failure on the second object...\")\n\npost_data = {\n\"action\": \"\",\n\"index\": \"0\",\n\"form-TOTAL_FORMS\": \"2\",\n\"form-INITIAL_FORMS\": \"2\",\n\"form-MIN_NUM_FORMS\": \"0\",\n\"form-MAX_NUM_FORMS\": \"1000\",\n\"_save\": \"Save\",\n\"form-0-id\": \"1\",\n\"form-0-name\": \"duplicate\",\n\"form-0-value\": \"111\",\n\"form-1-id\": \"2\",\n\"form-1-name\": \"duplicate\",\n\"form-1-value\": \"222\",\n}\npost_resp = client.post(changelist_url, post_data)\nprint(f\"POST returned status code {post_resp.status_code}\")\n\nobj1 = AtomicTestModel.objects.get(pk=1)\nobj2 = AtomicTestModel.objects.get(pk=2)\n\nprint(f\"After POST, obj1=(id=1, name={obj1.name}, value={obj1.value}), obj2=(id=2, name={obj2.name}, value={obj2.value})\")\n\nif obj1.name == \"duplicate\":\nprint(\"FAIL: Partial update detected (obj1 changed despite error on obj2).\")\nsys.exit(1)\nelse:\nprint(\"PASS: No partial update. Changes were rolled back on error.\")\nsys.exit(0)\n\nif __name__ == \"__main__\":\nmain()\n"
    },
    "ground_truth_patch": {
        "django/contrib/admin/options.py": "             )\n             if formset.is_valid():\n                 changecount = 0\nwith transaction.atomic(using=router.db_for_write(self.model)):\nfor form in formset.forms:\nif form.has_changed():\nobj = self.save_form(request, form, change=True)\nself.save_model(request, obj, form, change=True)\nself.save_related(request, form, formsets=[], change=True)\nchange_msg = self.construct_change_message(\nrequest, form, None\n)\nself.log_change(request, obj, change_msg)\nchangecount += 1\n                 if changecount:\n                     msg = ngettext(\n                         \"%(count)s %(name)s was changed successfully.\",\n"
    },
    "response": "{\"explanation\": \"The code in code sample 1 is part of a Django admin view that processes changes made to a list of objects, handles bulk edits, and manages responses based on whether the edit was successful or not. Specifically, it sets up a transaction to save modified objects and log the changes, while also constructing messages to notify the user. In contrast, the code in code sample 2 is a snippet that focuses on a smaller section of the same logic, particularly the part where it validates a formset, processes each form for changes, saves them, and constructs a change message. The second sample also focuses on the success message that is displayed after successful changes.\", \"is_clone\": true, \"classification\": \"type-3\", \"reasoning\": \"These code samples are type-3 clones because while they share syntactic similarity, the second code sample is a reduced excerpt from the first and does not represent the complete functionality. Additionally, there are some differences and omissions in the way the snippets are structured, which classify them as syntactically similar but with modified content.\"}"
}